! $Id$
!
! Earth System Modeling Framework
! Copyright 2002-2019, University Corporation for Atmospheric Research,
! Massachusetts Institute of Technology, Geophysical Fluid Dynamics
! Laboratory, University of Michigan, National Centers for Environmental
! Prediction, Los Alamos National Laboratory, Argonne National Laboratory,
! NASA Goddard Space Flight Center.
! Licensed under the University of Illinois-NCSA License.
!
!==============================================================================
^define ESMF_FILENAME "ESMF_AttributeInternals.F90"
!==============================================================================
!
! ESMF Attribute Internals Module
!
! (all lines between the !BOP and !EOP markers will be included in the
! automated document processing.)
!------------------------------------------------------------------------------
! one blank line for protex processing - in case all routines here are
! marked internal (BOPI/EOPI), the output file will still have contents.
!BOP

!EOP

!------------------------------------------------------------------------------
! module definition

module ESMF_AttributeInternalsMod
!
!------------------------------------------------------------------------------
! INCLUDES
^include "ESMF.h"
#include "ESMF_TypeKindMacros.hcppF90"
^ifndef ESMF_NO_INTEGER_1_BYTE
^define ESMF_NO_INTEGER_1_BYTE
^endif
^ifndef ESMF_NO_INTEGER_2_BYTE
^define ESMF_NO_INTEGER_2_BYTE
^endif

!==============================================================================
!BOPI
! !MODULE: ESMF_AttributeInternalsMod - Attribute API helper functions
!
! !DESCRIPTION:
!
! The helper functions for the Attribute API.
!
!------------------------------------------------------------------------------
! !USES:
  use ESMF_BaseMod
  use ESMF_UtilTypesMod     ! ESMF utility types
  use ESMF_InitMacrosMod    ! ESMF initializer macros
  use ESMF_LogErrMod        ! ESMF error handling
  use ESMF_GridMod
  use ESMF_StaggerLocMod

  implicit none

!------------------------------------------------------------------------------
! !PRIVATE TYPES:
  private


!------------------------------------------------------------------------------
!
! !DESCRIPTION:
!
! !PUBLIC MEMBER FUNCTIONS:
!
      
  public ESMF_AttributeGetInfo
  public AttributeInternalInfo
  public extractInfoInt, extractInfoValueString
  public getGridCoordsR4, getGridCoordsR8
    
  interface ESMF_AttributeGetInfo
    module procedure ESMF_GridAttGetInfoI4
    module procedure ESMF_GridAttGetInfoChar
    module procedure ESMF_GridAttGetInfoI4List
    module procedure ESMF_GridAttGetInfoR4List
    module procedure ESMF_GridAttGetInfoR8List
    module procedure ESMF_GridAttGetInfoLogicalList
  end interface

!==============================================================================
!
! INTERFACE BLOCKS
!
!==============================================================================

!EOPI 
!------------------------------------------------------------------------------
! leave the following line as-is; it will insert the cvs ident string
! into the object file for tracking purposes.
      character(*), parameter, private :: version = &
               '$Id$'
!------------------------------------------------------------------------------

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

contains

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_AttGetInfo"
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeGetInfo - Get internal Attribute info
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeGetInfo()
      subroutine ESMF_GridAttGetInfoI4(grid, name, value, inputList, rc)
!
! !ARGUMENTS:
      type(ESMF_Grid), intent(in) :: grid
      character (len = *), intent(in) :: name
      integer(ESMF_KIND_I4), intent(out) :: value
      character(len=*), intent(in), optional :: inputList(:)
      integer, intent(out), optional :: rc

!
! !DESCRIPTION:
!     Returns internal info from the object.
!
!     The arguments are:
!     \begin{description}
!     \item [grid]
!           An ESMF object.
!     \item [name]
!           The name of the Attribute to retrieve.
!     \item [value]
!           The value of the internal info.
!     \item [inputList]
!           A list containing input information needed to retrieve info.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc
      integer :: localDel, i
      character(len=ESMF_MAXSTR) :: msgbuf

      ! Initialize
      localrc = ESMF_RC_NOT_IMPL
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      localDel = 0

      ! check variables
      ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc)

      ! retrieve input values
      if (present(inputList)) then
        do i=1,size(inputList)
          if (index(inputList(i), "localDe") /= 0) then
            localDel = extractInfoInt(inputList(i))
          endif
        enddo
      endif

      ! retrieve list type info that does not require additional inputs
      select case (name)
        case ("dimCount")
          call ESMF_GridGet(grid, dimCount=value, rc=localrc)
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) return
        case ("tileCount")
          call ESMF_GridGet(grid, tileCount=value, rc=localrc)
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) return
        case ("staggerlocCount")
          call ESMF_GridGet(grid, staggerlocCount=value, rc=localrc)
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) return
        case ("localDECount")
          call ESMF_GridGet(grid, localDECount=value, rc=localrc)
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) return
        case ("arbDim")
          call ESMF_GridGet(grid, arbDim=value, rc=localrc)
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) return
        case ("rank")
          call ESMF_GridGet(grid, rank=value, rc=localrc)
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) return
        case ("arbDimCount")
          call ESMF_GridGet(grid, arbDimCount=value, rc=localrc)
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) return
        case("arbIndexCount") ! requires localDe
          call ESMF_GridGet(grid, localDe=localDel, arbIndexCount=value, &
                            rc=localrc)
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) return
        case DEFAULT
          write (msgbuf, *) "The provided 'name' (", trim(name), ") does not correspond to internal info"
          call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, &
            msg=msgbuf, &
            ESMF_CONTEXT, rcToReturn=rc)
          return
      end select

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_GridAttGetInfoI4
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_AttGetInfo"
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeGetInfo - Get internal Attribute info
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeGetInfo()
      subroutine ESMF_GridAttGetInfoChar(grid, name, value, rc)
!
! !ARGUMENTS:
      type(ESMF_Grid), intent(in) :: grid
      character (len = *), intent(in) :: name
      character (len = *), intent(out) :: value
      integer, intent(out), optional :: rc

!
! !DESCRIPTION:
!     Returns internal info from the object.
!
!     The arguments are:
!     \begin{description}
!     \item [grid]
!           An ESMF object.
!     \item [name]
!           The name of the Attribute to retrieve.
!     \item [value]
!           The value of the internal info.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      type(ESMF_TypeKind_Flag)   :: lcoordTypeKind
      type(ESMF_Index_Flag)      :: lindexflag
      type(ESMF_GridStatus_Flag) :: lstatus

      integer :: localrc

      ! Initialize
      localrc = ESMF_RC_NOT_IMPL
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check variables
      ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc)

      select case (name)
        case ("coordTypeKind")
          call ESMF_GridGet(grid, coordTypeKind=lcoordTypeKind, rc=localrc)
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) return
          ! assign the string value of this named constant
          value = lcoordTypeKind
        case ("indexflag")
          call ESMF_GridGet(grid, indexflag=lindexflag, rc=localrc)
          ! assign the string value of this named constant
          value = lindexflag
        case ("status")
          call ESMF_GridGet(grid, status=lstatus, rc=localrc)
          ! assign the string value of this named constant
          value = lstatus
        case ("name")
          call ESMF_GridGet(grid, name=value, rc=localrc)
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) return
        case DEFAULT
          call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, &
            msg="The provided 'name' does not correspond to internal info", &
            ESMF_CONTEXT, rcToReturn=rc)
          return
      end select

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_GridAttGetInfoChar
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_AttGetInfo"
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeGetInfo - Get internal Attribute info
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeGetInfo()
      subroutine ESMF_GridAttGetInfoI4List(grid, name, valueList, &
                                            inputList, rc)
!
! !ARGUMENTS:
      type(ESMF_Grid), intent(in) :: grid
      character(len=*), intent(in) :: name
      integer(ESMF_KIND_I4), intent(out) :: valueList(:)
      character(len=*), intent(in), optional :: inputList(:)
      integer, intent(out), optional :: rc

!
! !DESCRIPTION:
!     Returns internal info from the object.
!
!     The arguments are:
!     \begin{description}
!     \item [grid]
!           An ESMF object.
!     \item [name]
!           The name of the Attribute to retrieve.
!     \item [valueList]
!           The valueList of the internal info.
!     \item [inputList]
!           A list containing input information needed to retrieve info.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc, i
      
      integer :: localDel
      type(ESMF_StaggerLoc) :: staggerlocl
      integer :: tilel
      integer :: coordDiml
      type(ESMF_GridItem_Flag) :: itemflagl

      logical :: getLDe, getStagger, getTile, getCoord, getItem

      ! Initialize
      localrc = ESMF_RC_NOT_IMPL
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! setting default values
      localDel = 0
      staggerlocl = ESMF_STAGGERLOC_CENTER
      tilel = 1
      ! coorddim and itemflag cannot default
      getCoord = .false.
      getItem = .false.

      ! check variables
      ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc)

      ! looking for required input parameters
      if (present(inputList)) then
        do i=1,size(inputList)
          !!!! TODO: this can go away once modName is dynamically sized !!!
          if (len(inputList(i)) > ESMF_MAXSTR) then
            call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, &
              msg="len(inputList(i)) cannot be larger than ESMF_MAXSTR for now", &
              ESMF_CONTEXT, rcToReturn=rc)
            return
          endif
          ! set the parameters based on the inputList
          if (index(inputList(i), "localDe") /= 0) then
            localDel = extractInfoInt(inputList(i))
          elseif (index(inputList(i), "staggerloc") /= 0) then
            staggerlocl = extractInfoValueString(inputList(i))
          elseif (index(inputList(i), "tile") /= 0) then
            tilel = extractInfoInt(inputList(i))
          elseif (index(inputList(i), "coordDim") /= 0) then
            coordDiml = extractInfoInt(inputList(i))
            getCoord = .true.
          elseif (index(inputList(i), "itemflag") /= 0) then
            itemflagl = extractInfoValueString(inputList(i))
            getItem = .true.
          endif
        enddo
      endif

      ! TODO: if both getCoord and getItem are both true fault
      
      ! TODO: case("coord") ! requires index(:), localDe and staggerloc

      ! retrieve list type info
      select case (name)
        case ("distgridToGridMap")
          call ESMF_GridGet(grid, distgridToGridMap=valueList, rc=localrc)
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) return
        case ("coordDimCount")
          call ESMF_GridGet(grid, coordDimCount=valueList, rc=localrc)
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) return
        case ("gridEdgeLWidth")
          call ESMF_GridGet(grid, gridEdgeLWidth=valueList, rc=localrc)
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) return
        case ("gridEdgeUWidth")
          call ESMF_GridGet(grid, gridEdgeUWidth=valueList, rc=localrc)
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) return
        case ("gridAlign")
          call ESMF_GridGet(grid, gridAlign=valueList, rc=localrc)
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) return
      ! retrieve list type info that DOES require additional inputs
        case("minIndex")
          call ESMF_GridGet(grid, tile=tilel, staggerloc=staggerlocl, &
                            minIndex=valueList, rc=localrc)
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) return
        case("maxIndex")
          call ESMF_GridGet(grid, tile=tilel, staggerloc=staggerlocl, &
                            maxIndex=valueList, rc=localrc)
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) return
        case("exclusiveLBound")
          if (getCoord) then
            call ESMF_GridGetCoordBounds(grid, coordDim=coordDiml, &
                              staggerloc=staggerlocl, localDe=localDel, &
                              exclusiveLBound=valueList, rc=localrc)
          elseif (getItem) then
            call ESMF_GridGetItemBounds(grid, itemflag=itemflagl, &
                              staggerloc=staggerlocl, localDe=localDel, &
                              exclusiveLBound=valueList, rc=localrc)
          else
            call ESMF_GridGet(grid, staggerloc=staggerlocl, localDe=localDel, &
                              exclusiveLBound=valueList, rc=localrc)
          endif
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) return
        case("exclusiveUBound")
          if (getCoord) then
            call ESMF_GridGetCoordBounds(grid, coordDim=coordDiml, &
                              staggerloc=staggerlocl, localDe=localDel, &
                              exclusiveUBound=valueList, rc=localrc)
          elseif (getItem) then
            call ESMF_GridGetItemBounds(grid, itemflag=itemflagl, &
                              staggerloc=staggerlocl, localDe=localDel, &
                              exclusiveUBound=valueList, rc=localrc)
          else
            call ESMF_GridGet(grid, staggerloc=staggerlocl, localDe=localDel, &
                              exclusiveUBound=valueList, rc=localrc)
          endif
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) return
        case("exclusiveCount")
          if (getCoord) then
            call ESMF_GridGetCoordBounds(grid, coordDim=coordDiml, &
                              staggerloc=staggerlocl, localDe=localDel, &
                              exclusiveCount=valueList, rc=localrc)
          elseif (getItem) then
            call ESMF_GridGetItemBounds(grid, itemflag=itemflagl, &
                              staggerloc=staggerlocl, localDe=localDel, &
                              exclusiveCount=valueList, rc=localrc)
          else
            call ESMF_GridGet(grid, staggerloc=staggerlocl, localDe=localDel, &
                              exclusiveCount=valueList, rc=localrc)
          endif
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) return
        case("computationalLBound")
          if (getCoord) then
            call ESMF_GridGetCoordBounds(grid, coordDim=coordDiml, &
                              staggerloc=staggerlocl, localDe=localDel, &
                              computationalLBound=valueList, rc=localrc)
          elseif (getItem) then
            call ESMF_GridGetItemBounds(grid, itemflag=itemflagl, &
                              staggerloc=staggerlocl, localDe=localDel, &
                              computationalLBound=valueList, rc=localrc)
          else
            call ESMF_GridGet(grid, staggerloc=staggerlocl, localDe=localDel, &
                              computationalLBound=valueList, rc=localrc)
          endif
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) return
        case("computationalUBound")
          if (getCoord) then
            call ESMF_GridGetCoordBounds(grid, coordDim=coordDiml, &
                              staggerloc=staggerlocl, localDe=localDel, &
                              computationalUBound=valueList, rc=localrc)
          elseif (getItem) then
            call ESMF_GridGetItemBounds(grid, itemflag=itemflagl, &
                              staggerloc=staggerlocl, localDe=localDel, &
                              computationalUBound=valueList, rc=localrc)
          else
            call ESMF_GridGet(grid, staggerloc=staggerlocl, localDe=localDel, &
                              computationalUBound=valueList, rc=localrc)
          endif
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) return
        case("computationalCount")
          if (getCoord) then
            call ESMF_GridGetCoordBounds(grid, coordDim=coordDiml, &
                              staggerloc=staggerlocl, localDe=localDel, &
                              computationalCount=valueList, rc=localrc)
          elseif (getItem) then
            call ESMF_GridGetItemBounds(grid, itemflag=itemflagl, &
                              staggerloc=staggerlocl, localDe=localDel, &
                              computationalCount=valueList, rc=localrc)
          else
            call ESMF_GridGet(grid, staggerloc=staggerlocl, localDe=localDel, &
                              computationalCount=valueList, rc=localrc)
          endif
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) return
        case("totalLBound")
          if (getCoord) then
            call ESMF_GridGetCoordBounds(grid, coordDim=coordDiml, &
                              staggerloc=staggerlocl, localDe=localDel, &
                              totalLBound=valueList, rc=localrc)
          elseif (getItem) then
            call ESMF_GridGetItemBounds(grid, itemflag=itemflagl, &
                              staggerloc=staggerlocl, localDe=localDel, &
                              totalLBound=valueList, rc=localrc)
          endif
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) return
        case("totalUBound")
          if (getCoord) then
            call ESMF_GridGetCoordBounds(grid, coordDim=coordDiml, &
                              staggerloc=staggerlocl, localDe=localDel, &
                              totalUBound=valueList, rc=localrc)
          elseif (getItem) then
            call ESMF_GridGetItemBounds(grid, itemflag=itemflagl, &
                              staggerloc=staggerlocl, localDe=localDel, &
                              totalUBound=valueList, rc=localrc)
          endif
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) return
        case("totalCount")
          if (getCoord) then
            call ESMF_GridGetCoordBounds(grid, coordDim=coordDiml, &
                              staggerloc=staggerlocl, localDe=localDel, &
                              totalCount=valueList, rc=localrc)
          elseif (getItem) then
            call ESMF_GridGetItemBounds(grid, itemflag=itemflagl, &
                              staggerloc=staggerlocl, localDe=localDel, &
                              totalCount=valueList, rc=localrc)
          endif
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) return
        case DEFAULT
          call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, &
            msg="The provided 'name' does not correspond to internal info", &
            ESMF_CONTEXT, rcToReturn=rc)
          return
      end select

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_GridAttGetInfoI4List
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
#define AttGetInfoMacro(mtypekind) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGetInfo" @\
!--------------------------------------------------------------------------- @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGetInfo - Get internal Attribute info @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGetInfo() @\
      subroutine ESMF_GridAttGetInfo##mtypekind##List(grid, name, valueList, & @\
                                            inputList, rc) @\
! @\
! !ARGUMENTS: @\
      type(ESMF_Grid), intent(in) :: grid @\
      character(len=*), intent(in) :: name @\
      real(ESMF_KIND_##mtypekind), intent(out) :: valueList(:) @\
      character(len=*), intent(in), optional :: inputList(:) @\
      integer, intent(out), optional :: rc @\
 @\
! @\
! !DESCRIPTION: @\
!     Returns internal info from the object. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [grid] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to retrieve. @\
!     \item [valueList] @\
!           The valueList of the internal info. @\
!     \item [inputList] @\
!           A list containing input information needed to retrieve info. @\
!     \item [{[rc]}] @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc @\
 @\
      integer :: i @\
      integer :: localDel @\
      type(ESMF_StaggerLoc) :: staggerlocl @\
      integer :: coordDiml @\
      logical :: getLDe, getStagger, getCoord @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! setting default values @\
      localDel = 0 @\
      staggerlocl = ESMF_STAGGERLOC_CENTER @\
      ! coorddim cannot default @\
      getCoord = .false. @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) @\
 @\
      ! looking for required input parameters @\
      if (present(inputList)) then @\
        do i=1,size(inputList) @\
          !!!! TODO: this can go away once modName is dynamically sized !!! @\
          if (len(inputList(i)) > ESMF_MAXSTR) then @\
            call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & @\
              msg="len(inputList(i)) cannot be larger than ESMF_MAXSTR for now", & @\
              ESMF_CONTEXT, rcToReturn=rc) @\
            return @\
          endif @\
          ! set the parameters based on the inputList @\
          if (index(inputList(i), "localDe") /= 0) then @\
            localDel = extractInfoInt(inputList(i)) @\
          elseif (index(inputList(i), "staggerloc") /= 0) then @\
            staggerlocl = extractInfoValueString(inputList(i)) @\
          elseif (index(inputList(i), "coordDim") /= 0) then @\
            coordDiml = extractInfoInt(inputList(i)) @\
            getCoord = .true. @\
          endif @\
        enddo @\
      endif @\
 @\
      ! retrieve list type info that DOES NOT require additional inputs @\
      select case (name) @\
         case("farrayPtr") @\
          if (getCoord) then @\
            call getGridCoords##mtypekind(grid, coordDiml, valueList, & @\
              staggerloc=staggerlocl, localDe=localDel, rc=localrc) @\
            if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
              ESMF_CONTEXT, rcToReturn=rc)) return @\
          else @\
            call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & @\
              msg="The required argument 'coordDim' was not specified!", & @\
              ESMF_CONTEXT, rcToReturn=rc) @\
          endif @\
        case DEFAULT @\
          call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & @\
            msg="The provided 'name' does not correspond to internal info", & @\
            ESMF_CONTEXT, rcToReturn=rc) @\
          return @\
      end select @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine ESMF_GridAttGetInfo##mtypekind##List @\
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_AttGetInfo"
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeGetInfo - Get internal Attribute info
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeGetInfo()
      subroutine ESMF_GridAttGetInfoLogicalList(grid, name, valueList, &
                                                inputList, rc)
!
! !ARGUMENTS:
      type(ESMF_Grid), intent(in) :: grid
      character (len = *), intent(in) :: name
      logical, intent(out) :: valueList(:)
      character(len=*), intent(in), optional :: inputList(:)
      integer, intent(out), optional :: rc

!
! !DESCRIPTION:
!     Returns internal info from the object.
!
!     The arguments are:
!     \begin{description}
!     \item [grid]
!           An ESMF Grid object.
!     \item [name]
!           The name of the Attribute to retrieve.
!     \item [valueList]
!           The value list of the internal info.
!     \item [inputList]
!           A list containing input information needed to retrieve info.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc
      integer :: localDel
      integer :: i

      ! Initialize
      localrc = ESMF_RC_NOT_IMPL
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      localDel = 0

      ! check variables
      ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc)

      if (present(inputList)) then
        do i=1,size(inputList)
          if (index(inputList(i), "localDe") /= 0) then
            localDel = extractInfoInt(inputList(i))
          endif
        enddo
      else
        call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, &
          msg="No input information was given!", &
          ESMF_CONTEXT, rcToReturn=rc)
        return
      endif

      select case (name)
        case ("isLBound")
          call ESMF_GridGet(grid, localDe=localDel, isLBound=valueList, &
                            rc=localrc)
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) return
        case ("isUBound")
          call ESMF_GridGet(grid, localDe=localDel, isUBound=valueList, &
                            rc=localrc)
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) return
        case DEFAULT
          call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, &
            msg="The provided 'name' does not correspond to internal info", &
            ESMF_CONTEXT, rcToReturn=rc)
          return
      end select

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_GridAttGetInfoLogicalList
!------------------------------------------------------------------------------


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
! Helper routines
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


!------------------------------------------------------------------------------
#define getGridCoordsMacro(mtypekind) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "GetGridCoord" @\
!------------------------------------------------------------------------------ @\
!BOPI @\
! !IROUTINE: getGridCoords##mtypekind - extract ##mtypekind grid coordinates of a generic type @\
! @\
! !INTERFACE: @\
      subroutine getGridCoords##mtypekind(grid, coordDim, coords, & @\
                               staggerloc, localDe, rc) @\
 @\
! !ARGUMENTS: @\
      type(ESMF_Grid), intent(in) :: grid @\
      integer, intent(in) :: coordDim @\
      real(ESMF_KIND_##mtypekind), intent(out) :: coords(:) @\
      type(ESMF_StaggerLoc), intent(in), optional :: staggerloc @\
      integer, intent(in), optional :: localDe @\
      integer, intent(out), optional :: rc @\
 @\
! @\
! !DESCRIPTION: @\
!     Returns relevant information in proper format from the input string. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [grid] @\
!           An ESMF Grid object. @\
!     \item [coordDim] @\
!           The coordinate dimension from which to retrieve Grid coordinates. @\
!     \item [coords] @\
!           The deferred shape ESMF_KIND_R4 array to hold the Grid coordinates. @\
!     \item [{[staggerloc]}] @\
!           The stagger location from which to retrieve Grid coordinates. @\
!     \item [{[localDe]}] @\
!           The local DE from which to retrieve Grid coordinates. @\
!     \item [{[rc]}] @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc @\
      integer :: min_size, dimCount @\
 @\
      ! have to allocate pointers for all three possiblities of Grid size @\
      real(ESMF_KIND_##mtypekind), pointer :: coords1D(:) @\
      real(ESMF_KIND_##mtypekind), pointer :: coords2D(:,:) @\
      real(ESMF_KIND_##mtypekind), pointer :: coords3D(:,:,:) @\
      integer(ESMF_KIND_I4), dimension(3) :: exclusiveCount @\
      integer(ESMF_KIND_I4), dimension(3) :: exclusiveLBound, exclusiveUBound @\
 @\
      integer :: ind, i, j, k @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! get the dimcount @\
      call ESMF_GridGet(grid, dimCount=dimCount, rc=localrc) @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
      if (dimCount == 1) then @\
        ! get the coordinates @\
        call ESMF_GridGetCoord(grid, coordDim, staggerloc=staggerloc, & @\
                               localDe=localDe, farrayPtr=coords1D, & @\
                               exclusiveLBound=exclusiveLBound, & @\
                               exclusiveUBound=exclusiveUBound, & @\
                               exclusiveCount=exclusiveCount, rc=localrc) @\
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        ! check that valueList is large enough @\
        min_size = exclusiveCount(1) @\
        if (size(coords) < min_size) then @\
          call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & @\
            msg="The valueList size is not large enough!", & @\
            ESMF_CONTEXT, rcToReturn=rc) @\
          return @\
        endif @\
        ! fill the valueList with coordinates @\
        coords(exclusiveLBound(1):exclusiveUBound(1)) = coords1D @\
      else if (dimCount == 2) then @\
        ! get the coordinates @\
        call ESMF_GridGetCoord(grid, coordDim, staggerloc=staggerloc, & @\
                               localDe=localDe, farrayPtr=coords2D, & @\
                               exclusiveLBound=exclusiveLBound, & @\
                               exclusiveUBound=exclusiveUBound, & @\
                               exclusiveCount=exclusiveCount, rc=localrc) @\
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        ! check that valueList is large enough @\
        min_size = exclusiveCount(1)*exclusiveCount(2) @\
        if (size(coords) < min_size) then @\
          call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & @\
            msg="The valueList size is not large enough!", & @\
            ESMF_CONTEXT, rcToReturn=rc) @\
          return @\
        endif @\
        ! fill the valueList with coordinates @\
        ind = 1 @\
        do i=exclusiveLBound(1),exclusiveUBound(1) @\
          do j=exclusiveLBound(2),exclusiveUBound(2) @\
            coords(ind) = coords2D(i,j) @\
            ind = ind + 1 @\
          enddo @\
        enddo @\
      else if (dimCount == 3) then @\
        ! get the coordinates @\
        call ESMF_GridGetCoord(grid, coordDim, staggerloc=staggerloc, & @\
                               localDe=localDe, farrayPtr=coords3D, & @\
                               exclusiveLBound=exclusiveLBound, & @\
                               exclusiveUBound=exclusiveUBound, & @\
                               exclusiveCount=exclusiveCount, rc=localrc) @\
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        ! check that valueList is large enough @\
        min_size = exclusiveCount(1)*exclusiveCount(2)*exclusiveCount(3) @\
        if (size(coords) < min_size) then @\
          call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & @\
            msg="The valueList size is not large enough!", & @\
            ESMF_CONTEXT, rcToReturn=rc) @\
          return @\
        endif @\
        ! fill the valueList with coordinates @\
        ind = 1 @\
        do i=exclusiveLBound(1),exclusiveUBound(1) @\
          do j=exclusiveLBound(2),exclusiveUBound(2) @\
            do k=exclusiveLBound(3),exclusiveUBound(3) @\
              coords(ind) = coords3D(i,j,k) @\
              ind = ind + 1 @\
            enddo @\
          enddo @\
        enddo @\
      endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine getGridCoords##mtypekind @\
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "AttributeInternalInfo"
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: AttributeInternalInfo - Query for internal Attribute info
!
! !INTERFACE:
      function AttributeInternalInfo(name, modName)

! !RETURN VALUE:
      logical :: AttributeInternalInfo

! !ARGUMENTS:
      character (len = *), intent(in) :: name
      character (len = *), intent(out)   :: modName

!
! !DESCRIPTION:
!     Returns .true. if this name indicates Attribute internal info.
!
!     The arguments are:
!     \begin{description}
!     \item [name]
!           The name of the Attribute.
!     \item [modName]
!           The name of the Attribute without the tag (ESMF:).
!     \end{description}
!
!
!EOPI

      character(32), parameter :: exception_list(2) = (/  &
          ESMF_ATT_GRIDDED_DIM_LABELS,  &
          ESMF_ATT_UNGRIDDED_DIM_LABELS   &
      /)

      ! Initialize to false
      AttributeInternalInfo = .false.

      ! get the length of name
      if (len (name) >= 5) then
        if (name(1:5) == "ESMF:") then
          if (all (name /= exception_list)) then
            modName = name(6:)
            AttributeInternalInfo = .true.
          end if
        end if
      endif

      end function AttributeInternalInfo
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "extractInfo"
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: extractInfo - Get information out of string for AttributeGetInternal
!
! !INTERFACE:
      function extractInfoInt(string, rc)

! !RETURN VALUE:
      integer :: extractInfoInt

! !ARGUMENTS:
      character (len = *), intent(in) :: string
      integer, intent(out), optional :: rc

!
! !DESCRIPTION:
!     Returns relevant information in proper format from the input string.
!
!     The arguments are:
!     \begin{description}
!     \item [string]
!           The string containing the information to be extracted.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!!     \end{description}
!
!
!EOPI

      integer :: localrc
      integer :: ind
      ! TODO remove ESMF_MAXSTR
      character(len=ESMF_MAXSTR) :: temp

      ! Initialize
      localrc = ESMF_RC_NOT_IMPL
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! take everything after the colon, minus whitespace
      if (index(string, "=") == 0) then
        call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_VALUE, &
          msg="The format of the input info is incorrect", &
          ESMF_CONTEXT, rcToReturn=localrc)
        extractInfoInt = -1
        if (present(rc)) rc = localrc
        return
      else
        ind = index(string, "=")
        temp = trim(adjustl(string((ind+1):len(string))))
        ! convert 'temp' (string) to integer
        read (temp, '(i1)') extractInfoInt
      endif

      if (present(rc)) rc = ESMF_SUCCESS

      end function extractInfoInt
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "extractInfo"
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: extractInfo - Get information out of string for AttributeGetInternal
!
! !INTERFACE:
      function extractInfoValueString(string, rc)

! !RETURN VALUE:
      ! TODO remove ESMF_MAXSTR
      character (len=ESMF_MAXSTR) :: extractInfoValueString

! !ARGUMENTS:
      character (len=*), intent(in) :: string
      integer, intent(out), optional :: rc

!
! !DESCRIPTION:
!     Returns relevant information in proper format from the input string.
!
!     The arguments are:
!     \begin{description}
!     \item [string]
!           The string containing the information to be extracted.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!!     \end{description}
!
!
!EOPI

      integer :: localrc
      integer :: ind

      ! Initialize
      localrc = ESMF_RC_NOT_IMPL
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! take everything after the colon, minus whitespace
      if (index(string, "=") == 0) then
        call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_VALUE, &
          msg="The format of the input info is incorrect", &
          ESMF_CONTEXT, rcToReturn=localrc)
        extractInfoValueString = "-1"
        if (present(rc)) rc = localrc
        return
      else
        ind = index(string, "=")
        extractInfoValueString = trim(adjustl(string((ind+1):len(string))))
      endif

      if (present(rc)) rc = ESMF_SUCCESS
     
      end function extractInfoValueString
!------------------------------------------------------------------------------

!---------------------------Macro instantiations------------------------------!
getGridCoordsMacro(R4)
getGridCoordsMacro(R8)
AttGetInfoMacro(R4)
AttGetInfoMacro(R8)

!------------------------------------------------------------------------------
end module ESMF_AttributeInternalsMod
!------------------------------------------------------------------------------
