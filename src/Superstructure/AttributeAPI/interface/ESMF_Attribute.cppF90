! $Id$
!
! Earth System Modeling Framework
! Copyright 2002-2013, University Corporation for Atmospheric Research,
! Massachusetts Institute of Technology, Geophysical Fluid Dynamics
! Laboratory, University of Michigan, National Centers for Environmental
! Prediction, Los Alamos National Laboratory, Argonne National Laboratory,
! NASA Goddard Space Flight Center.
! Licensed under the University of Illinois-NCSA License.
!
!==============================================================================
^define ESMF_FILENAME "ESMF_Attribute.F90"
!==============================================================================
!
! ESMF Attribute Module
!
! (all lines between the !BOP and !EOP markers will be included in the
! automated document processing.)
!------------------------------------------------------------------------------
! one blank line for protex processing - in case all routines here are
! marked internal (BOPI/EOPI), the output file will still have contents.
!BOP

!EOP

!------------------------------------------------------------------------------
! module definition

module ESMF_AttributeMod
!
!------------------------------------------------------------------------------
! INCLUDES
^include "ESMF.h"
#include "ESMF_TypeKindMacros.hcppF90"
^ifndef ESMF_NO_INTEGER_1_BYTE
^define ESMF_NO_INTEGER_1_BYTE
^endif
^ifndef ESMF_NO_INTEGER_2_BYTE
^define ESMF_NO_INTEGER_2_BYTE
^endif

!==============================================================================
!BOPI
! !MODULE: ESMF_AttributeMod - Attribute API
!
! !DESCRIPTION:
!
! The code in this file implements the Attribute defined type
!  and functions.  This is an
!  interface to the actual C++ Attribute class implementation
!  in the ../../Infrastructure/Attribute dir.
!
! See the ESMF Developers Guide document for more details.
!
!------------------------------------------------------------------------------
! !USES:
  use ESMF_BaseMod
  use ESMF_UtilTypesMod     ! ESMF utility types
  use ESMF_InitMacrosMod    ! ESMF initializer macros
  use ESMF_LogErrMod        ! ESMF error handling
  use ESMF_ArrayMod
  use ESMF_ArrayBundleMod
  use ESMF_CompMod
  use ESMF_CplCompMod
  use ESMF_GridCompMod
  use ESMF_SciCompMod
  use ESMF_DistGridMod
  use ESMF_FieldMod
  use ESMF_FieldBundleMod
  use ESMF_GridMod
  use ESMF_StateTypesMod
  use ESMF_StateVaMod
  use ESMF_StateMod
  use ESMF_UtilMod
  use ESMF_VMMod
  use ESMF_AttributeInternalsMod

  implicit none

!------------------------------------------------------------------------------
! !PRIVATE TYPES:
  private

!------------------------------------------------------------------------------
! ! ESMF_Attribute
!
!------------------------------------------------------------------------------

 ! Fortran class type to hold pointer to C++ object
  type ESMF_Attribute
  sequence
  private
    type(ESMF_Pointer) :: this
    ESMF_INIT_DECLARE
  end type

!------------------------------------------------------------------------------
!
! !DESCRIPTION:
!     The following routines apply to {\tt ESMF\_Array}, {\tt ESMF\_ArrayBundle},
!     {\ESMF_DistGrid}, {\tt ESMF\_Field},{\tt ESMF\_FieldBundle}, {\tt ESMF\_Grid},
!     and {\tt ESMF\_State}.
!
! !PUBLIC MEMBER FUNCTIONS:
!
!   Classes
      public ESMF_Attribute

!  Attribute methods
      public ESMF_AttributeAdd
      public ESMF_AttributeCopy
      public ESMF_AttributeRemove
      public ESMF_AttributeGet
      public ESMF_AttributeLink
      public ESMF_AttributeLinkRemove
      public ESMF_AttributeSet
      public ESMF_AttributeUpdate
      public ESMF_AttributeRead
      public ESMF_AttributeWrite

      public ESMF_AttPackGet

!EOPI
!------------------------------------------------------------------------------
! leave the following line as-is; it will insert the cvs ident string
! into the object file for tracking purposes.
      character(*), parameter, private :: version = &
               '$Id$'
!------------------------------------------------------------------------------
!==============================================================================
!
! INTERFACE BLOCKS
!
!==============================================================================

!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttPackGet  - Get an Attribute package
!
! !INTERFACE:
	interface ESMF_AttPackGet

! !PRIVATE MEMBER FUNCTIONS:
		module procedure ESMF_ArrayAttPackGet
		module procedure ESMF_ArrayBundleAttPackGet
		module procedure ESMF_CplCompAttPackGet
		module procedure ESMF_GridCompAttPackGet
		module procedure ESMF_SciCompAttPackGet
		module procedure ESMF_DistGridAttPackGet
		module procedure ESMF_FieldAttPackGet
		module procedure ESMF_FieldBundleAttPackGet
		module procedure ESMF_GridAttPackGet
		module procedure ESMF_StateAttPackGet
! !DESCRIPTION:
!     This interface provides a single entry point for methods that retrieve
!     a handle to and Attribute package.

!EOPI
	end interface

!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeAdd  - Create Attribute packages
!
! !INTERFACE:
      interface ESMF_AttributeAdd

! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_ArrayAttAddPackCst
        module procedure ESMF_ArrayAttAddPackCstN
        module procedure ESMF_ArrayAttAddPackCstN1
        module procedure ESMF_ArrayAttAddPackStd
        module procedure ESMF_ArrayBundleAttAddPackCst
        module procedure ESMF_ArrayBundleAttAddPackCstN
        module procedure ESMF_ArrayBundleAttAddPackCstN1
        module procedure ESMF_ArrayBundleAttAddPackStd
        module procedure ESMF_CplCompAttAddPackStd
        module procedure ESMF_CplCompAttAddPackStdN
        module procedure ESMF_CplCompAttAddPackCst
        module procedure ESMF_CplCompAttAddPackCstN
        module procedure ESMF_CplCompAttAddPackCstN1
        module procedure ESMF_GridCompAttAddPackStd
        module procedure ESMF_GridCompAttAddPackStdN
        module procedure ESMF_GridCompAttAddPackCst
        module procedure ESMF_GridCompAttAddPackCstN
        module procedure ESMF_GridCompAttAddPackCstN1
        module procedure ESMF_SciCompAttAddPackStd
        module procedure ESMF_SciCompAttAddPackStdN
        module procedure ESMF_SciCompAttAddPackCst
        module procedure ESMF_SciCompAttAddPackCstN
        module procedure ESMF_SciCompAttAddPackCstN1
        module procedure ESMF_DistGridAttAddPackCst
        module procedure ESMF_DistGridAttAddPackCstN
        module procedure ESMF_DistGridAttAddPackCstN1
        module procedure ESMF_FieldAttAddPackStd
        module procedure ESMF_FieldAttAddPackCst
        module procedure ESMF_FieldAttAddPackCstN
        module procedure ESMF_FieldAttAddPackCstN1
        module procedure ESMF_FieldBundleAttAddPackCst
        module procedure ESMF_FieldBundleAttAddPackCstN
        module procedure ESMF_FieldBundleAttAddPackCstN1
        module procedure ESMF_GridAttAddPackStd
        module procedure ESMF_GridAttAddPackCst
        module procedure ESMF_GridAttAddPackCstN
        module procedure ESMF_GridAttAddPackCstN1
        module procedure ESMF_StateAttAddPackStd
        module procedure ESMF_StateAttAddPackCst
        module procedure ESMF_StateAttAddPackCstN
        module procedure ESMF_StateAttAddPackCstN1

! !DESCRIPTION:
!     This interface provides a single entry point for methods that create
!     an Attribute package.

!EOPI
      end interface

!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeCopy  - Copy an Attribute or hierarchy
!
! !INTERFACE:
      interface ESMF_AttributeCopy

! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_CplCompAttCopy
        module procedure ESMF_GridCompAttCopy
        module procedure ESMF_SciCompAttCopy
        module procedure ESMF_StateAttCopy

! !DESCRIPTION:
!     This interface provides a single entry point for methods that copy
!     an Attribute or Attribute hierarchy.

!EOPI
      end interface

!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeRemove  - Remove an Attribute or Attribute Package
!
! !INTERFACE:
      interface ESMF_AttributeRemove

! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_ArrayAttRemove
        module procedure ESMF_ArrayBundleAttRemove
        module procedure ESMF_CplCompAttRemove
        module procedure ESMF_GridCompAttRemove
        module procedure ESMF_SciCompAttRemove
        module procedure ESMF_DistGridAttRemove
        module procedure ESMF_FieldAttRemove
        module procedure ESMF_FieldBundleAttRemove
        module procedure ESMF_GridAttRemove
        module procedure ESMF_StateAttRemove

! !DESCRIPTION:
!     This interface provides a single entry point for methods that destroy
!     an Attribute or Attribute package.

!EOPI
      end interface

!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeGet  - Get Attributes, Attribute packages, count,
!              info, and type
!
! !INTERFACE:
      interface ESMF_AttributeGet

! !PRIVATE MEMBER FUNCTIONS:
        TypeKindInterfaceMacro(ESMF_ArrayAttGet)
	TypeKindInterfaceMacro(ESMF_ArrayAttGet1D)
        module procedure ESMF_ArrayAttGetLgcl
        module procedure ESMF_ArrayAttGetLgclList
        module procedure ESMF_ArrayAttGetChar
        module procedure ESMF_ArrayAttGetCharList
        module procedure ESMF_ArrayAttGetInfoByNam
        module procedure ESMF_ArrayAttGetInfoByNum
        module procedure ESMF_ArrayAttGetCount

        TypeKindInterfaceMacro(ESMF_ArrayBundleAttGet)
	TypeKindInterfaceMacro(ESMF_ArrayBundleAttGet1D)
        module procedure ESMF_ArrayBundleAttGetLgcl
        module procedure ESMF_ArrayBundleAttGetLgclList
        module procedure ESMF_ArrayBundleAttGetChar
        module procedure ESMF_ArrayBundleAttGetCharList
        module procedure ESMF_ArrayBundleAttGetInfoByNam
        module procedure ESMF_ArrayBundleAttGetInfoByNum
        module procedure ESMF_ArrayBundleAttGetCount

        TypeKindInterfaceMacro(ESMF_CplCompAttGet)
	TypeKindInterfaceMacro(ESMF_CplCompAttGet1D)
        module procedure ESMF_CplCompAttGetLgcl
        module procedure ESMF_CplCompAttGetLgclList
        module procedure ESMF_CplCompAttGetChar
        module procedure ESMF_CplCompAttGetCharList
        module procedure ESMF_CplCompAttGetInfoByNam
        module procedure ESMF_CplCompAttGetInfoByNum
        module procedure ESMF_CplCompAttGetCount
        module procedure ESMF_CplCompAttGetAPinstNames

        TypeKindInterfaceMacro(ESMF_GridCompAttGet)
	TypeKindInterfaceMacro(ESMF_GridCompAttGet1D)
        module procedure ESMF_GridCompAttGetLgcl
        module procedure ESMF_GridCompAttGetLgclList
        module procedure ESMF_GridCompAttGetChar
        module procedure ESMF_GridCompAttGetCharList
        module procedure ESMF_GridCompAttGetInfoByNam
        module procedure ESMF_GridCompAttGetInfoByNum
        module procedure ESMF_GridCompAttGetCount
        module procedure ESMF_GridCompAttGetAPinstNames

        TypeKindInterfaceMacro(ESMF_SciCompAttGet)
        TypeKindInterfaceMacro(ESMF_SciCompAttGet1D)
        module procedure ESMF_SciCompAttGetLgcl
        module procedure ESMF_SciCompAttGetLgclList
        module procedure ESMF_SciCompAttGetChar
        module procedure ESMF_SciCompAttGetCharList
        module procedure ESMF_SciCompAttGetInfoByNam
        module procedure ESMF_SciCompAttGetInfoByNum
        module procedure ESMF_SciCompAttGetCount
        module procedure ESMF_SciCompAttGetAPinstNames

        TypeKindInterfaceMacro(ESMF_DistGridAttGet)
	TypeKindInterfaceMacro(ESMF_DistGridAttGet1D)
        module procedure ESMF_DistGridAttGetLgcl
        module procedure ESMF_DistGridAttGetLgclList
        module procedure ESMF_DistGridAttGetChar
        module procedure ESMF_DistGridAttGetCharList
        module procedure ESMF_DistGridAttGetInfoByNam
        module procedure ESMF_DistGridAttGetInfoByNum
        module procedure ESMF_DistGridAttGetCount

        TypeKindInterfaceMacro(ESMF_FieldAttGet)
	TypeKindInterfaceMacro(ESMF_FieldAttGet1D)
        module procedure ESMF_FieldAttGetLgcl
        module procedure ESMF_FieldAttGetLgclList
        module procedure ESMF_FieldAttGetChar
        module procedure ESMF_FieldAttGetCharList
        module procedure ESMF_FieldAttGetInfoByNam
        module procedure ESMF_FieldAttGetInfoByNum
        module procedure ESMF_FieldAttGetCount

        TypeKindInterfaceMacro(ESMF_FieldBundleAttGet)
	TypeKindInterfaceMacro(ESMF_FieldBundleAttGet1D)
        module procedure ESMF_FieldBundleAttGetLgcl
        module procedure ESMF_FieldBundleAttGetLgclList
        module procedure ESMF_FieldBundleAttGetChar
        module procedure ESMF_FieldBundleAttGetCharList
        module procedure ESMF_FieldBundleAttGetInfoByNam
        module procedure ESMF_FieldBundleAttGetInfoByNum
        module procedure ESMF_FieldBundleAttGetCount

        TypeKindInterfaceMacro(ESMF_GridAttGet)
	TypeKindInterfaceMacro(ESMF_GridAttGet1D)
        module procedure ESMF_GridAttGetLgcl
        module procedure ESMF_GridAttGetLgclList
        module procedure ESMF_GridAttGetChar
        module procedure ESMF_GridAttGetCharList
        module procedure ESMF_GridAttGetInfoByNam
        module procedure ESMF_GridAttGetInfoByNum
        module procedure ESMF_GridAttGetCount

        TypeKindInterfaceMacro(ESMF_StateAttGet)
	TypeKindInterfaceMacro(ESMF_StateAttGet1D)
        module procedure ESMF_StateAttGetLgcl
        module procedure ESMF_StateAttGetLgclList
        module procedure ESMF_StateAttGetChar
        module procedure ESMF_StateAttGetCharList
        module procedure ESMF_StateAttGetInfoByNam
        module procedure ESMF_StateAttGetInfoByNum
        module procedure ESMF_StateAttGetCount

! !DESCRIPTION:
!     This interface provides a single entry point for methods that retrieve
!     Attributes.

!EOPI
      end interface

!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeLink  - Link Attribute hierarchies
!
! !INTERFACE:
      interface ESMF_AttributeLink

! !PRIVATE MEMBER FUNCTIONS:
! TODO
        module procedure ESMF_ArrayBundleAttLinkArray
        module procedure ESMF_CplCompAttLinkCplComp
        module procedure ESMF_CplCompAttLinkGridComp
        module procedure ESMF_CplCompAttLinkSciComp
        module procedure ESMF_CplCompAttLinkState
        module procedure ESMF_FieldBundleAttLinkField
        module procedure ESMF_FieldBundleAttLinkGrid
        module procedure ESMF_FieldAttLinkGrid
        module procedure ESMF_GridCompAttLinkCplComp
        module procedure ESMF_GridCompAttLinkGridComp
        module procedure ESMF_GridCompAttLinkSciComp
        module procedure ESMF_GridCompAttLinkState
        module procedure ESMF_SciCompAttLinkCplComp
        module procedure ESMF_SciCompAttLinkGridComp
        module procedure ESMF_SciCompAttLinkSciComp
        module procedure ESMF_SciCompAttLinkState
        module procedure ESMF_StateAttLinkArrayBundle
        module procedure ESMF_StateAttLinkArray
        module procedure ESMF_StateAttLinkFieldBundle
        module procedure ESMF_StateAttLinkField
        module procedure ESMF_StateAttLinkState

! !DESCRIPTION:
!     This interface provides a single entry point for methods that link
!     Attribute hierarchies.

!EOPI
      end interface
!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeLinkRemove  - Unlink Attribute hierarchies
!
! !INTERFACE:
      interface ESMF_AttributeLinkRemove

! !PRIVATE MEMBER FUNCTIONS:
! TODO
        module procedure ESMF_ArrayBundleAttLinkRmArray
        module procedure ESMF_CplCompAttLinkRmCplComp
        module procedure ESMF_CplCompAttLinkRmGridComp
        module procedure ESMF_CplCompAttLinkRmSciComp
        module procedure ESMF_CplCompAttLinkRmState
        module procedure ESMF_FieldBundleAttLinkRmField
        module procedure ESMF_FieldBundleAttLinkRmGrid
        module procedure ESMF_FieldAttLinkRmGrid
        module procedure ESMF_GridCompAttLinkRmCplComp
        module procedure ESMF_GridCompAttLinkRmGridComp
        module procedure ESMF_GridCompAttLinkRmSciComp
        module procedure ESMF_GridCompAttLinkRmState
        module procedure ESMF_SciCompAttLinkRmCplComp
        module procedure ESMF_SciCompAttLinkRmGridComp
        module procedure ESMF_SciCompAttLinkRmSciComp
        module procedure ESMF_SciCompAttLinkRmState
        module procedure ESMF_StateAttLinkRmArrayBundle
        module procedure ESMF_StateAttLinkRmArray
        module procedure ESMF_StateAttLinkRmFieldBundle
        module procedure ESMF_StateAttLinkRmField
        module procedure ESMF_StateAttLinkRmState

! !DESCRIPTION:
!     This interface provides a single entry point for methods that unlink
!     Attribute hierarchies.

!EOPI
      end interface
!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeRead  - Read an Attribute or Attribute Package
!
! !INTERFACE:
      interface ESMF_AttributeRead

! !PRIVATE MEMBER FUNCTIONS:
! TODO
!        module procedure ESMF_ArrayAttRead
!        module procedure ESMF_ArrayBundleAttRead
        module procedure ESMF_CplCompAttRead
        module procedure ESMF_GridCompAttRead
        module procedure ESMF_SciCompAttRead
!        module procedure ESMF_DistGridAttRead
        module procedure ESMF_FieldAttRead
        module procedure ESMF_FieldBundleAttRead
        module procedure ESMF_GridAttRead
        module procedure ESMF_StateAttRead

! !DESCRIPTION:
!     This interface provides a single entry point for methods that read
!     an Attribute or Attribute package.

!EOPI
      end interface
!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeSet  - Set Attributes and Attribute packages
!
! !INTERFACE:
      interface ESMF_AttributeSet

! !PRIVATE MEMBER FUNCTIONS:
	TypeKindInterfaceMacro(ESMF_ArrayAttSet)
	TypeKindInterfaceMacro(ESMF_ArrayAttSet1D)
        module procedure ESMF_ArrayAttSetLgcl
        module procedure ESMF_ArrayAttSetLgclList
        module procedure ESMF_ArrayAttSetChar
        module procedure ESMF_ArrayAttSetCharList

	TypeKindInterfaceMacro(ESMF_ArrayBundleAttSet)
	TypeKindInterfaceMacro(ESMF_ArrayBundleAttSet1D)
        module procedure ESMF_ArrayBundleAttSetLgcl
        module procedure ESMF_ArrayBundleAttSetLgclList
        module procedure ESMF_ArrayBundleAttSetChar
        module procedure ESMF_ArrayBundleAttSetCharList

	TypeKindInterfaceMacro(ESMF_CplCompAttSet)
	TypeKindInterfaceMacro(ESMF_CplCompAttSet1D)
        module procedure ESMF_CplCompAttSetLgcl
        module procedure ESMF_CplCompAttSetLgclList
        module procedure ESMF_CplCompAttSetChar
        module procedure ESMF_CplCompAttSetCharList

	TypeKindInterfaceMacro(ESMF_GridCompAttSet)
	TypeKindInterfaceMacro(ESMF_GridCompAttSet1D)
        module procedure ESMF_GridCompAttSetLgcl
        module procedure ESMF_GridCompAttSetLgclList
        module procedure ESMF_GridCompAttSetChar
        module procedure ESMF_GridCompAttSetCharList

	TypeKindInterfaceMacro(ESMF_SciCompAttSet)
	TypeKindInterfaceMacro(ESMF_SciCompAttSet1D)
        module procedure ESMF_SciCompAttSetLgcl
        module procedure ESMF_SciCompAttSetLgclList
        module procedure ESMF_SciCompAttSetChar
        module procedure ESMF_SciCompAttSetCharList

	TypeKindInterfaceMacro(ESMF_DistGridAttSet)
	TypeKindInterfaceMacro(ESMF_DistGridAttSet1D)
        module procedure ESMF_DistGridAttSetLgcl
        module procedure ESMF_DistGridAttSetLgclList
        module procedure ESMF_DistGridAttSetChar
        module procedure ESMF_DistGridAttSetCharList

	TypeKindInterfaceMacro(ESMF_FieldAttSet)
	TypeKindInterfaceMacro(ESMF_FieldAttSet1D)
        module procedure ESMF_FieldAttSetLgcl
        module procedure ESMF_FieldAttSetLgclList
        module procedure ESMF_FieldAttSetChar
        module procedure ESMF_FieldAttSetCharList

	TypeKindInterfaceMacro(ESMF_FieldBundleAttSet)
	TypeKindInterfaceMacro(ESMF_FieldBundleAttSet1D)
        module procedure ESMF_FieldBundleAttSetLgcl
        module procedure ESMF_FieldBundleAttSetLgclList
        module procedure ESMF_FieldBundleAttSetChar
        module procedure ESMF_FieldBundleAttSetCharList

	TypeKindInterfaceMacro(ESMF_GridAttSet)
	TypeKindInterfaceMacro(ESMF_GridAttSet1D)
        module procedure ESMF_GridAttSetLgcl
        module procedure ESMF_GridAttSetLgclList
        module procedure ESMF_GridAttSetChar
        module procedure ESMF_GridAttSetCharList

	TypeKindInterfaceMacro(ESMF_StateAttSet)
	TypeKindInterfaceMacro(ESMF_StateAttSet1D)
        module procedure ESMF_StateAttSetLgcl
        module procedure ESMF_StateAttSetLgclList
        module procedure ESMF_StateAttSetChar
        module procedure ESMF_StateAttSetCharList

! !DESCRIPTION:
!     This interface provides a single entry point for methods that attach
!     Attributes and Attribute packages, and link Attribute hierarchies.

!EOPI
      end interface
!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeWrite  - Write an Attribute or Attribute Package
!
! !INTERFACE:
      interface ESMF_AttributeWrite

! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_ArrayAttWrite
        module procedure ESMF_ArrayBundleAttWrite
        module procedure ESMF_CplCompAttWrite
        module procedure ESMF_GridCompAttWrite
        module procedure ESMF_SciCompAttWrite
        !module procedure ESMF_DistGridAttWrite
        module procedure ESMF_FieldAttWrite
        module procedure ESMF_FieldBundleAttWrite
        module procedure ESMF_GridAttWrite
        module procedure ESMF_StateAttWrite

! !DESCRIPTION:
!     This interface provides a single entry point for methods that write
!     an Attribute or Attribute package.

!EOPI
      end interface

!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeUpdate  - Update an Attribute hierarchy
!
! !INTERFACE:
      interface ESMF_AttributeUpdate

! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_CplCompAttUpdate
        module procedure ESMF_GridCompAttUpdate
        module procedure ESMF_SciCompAttUpdate
        module procedure ESMF_FieldAttUpdate
        module procedure ESMF_FieldBundleAttUpdate
        module procedure ESMF_StateAttUpdate

! !DESCRIPTION:
!     This interface provides a single entry point for methods that update
!     an Attribute hierarchy.

!EOPI
      end interface

!
!------------------------------------------------------------------------------
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

contains

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeAdd  - Add an ESMF standard Attribute package
!
! !INTERFACE:
!     ! Private name; call using ESMF_AttributeAdd()
!     subroutine ESMF_AttAddPackStd(<object>, convention, purpose, attpack, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values
!     character (len = *), intent(in)            :: convention
!     character (len = *), intent(in)            :: purpose
!     type(ESMF_Attribute),intent(in),  optional :: attpack
!     integer,             intent(out), optional :: rc
!
! !DESCRIPTION:
!     Add an ESMF standard Attribute package.  See Section~\ref{sec:AttPacks}
!     for a description of Attribute packages.
!
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array),    intent(inout) :: array
!     \item type(ESMF\_CplComp),  intent(inout) :: comp
!     \item type(ESMF\_GridComp), intent(inout) :: comp
!     \item type(ESMF\_SciComp),  intent(inout) :: comp
!     \item type(ESMF\_Field),    intent(inout) :: field
!     \item type(ESMF\_Grid),     intent(inout) :: grid
!     \item type(ESMF\_State),    intent(inout) :: state
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object
!     \item [convention]
!           The convention of the new Attribute package
!     \item [purpose]
!           The purpose of the new Attribute package
!     \item [{[attpack}]]
!           An optional handle to the Attribute package that is to be created
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeAdd  - Add an ESMF standard Attribute package containing nested standard Attribute packages
!
! !INTERFACE:
!     ! Private name; call using ESMF_AttributeAdd()
!     subroutine ESMF_AttAddPackStdN(<object>, convention, purpose, &
!       nestConvention, nestPurpose, nestAttPackInstanceCountList, &
!       nestAttPackInstanceNameList, nestCount, &
!       nestAttPackInstanceNameCount, attpack, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values
!     character (len = *), intent(in)            :: convention
!     character (len = *), intent(in)            :: purpose
!     character (len = *), intent(in)            :: nestConvention(:)
!     character (len = *), intent(in)            :: nestPurpose(:)
!     integer,             intent(in)            :: nestAttPackInstanceCountList(:)
!     character (len = *), intent(out)           :: nestAttPackInstanceNameList(:)
!     integer,             intent(in),  optional :: nestCount
!     integer,             intent(out), optional :: nestAttPackInstanceNameCount
!     type(ESMF_Attribute),intent(in),  optional :: attpack
!     integer,             intent(out), optional :: rc
!
! !DESCRIPTION:
!     Add an ESMF standard Attribute package which contains a user-specified
!     number of nested standard Attribute packages.  ESMF generates and returns
!     default instance names for the nested Attribute packages.  These names
!     can be used later to distinguish among multiple nested Attribute
!     packages of the same type in calls to {\tt ESMF\_AttributeGet()},
!     {\tt ESMF\_AttributeSet()}, and {\tt ESMF\_AttributeRemove()}.
!     See Section~\ref{sec:AttPacks} for a description of Attribute packages.
!
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_CplComp),  intent(inout) :: comp
!     \item type(ESMF\_GridComp), intent(inout) :: comp
!     \item type(ESMF\_SciComp),  intent(inout) :: comp
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object
!     \item [convention]
!           The convention of the new Attribute package
!     \item [purpose]
!           The purpose of the new Attribute package
!     \item [nestConvention]
!           The convention(s) of the standard Attribute package(s) around
!           which to nest the new Attribute package
!     \item [nestPurpose]
!           The purpose(s) of the standard Attribute package(s) around
!           which to nest the new Attribute package
!     \item [nestAttPackInstanceCountList]
!           The desired number of nested Attribute package instances for each
!           nested (nestConvention, nestPurpose) package type. Note: if only one
!           of each nested package type is desired, then the
!           {\tt ESMF\_AttributeAdd()} overloaded method
!           {\tt ESMF\_AttAddPackStd()} should be used.
!     \item [nestAttPackInstanceNameList]
!           The name(s) of the nested Attribute package instances, generated
!           by ESMF, used to distinguish between multiple instances of the
!           same convention and purpose.
!     \item [{[nestCount]}]
!           The count of the number of nested Attribute package types to add to
!           the new Attribute package.
!     \item [{[nestAttPackInstanceNameCount]}]
!           The number of nested Attribute package instance names.
!     \item [{[attpack}]]
!           An optional handle to the Attribute package that is to be created
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeAdd  - Add a custom Attribute package or modify an existing Attribute package
!
! !INTERFACE:
!     ! Private name; call using ESMF_AttributeAdd()
!     subroutine ESMF_AttAddPackCst(<object>, convention, purpose, &
!       attrList, count, attpack, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values
!     character (len = *), intent(in)            :: convention
!     character (len = *), intent(in)            :: purpose
!     character (len = *), intent(in)            :: attrList(:)
!     integer,             intent(in),  optional :: count
!     type(ESMF_Attribute),intent(in),  optional :: attpack
!     integer,             intent(out), optional :: rc
!
! !DESCRIPTION:
!     Add a custom Attribute package to <object>.
!     See Section~\ref{sec:AttPacks} for a description of Attribute packages.
!
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array),       intent(inout) :: array
!     \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
!     \item type(ESMF\_CplComp),     intent(inout) :: comp
!     \item type(ESMF\_GridComp),    intent(inout) :: comp
!     \item type(ESMF\_SciComp),     intent(inout) :: comp
!     \item type(ESMF\_DistGrid),    intent(inout) :: distgrid
!     \item type(ESMF\_Field),       intent(inout) :: field
!     \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
!     \item type(ESMF\_Grid),        intent(inout) :: grid
!     \item type(ESMF\_State),       intent(inout) :: state
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object
!     \item [convention]
!           The convention of the Attribute package
!     \item [purpose]
!           The purpose of the Attribute package
!     \item [attrList]
!           The list of Attribute names to specify the custom Attribute package
!     \item [{[count]}]
!           The number of Attributes to add to the custom Attribute package
!     \item [{[attpack}]]
!           An optional handle to the Attribute package that is to be created
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeAdd  - Add a custom Attribute package with nested Attribute packages or modify an existing Attribute package
!
! !INTERFACE:
!     ! Private name; call using ESMF_AttributeAdd()
!     subroutine ESMF_AttAddPackCstN(<object>, convention, purpose, &
!       attrList, count, nestConvention, nestPurpose, nestCount, attpack, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values
!     character (len = *), intent(in)            :: convention
!     character (len = *), intent(in)            :: purpose
!     character (len = *), intent(in),  optional :: attrList(:)
!     integer,             intent(in),  optional :: count
!     character (len = *), intent(in)            :: nestConvention(:)
!     character (len = *), intent(in)            :: nestPurpose(:)
!     integer,             intent(in),  optional :: nestCount
!     type(ESMF_Attribute),intent(in),  optional :: attpack
!     integer,             intent(out), optional :: rc
!
! !DESCRIPTION:
!     Add a custom Attribute package, with one or more nested Attribute
!     packages, to <object>.  Allows for building full multiple-child Attribute
!     hierarchies (multi-child trees).
!     See Section~\ref{sec:AttPacks} for a description of Attribute packages.
!
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array),       intent(inout) :: array
!     \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
!     \item type(ESMF\_CplComp),     intent(inout) :: comp
!     \item type(ESMF\_GridComp),    intent(inout) :: comp
!     \item type(ESMF\_SciComp),     intent(inout) :: comp
!     \item type(ESMF\_DistGrid),    intent(inout) :: distgrid
!     \item type(ESMF\_Field),       intent(inout) :: field
!     \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
!     \item type(ESMF\_Grid),        intent(inout) :: grid
!     \item type(ESMF\_State),       intent(inout) :: state
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object
!     \item [convention]
!           The convention of the Attribute package
!     \item [purpose]
!           The purpose of the Attribute package
!     \item [{[attrList]}]
!           The list of Attribute names to specify the custom Attribute package
!     \item [{[count]}]
!           The number of Attributes to add to the custom Attribute package
!     \item [nestConvention]
!           The convention(s) of the Attribute package(s) around which to nest
!           the new Attribute package
!     \item [nestPurpose]
!           The purpose(s) of the Attribute package(s) around which to nest the
!           new Attribute package
!     \item [{[nestCount]}]
!           The number of nested Attribute packages to add to the custom
!           Attribute package
!     \item [{[attpack}]]
!           An optional handle to the Attribute package that is to be created
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeAdd  - Add a custom Attribute package with a single nested Atrribute package, or modify an existing Attribute package
!
! !INTERFACE:
!     ! Private name; call using ESMF_AttributeAdd()
!     subroutine ESMF_AttAddPackCstN1(<object>, convention, purpose, &
!       attrList, count, nestConvention, nestPurpose, attpack, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values
!     character (len = *), intent(in)            :: convention
!     character (len = *), intent(in)            :: purpose
!     character (len = *), intent(in),  optional :: attrList(:)
!     integer,             intent(in),  optional :: count
!     character (len = *), intent(in)            :: nestConvention
!     character (len = *), intent(in)            :: nestPurpose
!     type(ESMF_Attribute),intent(in),  optional :: attpack
!     integer,             intent(out), optional :: rc
!
! !DESCRIPTION:
!     Add a custom Attribute package, with a single nested Attribute
!     package, to <object>.  Allows for building single-child Attribute
!     hierarchies (single-child trees).
!     See Section~\ref{sec:AttPacks} for a description of Attribute packages.
!
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array),       intent(inout) :: array
!     \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
!     \item type(ESMF\_CplComp),     intent(inout) :: comp
!     \item type(ESMF\_GridComp),    intent(inout) :: comp
!     \item type(ESMF\_SciComp),     intent(inout) :: comp
!     \item type(ESMF\_DistGrid),    intent(inout) :: distgrid
!     \item type(ESMF\_Field),       intent(inout) :: field
!     \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
!     \item type(ESMF\_Grid),        intent(inout) :: grid
!     \item type(ESMF\_State),       intent(inout) :: state
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object
!     \item [convention]
!           The convention of the Attribute package
!     \item [purpose]
!           The purpose of the Attribute package
!     \item [{[attrList]}]
!           The list of Attribute names to specify the custom Attribute package
!     \item [{[count]}]
!           The number of Attributes to add to the custom Attribute package
!     \item [nestConvention]
!           The convention of the Attribute package around which to nest
!           the new Attribute package
!     \item [nestPurpose]
!           The purpose of the Attribute package around which to nest the
!           new Attribute package
!     \item [{[attpack}]]
!           An optional handle to the Attribute package that is to be created
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeCopy - Copy an Attribute hierarchy
!
! !INTERFACE:
!     ! Private name; call using ESMF_AttributeCopy()
!     subroutine ESMF_AttributeCopy(<object1>, <object2>, copyflag, &
!       atttreeflag, rc)
!
! !ARGUMENTS:
!     <object1>, see below for supported values
!     <object2>, see below for supported values
!     type(ESMF_Copy_Flag),   intent(in)            :: copyflag
!     type(ESMF_AttTreeFlag), intent(in)            :: atttreeflag
!     integer,                intent(out), optional :: rc
!
! !DESCRIPTION:
!     Copy an Attribute hierarchy from <object1> to <object2>.
!
!     Supported values for <object1> are:
!     \begin{description}
!     \item type(ESMF\_CplComp),  intent(in) :: comp1
!     \item type(ESMF\_GridComp), intent(in) :: comp1
!     \item type(ESMF\_SciComp),  intent(in) :: comp1
!     \item type(ESMF\_State),    intent(in) :: state
!     \end{description}
!
!     Supported values for <object2> are:
!     \begin{description}
!     \item type(ESMF\_CplComp),  intent(inout) :: comp2
!     \item type(ESMF\_GridComp), intent(inout) :: comp2
!     \item type(ESMF\_SciComp),  intent(inout) :: comp2
!     \item type(ESMF\_State),    intent(inout) :: state
!     \end{description}
!
!     NOTE: Copies between different ESMF object types are not possible at this time.
!
!     The arguments are:
!     \begin{description}
!     \item [<object1>]
!           An {\tt ESMF} object
!     \item [<object2>]
!           An {\tt ESMF} object
!     \item [copyflag]
!           A flag to determine if the copy is to be by reference, value,
!           or both.  This flag is documented in section \ref{const:copy}.
!     \item [atttreeflag]
!           A flag to determine if the copy is supposed to descend the
!           Attribute hierarchy. This flag is documented in section \ref{const:atttree}.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet  - Get an Attribute
!
! !INTERFACE:
!     subroutine ESMF_AttributeGet(<object>, name, <value>, <defaultvalue>, &
!       attpack, isPresent, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values
!     character (len = *), intent(in)            :: name
!     <value>, see below for supported values
!     <defaultvalue>, see below for supported values
!     type(ESMF_Attribute),intent(in),  optional :: attpack
!     logical,             intent(out), optional :: isPresent
!     integer,             intent(out), optional :: rc
!
! !DESCRIPTION:
!     Return an Attribute {\tt value} from the <object>, or from an Attribute
!     package on the <object>, specified by {\tt attpack}.  Internal information can also
!     be retrieved from Grid objects by prepending 'ESMF:' to the name of the
!     piece of information that is requested.  See
!     Section~\ref{sec:InternalInfo} for more information
!     on which pieces of Grid data can be retrieved through this interface.
!     A {\tt defaultvalue} argument
!     may be given if a return code is not desired when the Attribute is not
!     found.  See Section~\ref{sec:AttPacks} for a description of Attribute
!     packages.
!
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array),       intent(in) :: array
!     \item type(ESMF\_ArrayBundle), intent(in) :: arraybundle
!     \item type(ESMF\_CplComp),     intent(in) :: comp
!     \item type(ESMF\_GridComp),    intent(in) :: comp
!     \item type(ESMF\_SciComp),     intent(in) :: comp
!     \item type(ESMF\_DistGrid),    intent(in) :: distgrid
!     \item type(ESMF\_Field),       intent(in) :: field
!     \item type(ESMF\_FieldBundle), intent(in) :: fieldbundle
!     \item type(ESMF\_Grid),        intent(in) :: grid
!     \item type(ESMF\_State),       intent(in) :: state
!     \end{description}
!
!     Supported values for <value> are:
!     \begin{description}
!     \item integer(ESMF\_KIND\_I4), intent(out) :: value
!     \item integer(ESMF\_KIND\_I8), intent(out) :: value
!     \item real (ESMF\_KIND\_R4),   intent(out) :: value
!     \item real (ESMF\_KIND\_R8),   intent(out) :: value
!     \item logical,                 intent(out) :: value
!     \item character (len = *),     intent(out) :: value
!     \end{description}
!
!     Supported values for <defaultvalue> are:
!     \begin{description}
!     \item integer(ESMF\_KIND\_I4), intent(in), optional :: defaultvalue
!     \item integer(ESMF\_KIND\_I8), intent(in), optional :: defaultvalue
!     \item real (ESMF\_KIND\_R4),   intent(in), optional :: defaultvalue
!     \item real (ESMF\_KIND\_R8),   intent(in), optional :: defaultvalue
!     \item logical,                 intent(in), optional :: defaultvalue
!     \item character (len = *),     intent(in), optional :: defaultvalue
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object
!     \item [name]
!           The name of the Attribute to retrieve
!     \item [<value>]
!           The value of the named Attribute
!     \item [{[<defaultvalue>]}]
!           The default value of the named Attribute
!     \item [{[attpack}]]
!           An optional handle to the Attribute package that is to be created
!     \item [{[isPresent]}]
!           A logical flag to tell if this Attribute is present or not
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet - Get an Attribute pointing to internal class information
!
! !INTERFACE:
!     subroutine ESMF_AttributeGet(<object>, name, <value>, <defaultvalue>, &
!       inputList, attpack, isPresent, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values
!     character (len = *), intent(in)            :: name
!     <value>, see below for supported values
!     <defaultvalue>, see below for supported values
!     character (len = *), intent(in),  optional :: inputList(:)
!     type(ESMF_Attribute),intent(in),  optional :: attpack
!     logical,             intent(out), optional :: isPresent
!     integer,             intent(out), optional :: rc
!
! !DESCRIPTION:
!     Return an Attribute {\tt value} from the <object>, or from an Attribute
!     package on the <object>, specified by {\tt attpack}.  Internal class information can
!     be retrieved by prepending 'ESMF:' to the name of the
!     piece of information that is requested.  See
!     Section~\ref{sec:InternalInfo} for more information
!     on this capability.
!     A {\tt defaultvalue} argument
!     may be given if a return code is not desired when the Attribute is not
!     found.  See Section~\ref{sec:AttPacks} for a description of Attribute
!     packages.
!
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Grid), intent(in) :: grid
!     \end{description}
!
!     Supported values for <value> are:
!     \begin{description}
!     \item integer(ESMF\_KIND\_I4), intent(out) :: value
!     \item character (len = *),     intent(out) :: value
!     \end{description}
!
!     Supported values for <defaultvalue> are:
!     \begin{description}
!     \item integer(ESMF\_KIND\_I4), intent(in), optional :: defaultvalue
!     \item character (len = *),     intent(in), optional :: defaultvalue
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object
!     \item [name]
!           The name of the Attribute to retrieve
!     \item [<value argument>]
!           The value of the named Attribute
!     \item [{[<defaultvalue argument>]}]
!           The default value of the named Attribute
!     \item [{[inputList]}]
!           A list of the input parameters required to retrieve internal info
!     \item [{[attpack}]]
!           An optional handle to the Attribute package that is to be created
!     \item [{[isPresent]}]
!           A logical flag to tell if this Attribute is present or not
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet  - Get an Attribute
!
! !INTERFACE:
!     subroutine ESMF_AttributeGet(<object>, name, <valueList>, &
!       <defaultvalueList>, attpack, itemCount, isPresent, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values
!     character (len = *), intent(in)              :: name
!     <valueList>, see below for supported values
!     <defaultvalueList>, see below for supported values
!     type(ESMF_Attribute),intent(in),    optional :: attpack
!     integer,             intent(out),   optional :: itemCount
!     logical,             intent(out),   optional :: isPresent
!     integer,             intent(out),   optional :: rc
!
! !DESCRIPTION:
!     Return an Attribute {\tt valueList} from the <object>, or from an
!     Attribute package on the <object>, specified by {\tt attpack}.  Internal
!     information can also be retrieved from Grid objects by prepending 'ESMF:'
!     to the name of the piece of information that is requested.  See
!     Section~\ref{sec:InternalInfo} for more information
!     on which pieces of Grid data can be retrieved through this interface.
!     A {\tt defaultvalueList} list argument may be given if
!     a return code is not desired when the Attribute is not found.
!     See Section~\ref{sec:AttPacks} for a description of Attribute packages.
!
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array),       intent(in) :: array
!     \item type(ESMF\_ArrayBundle), intent(in) :: arraybundle
!     \item type(ESMF\_CplComp),     intent(in) :: comp
!     \item type(ESMF\_GridComp),    intent(in) :: comp
!     \item type(ESMF\_SciComp),     intent(in) :: comp
!     \item type(ESMF\_DistGrid),    intent(in) :: distgrid
!     \item type(ESMF\_Field),       intent(in) :: field
!     \item type(ESMF\_FieldBundle), intent(in) :: fieldbundle
!     \item type(ESMF\_Grid),        intent(in) :: grid
!     \item type(ESMF\_State),       intent(in) :: state
!     \end{description}
!
!     Supported values for <valueList> are:
!     \begin{description}
!     \item integer(ESMF\_KIND\_I4), intent(out) :: valueList(:)
!     \item integer(ESMF\_KIND\_I8), intent(out) :: valueList(:)
!     \item real (ESMF\_KIND\_R4),   intent(out) :: valueList(:)
!     \item real (ESMF\_KIND\_R8),   intent(out) :: valueList(:)
!     \item logical,                 intent(out) :: valueList(:)
!     \item character (len = *),     intent(out) :: valueList(:)
!     \end{description}
!
!     Supported values for <defaultvalueList> are:
!     \begin{description}
!     \item integer(ESMF\_KIND\_I4), intent(in), optional :: defaultvalueList(:)
!     \item integer(ESMF\_KIND\_I8), intent(in), optional :: defaultvalueList(:)
!     \item real (ESMF\_KIND\_R4),   intent(in), optional :: defaultvalueList(:)
!     \item real (ESMF\_KIND\_R8),   intent(in), optional :: defaultvalueList(:)
!     \item logical,                 intent(in), optional :: defaultvalueList(:)
!     \item character (len = *),     intent(in), optional :: defaultvalueList(:)
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object
!     \item [name]
!           The name of the Attribute to retrieve
!     \item [<valueList>]
!           The valueList of the named Attribute
!     \item [{[<defaultvalueList>]}]
!           The default value list of the named Attribute
!     \item [{[attpack}]]
!           An optional handle to the Attribute package that is to be created
!     \item [{[itemCount]}]
!           The number of items in a multi-valued Attribute
!     \item [{[isPresent]}]
!           A logical flag to tell if this Attribute is present or not
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet - Get an Attribute pointing to internal class information
!
! !INTERFACE:
!     subroutine ESMF_AttributeGet(<object>, name, <valueList>, &
!       <defaultvalueList>, inputList, attpack, itemCount, isPresent, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values
!     character (len = *), intent(in)              :: name
!     <valueList>, see below for supported values
!     <defaultvalueList>, see below for supported values
!     character (len = *), intent(in),    optional :: inputList(:)
!     type(ESMF_Attribute),intent(in),    optional :: attpack
!     integer,             intent(out),   optional :: itemCount
!     logical,             intent(out),   optional :: isPresent
!     integer,             intent(out),   optional :: rc
!
! !DESCRIPTION:
!     Return an Attribute {\tt valueList} from the <object>, or from an
!     Attribute package on the <object>, specified by {\tt attpack}.  Internal class
!     information can be retrieved by prepending 'ESMF:'
!     to the name of the piece of information that is requested.  See
!     Section~\ref{sec:InternalInfo} for more information
!     on this capability.
!     A {\tt defaultvalueList} list argument may be given if
!     a return code is not desired when the Attribute is not found.
!     See Section~\ref{sec:AttPacks} for a description of Attribute packages.
!
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Grid),        intent(in) :: grid
!     \end{description}
!
!     Supported values for <valueList> are:
!     \begin{description}
!     \item integer(ESMF\_KIND\_I4), intent(out) :: valueList(:)
!     \item real (ESMF\_KIND\_R8),   intent(out) :: valueList(:)
!     \item logical,                 intent(out) :: valueList(:)
!     \end{description}
!
!     Supported values for <defaultvalueList> are:
!     \begin{description}
!     \item integer(ESMF\_KIND\_I4), intent(in), optional :: defaultvalueList(:)
!     \item real (ESMF\_KIND\_R8),   intent(in), optional :: defaultvalueList(:)
!     \item logical,                 intent(in), optional :: defaultvalueList(:)
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object
!     \item [name]
!           The name of the Attribute to retrieve
!     \item [<valueList>]
!           The valueList of the named Attribute
!     \item [{[<defaultvalueList>]}]
!           The default value list of the named Attribute
!     \item [{[inputList]}]
!           A list of the input parameters required to retrieve internal info
!     \item [{[attpack}]]
!           An optional handle to the Attribute package that is to be created
!     \item [{[itemCount]}]
!           The number of items in a multi-valued Attribute
!     \item [{[isPresent]}]
!           A logical flag to tell if this Attribute is present or not
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet - Get the Attribute count
!
! !INTERFACE:
!     ! Private name; call using ESMF_AttributeGet()
!     subroutine ESMF_AttributeGetCount(<object>, count, attcountflag, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values
!     integer,                    intent(out)           :: count
!     type(ESMF_AttGetCountFlag), intent(in),  optional :: attcountflag
!     integer,                    intent(out), optional :: rc
!
! !DESCRIPTION:
!     Return the Attribute count for <object>.
!
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array),       intent(in) :: array
!     \item type(ESMF\_ArrayBundle), intent(in) :: arraybundle
!     \item type(ESMF\_CplComp),     intent(in) :: comp
!     \item type(ESMF\_GridComp),    intent(in) :: comp
!     \item type(ESMF\_SciComp),     intent(in) :: comp
!     \item type(ESMF\_DistGrid),    intent(in) :: distgrid
!     \item type(ESMF\_Field),       intent(in) :: field
!     \item type(ESMF\_FieldBundle), intent(in) :: fieldbundle
!     \item type(ESMF\_Grid),        intent(in) :: grid
!     \item type(ESMF\_State),       intent(in) :: state
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object
!     \item [count]
!           The Attribute count for <object>
!     \item [{[attcountflag]}]
!           The flag to specify which attribute count to return, the
!           default is ESMF\_ATTGETCOUNT\_ATTRIBUTE.  This flag is documented
!           in section \ref{const:attgetcount}.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet - Get Attribute info by name
!
! !INTERFACE:
!     ! Private name; call using ESMF_AttributeGet()
!     subroutine ESMF_AttributeGetInfoByNam(<object>, name, keywordEnforcer, &
!       attpack, typekind, itemCount, isPresent, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values
!     character (len = *),      intent(in)            :: name
!type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
!     type(ESMF_Attribute),     intent(in),  optional :: attpack
!     type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
!     integer,                  intent(out), optional :: itemCount
!     logical,                  intent(out), optional :: isPresent
!     integer,                  intent(out), optional :: rc
!
! !DESCRIPTION:
!     Return information associated with the named Attribute,
!     including {\tt typekind} and {\tt itemCount}.
!
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array),       intent(in) :: array
!     \item type(ESMF\_ArrayBundle), intent(in) :: arraybundle
!     \item type(ESMF\_CplComp),     intent(in) :: comp
!     \item type(ESMF\_GridComp),    intent(in) :: comp
!     \item type(ESMF\_SciComp),     intent(in) :: comp
!     \item type(ESMF\_DistGrid),    intent(in) :: distgrid
!     \item type(ESMF\_Field),       intent(in) :: field
!     \item type(ESMF\_FieldBundle), intent(in) :: fieldbundle
!     \item type(ESMF\_Grid),        intent(in) :: grid
!     \item type(ESMF\_State),       intent(in) :: state
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object
!     \item [name]
!           The name of the Attribute to query
!     \item [{[attpack}]]
!           An optional handle to the Attribute package that is to be created
!     \item [{[typekind}]]
!           The typekind of the Attribute
!     \item [{[itemCount]}]
!           The number of items in this Attribute
!     \item [{[isPresent]}] @\
!           A logical flag to tell if this Attribute is present or not @\
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet - Get Attribute info by index number
!
! !INTERFACE:
!     ! Private name; call using ESMF_AttributeGet()
!     subroutine ESMF_AttributeGetInfoByNum(<object>, attributeIndex, name, &
!       typekind, itemcount, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values
!     integer,             intent(in)            :: attributeIndex
!     character (len = *), intent(out)           :: name
!     integer,             intent(out), optional :: itemCount
!     integer,             intent(out), optional :: rc
!
! !DESCRIPTION:
!     Returns information associated with the indexed Attribute,
!     including {\tt name}, {\tt typekind} and {\tt itemCount}.  Keep in
!     mind that these indexes start from 1, as expected in a Fortran API.
!
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array),       intent(in) :: array
!     \item type(ESMF\_ArrayBundle), intent(in) :: arraybundle
!     \item type(ESMF\_CplComp),     intent(in) :: comp
!     \item type(ESMF\_GridComp),    intent(in) :: comp
!     \item type(ESMF\_SciComp),     intent(in) :: comp
!     \item type(ESMF\_DistGrid),    intent(in) :: distgrid
!     \item type(ESMF\_Field),       intent(in) :: field
!     \item type(ESMF\_FieldBundle), intent(in) :: fieldbundle
!     \item type(ESMF\_Grid),        intent(in) :: grid
!     \item type(ESMF\_State),       intent(in) :: state
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object
!     \item [attributeIndex]
!           The index number of the Attribute to query
!     \item [name]
!           The name of the Attribute
!     \item [{[typekind]}]
!           The typekind of the Attribute
!     \item [{[itemCount]}]
!           The number of items in this Attribute
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet  - Get Attribute package instance names
!
! !INTERFACE:
!     ! Private name; call using ESMF_AttributeGet()
!     subroutine ESMF_AttributeGetAPinstNames(<object>, convention, purpose, &
!       attPackInstanceNameList, attPackInstanceNameCount, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values
!     character (len = *), intent(in), optional  :: convention
!     character (len = *), intent(in), optional  :: purpose
!     character (len = *), intent(out)           :: attPackInstanceNameList(:)
!     integer,             intent(out)           :: attPackInstanceNameCount
!     integer,             intent(out), optional :: rc
!
! !DESCRIPTION:
!     Get the Attribute package instance names of the specified convention
!     and purpose.  Also get the number of such names.
!     See Section~\ref{sec:AttPacks} for a description of Attribute packages
!     and their conventions, purposes, and object types.
!
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_CplComp),  intent(in) :: comp
!     \item type(ESMF\_GridComp), intent(in) :: comp
!     \item type(ESMF\_SciComp),  intent(in) :: comp
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object
!     \item [convention]
!           The convention of the Attribute package instances.
!     \item [purpose]
!           The purpose of the Attribute package instances.
!     \item [attPackInstanceNameList]
!           The name(s) of the Attribute package instances of the given
!           convention and purpose.
!     \item [attPackInstanceNameCount]
!           The number of Attribute package instance names.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLink - Link a Component Attribute hierarchy to that of a Component or State
!
! !INTERFACE:
!      ! Private name; call using ESMF_AttributeLink()
!      subroutine ESMF_CompAttLink(<object1>, <object2>, rc)
!
! !ARGUMENTS:
!      <object1>, see below for supported values
!      <object2>, see below for supported values
!      integer, intent(out), optional :: rc
!
!
! !DESCRIPTION:
!     Attach a {\tt CplComp}, {\tt GridComp}, or {\tt SciComp} Attribute
!     hierarchy to the
!     hierarchy of a {\tt CplComp}, {\tt GridComp}, {\tt SciComp}, or
!     {\tt State}.
!
!     Supported values for the <object1> are:
!     \begin{description}
!     \item type(ESMF\_CplComp),  intent(inout) :: comp1
!     \item type(ESMF\_GridComp), intent(inout) :: comp1
!     \item type(ESMF\_SCiComp),  intent(inout) :: comp1
!     \end{description}
!
!     Supported values for the <object2> are:
!     \begin{description}
!     \item type(ESMF\_CplComp),  intent(in) :: comp2
!     \item type(ESMF\_GridComp), intent(in) :: comp2
!     \item type(ESMF\_SciComp),  intent(in) :: comp2
!     \item type(ESMF\_State),    intent(in) :: state
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [<object1>]
!       The ``parent'' object in the Attribute hierarchy link
!     \item [<object2>]
!       The ``child'' object in the Attribute hierarchy link
!     \item [{[rc]}]
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLink - Link a State Attribute hierarchy with the hierarchy of an Array, ArrayBundle, Field, FieldBundle, or State
!
! !INTERFACE:
!      ! Private name; call using ESMF_AttributeLink()
!      subroutine ESMF_StateAttLink(state, <object>, rc)
!
! !ARGUMENTS:
!      type(ESMF_State), intent(inout)         :: state
!      <object>, see below for supported values
!      integer,          intent(out), optional :: rc
!
!
! !DESCRIPTION:
!     Attach a {\tt State} Attribute hierarchy to the hierarchy of
!     a {\tt Fieldbundle}, {\tt Field}, or another {\tt State}.
!
!     Supported values for the <object> are:
!     \begin{description}
!     \item type(ESMF\_Array),       intent(in) :: array
!     \item type(ESMF\_ArrayBundle), intent(in) :: arraybundle
!     \item type(ESMF\_Field),       intent(in) :: field
!     \item type(ESMF\_FieldBundle), intent(in) :: fieldbundle
!     \item type(ESMF\_State),       intent(in) :: state
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [state]
!       An {\tt ESMF\_State} object
!     \item [<object>]
!       The object with which to link hierarchies
!     \item [{[rc]}]
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLink - Link a FieldBundle and Field Attribute hierarchy
!
! !INTERFACE:
!      ! Private name; call using ESMF_AttributeLink()
!      subroutine ESMF_FieldBundleAttLink(fieldbundle, field, rc)
!
! !ARGUMENTS:
!      type(ESMF_FieldBundle), intent(inout)         :: fieldbundle
!      type(ESMF_Field),       intent(in)            :: field
!      integer,                intent(out), optional :: rc
!
!
! !DESCRIPTION:
!     Attach a {\tt FieldBundle} Attribute hierarchy to the hierarchy of
!     a {\tt Field}.
!
!     The arguments are:
!     \begin{description}
!     \item [fieldbundle]
!       An {\tt ESMF\_FieldBundle} object
!     \item [field]
!       An {\tt ESMF\_Field} object
!     \item [{[rc]}]
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLink - Link a Field and Grid Attribute hierarchy
!
! !INTERFACE:
!      ! Private name; call using ESMF_AttributeLink()
!      subroutine ESMF_FieldAttLink(field, grid, rc)
!
! !ARGUMENTS:
!      type(ESMF_Field), intent(inout)         :: field
!      type(ESMF_Grid),  intent(in)            :: grid
!      integer,          intent(out), optional :: rc
!
!
! !DESCRIPTION:
!     Attach a {\tt Field} Attribute hierarchy to the hierarchy of
!     a {\tt Grid}.
!
!     The arguments are:
!     \begin{description}
!     \item [field]
!       An {\tt ESMF\_Field} object
!     \item [grid]
!       An {\tt ESMF\_Grid} object
!     \item [{[rc]}]
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLink - Link an ArrayBundle and Array Attribute hierarchy
!
! !INTERFACE:
!      ! Private name; call using ESMF_AttributeLink()
!      subroutine ESMF_ArrayBundleAttLink(arraybundle, array, rc)
!
! !ARGUMENTS:
!      type(ESMF_ArrayBundle), intent(inout)         :: arraybundle
!      type(ESMF_Array),       intent(in)            :: array
!      integer,                intent(out), optional :: rc
!
!
! !DESCRIPTION:
!     Attach an {\tt ArrayBundle} Attribute hierarchy to the hierarchy of
!     an {\tt Array}.
!
!     The arguments are:
!     \begin{description}
!     \item [arraybundle]
!       An {\tt ESMF\_ArrayBundle} object
!     \item [array]
!       An {\tt ESMF\_Array} object
!     \item [{[rc]}]
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink a Component Attribute hierarchy from that of a Component or State
!
! !INTERFACE:
!      ! Private name; call using ESMF_AttributeLinkRemove()
!      subroutine ESMF_CompAttLinkRemove(<object1>, <object2>, rc)
!
! !ARGUMENTS:
!      <object1>, see below for supported values
!      <object2>, see below for supported values
!      integer, intent(out), optional :: rc
!
!
! !DESCRIPTION:
!     Unattach a {\tt CplComp}, {\tt GridComp}, or {\tt SciComp} Attribute
!     hierarchy from the hierarchy of a {\tt CplComp}, {\tt GridComp},
!     {\tt SciComp}, or {\tt State}.
!
!     Supported values for the <object1> are:
!     \begin{description}
!     \item type(ESMF\_CplComp),  intent(inout) :: comp1
!     \item type(ESMF\_GridComp), intent(inout) :: comp1
!     \item type(ESMF\_SciComp),  intent(inout) :: comp1
!     \end{description}
!
!     Supported values for the <object2> are:
!     \begin{description}
!     \item type(ESMF\_CplComp),  intent(in) :: comp2
!     \item type(ESMF\_GridComp), intent(in) :: comp2
!     \item type(ESMF\_SciComp),  intent(in) :: comp2
!     \item type(ESMF\_State),    intent(in) :: state
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [<object1>]
!       The ``parent'' object in the Attribute hierarchy link
!     \item [<object2>]
!       The ``child'' object in the Attribute hierarchy link
!     \item [{[rc]}]
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink a State Attribute hierarchy from the hierarchy of an Array, ArrayBundle, Field, FieldBundle, or State
!
! !INTERFACE:
!      ! Private name; call using ESMF_AttributeLinkRemove()
!      subroutine ESMF_StateAttLinkRemove(state, <object>, rc)
!
! !ARGUMENTS:
!      type(ESMF_State), intent(inout)         :: state
!      <object>, see below for supported values
!      integer,          intent(out), optional :: rc
!
!
! !DESCRIPTION:
!     Unattach a {\tt State} Attribute hierarchy from the hierarchy of
!     a {\tt Fieldbundle}, {\tt Field}, or another {\tt State}.
!
!     Supported values for the <object> are:
!     \begin{description}
!     \item type(ESMF\_Array),       intent(in) :: array
!     \item type(ESMF\_ArrayBundle), intent(in) :: arraybundle
!     \item type(ESMF\_Field),       intent(in) :: field
!     \item type(ESMF\_FieldBundle), intent(in) :: fieldbundle
!     \item type(ESMF\_State),       intent(in) :: state
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [state]
!       An {\tt ESMF\_State} object
!     \item [<object>]
!       The object with which to unlink hierarchies
!     \item [{[rc]}]
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink a FieldBundle and Field Attribute hierarchy
!
! !INTERFACE:
!      ! Private name; call using ESMF_AttributeLinkRemove()
!      subroutine ESMF_FieldBundleAttLinkRemove(fieldbundle, field, rc)
!
! !ARGUMENTS:
!      type(ESMF_FieldBundle), intent(inout)         :: fieldbundle
!      type(ESMF_Field),       intent(in)            :: field
!      integer,                intent(out), optional :: rc
!
!
! !DESCRIPTION:
!     Unattach a {\tt FieldBundle} Attribute hierarchy from the hierarchy of
!     a {\tt Field}.
!
!     The arguments are:
!     \begin{description}
!     \item [fieldbundle]
!       An {\tt ESMF\_FieldBundle} object
!     \item [field]
!       An {\tt ESMF\_Field} object
!     \item [{[rc]}]
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink a Field and Grid Attribute hierarchy
!
! !INTERFACE:
!      ! Private name; call using ESMF_AttributeLinkRemove()
!      subroutine ESMF_FieldAttLinkRemove(field, grid, rc)
!
! !ARGUMENTS:
!      type(ESMF_Field), intent(inout)         :: field
!      type(ESMF_Grid),  intent(in)            :: grid
!      integer,          intent(out), optional :: rc
!
!
! !DESCRIPTION:
!     Unattach a {\tt Field} Attribute hierarchy from the hierarchy of
!     a {\tt Grid}.
!
!     The arguments are:
!     \begin{description}
!     \item [field]
!       An {\tt ESMF\_Field} object
!     \item [grid]
!       An {\tt ESMF\_Grid} object
!     \item [{[rc]}]
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink an ArrayBundle and Array Attribute hierarchy
!
! !INTERFACE:
!      ! Private name; call using ESMF_AttributeLinkRemove()
!      subroutine ESMF_ArrayBundleAttLinkRemove(arraybundle, array, rc)
!
! !ARGUMENTS:
!      type(ESMF_ArrayBundle), intent(inout)         :: arraybundle
!      type(ESMF_Array),       intent(in)            :: array
!      integer,                intent(out), optional :: rc
!
!
! !DESCRIPTION:
!     Unattach an {\tt ArrayBundle} Attribute hierarchy from the hierarchy of
!     an {\tt Array}.
!
!     The arguments are:
!     \begin{description}
!     \item [arraybundle]
!       An {\tt ESMF\_ArrayBundle} object
!     \item [array]
!       An {\tt ESMF\_Array} object
!     \item [{[rc]}]
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeRead  - Read Attributes from an XML file
! \label{api:AttributeRead}
!
! !INTERFACE:
!     subroutine ESMF_AttributeRead(<object>, fileName, schemaFileName, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values
!     character (len = *), intent(in),  optional :: fileName
!     character (len = *), intent(in),  optional :: schemaFileName
!     integer,             intent(out), optional :: rc
!
! !DESCRIPTION:
!     Read Attributes for <object> from fileName, whose format is XML.
!     schemaFileName format is XSD.  If present, the schemaFileName is used to
!     validate the contents of fileName.  schemaFileName must be specified for
!     a fileName containing custom, user-defined Attributes.
!
!     Requires the third party Xerces C++ XML Parser library to be installed,
!     v3.1.0 or better.  For more details, see the "ESMF Users Guide",
!     "Building and Installing the ESMF, Third Party Libraries, Xerces" and
!     the website
!     \newline
!     "http://xerces.apache.org/xerces-c".  Also please see the
!     section on Attribute I/O,~\ref{io:attributeio}.
!
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array),       intent(inout) :: array       ! not yet implemented
!     \item type(ESMF\_ArrayBundle), intent(inout) :: arrayBundle ! not yet implemented
!     \item type(ESMF\_CplComp),     intent(inout) :: cplComp
!     \item type(ESMF\_GridComp),    intent(inout) :: gridComp
!     \item type(ESMF\_SciComp),     intent(inout) :: gridComp
!     \item type(ESMF\_Field),       intent(inout) :: field
!     \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle ! not yet implemented
!     \item type(ESMF\_Grid),        intent(inout) :: grid
!     \item type(ESMF\_DistGrid),    intent(inout) :: distGrid    ! not yet implemented
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           The {\tt ESMF} object onto which the read Attributes will be placed
!     \item [{[fileName]}]
!           The name of the XML file to read
!     \item [{[schemaFileName]}]
!           The name of the XSD file to validate the contents of fileName
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute package
!
! !INTERFACE:
!     subroutine ESMF_AttributeRemove(<object>, name, attpack, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values
!     character (len = *), intent(in),  optional :: name
!     type(ESMF_Attribute), intent(in), optional :: attpack
!     integer,             intent(out), optional :: rc
!
! !DESCRIPTION:
!     Remove an Attribute, or Attribute package on <object>.
!     See Section~\ref{sec:AttPacks} for a description of Attribute packages
!     and their conventions, purposes, and object types.
!
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array),       intent(inout) :: array
!     \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
!     \item type(ESMF\_CplComp),     intent(inout) :: comp
!     \item type(ESMF\_GridComp),    intent(inout) :: comp
!     \item type(ESMF\_SciComp),     intent(inout) :: comp
!     \item type(ESMF\_DistGrid),    intent(inout) :: distgrid
!     \item type(ESMF\_Field),       intent(inout) :: field
!     \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
!     \item type(ESMF\_Grid),        intent(inout) :: grid
!     \item type(ESMF\_State),       intent(inout) :: state
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object
!     \item [{[name]}]
!           The name of the Attribute to remove
!     \item [{[attpack}]]
!           An optional handle to the Attribute package that is to be created
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!     NOTE:  An entire Attribute package can be removed by specifying
!            {\tt attpack} only, without {\tt name}.  By specifying
!            {\tt attpack} an Attribute will be removed
!            from the corresponding Attribute package, if it exists.  An
!            Attribute can be removed directly from <object> by specifying
!            {\tt name}, without {\tt attpack}.
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeSet - Set an Attribute
!
! !INTERFACE:
!     subroutine ESMF_AttributeSet(<object>, name, <value>, attpack, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values
!     character (len = *), intent(in)            :: name
!     <value>, see below for supported values
!     type(ESMF_Attribute), intent(in), optional :: attpack
!     integer,             intent(out), optional :: rc
!
! !DESCRIPTION:
!     Attach an Attribute to <object>, or set an Attribute in an
!     Attribute package.  The Attribute has a {\tt name} and {\tt value},
!     and, if in an Attribute package, a {\tt attpack}.
!     See Section~\ref{sec:AttPacks} for a description of Attribute packages.
!
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array),       intent(inout) :: array
!     \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
!     \item type(ESMF\_CplComp),     intent(inout) :: comp
!     \item type(ESMF\_GridComp),    intent(inout) :: comp
!     \item type(ESMF\_SciComp),     intent(inout) :: comp
!     \item type(ESMF\_DistGrid),    intent(inout) :: distgrid
!     \item type(ESMF\_Field),       intent(inout) :: field
!     \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
!     \item type(ESMF\_Grid),        intent(inout) :: grid
!     \item type(ESMF\_State),       intent(inout) :: state
!     \end{description}
!
!     Supported values for the <value> are:
!     \begin{description}
!     \item integer(ESMF\_KIND\_I4), intent(in) :: value
!     \item integer(ESMF\_KIND\_I8), intent(in) :: value
!     \item real (ESMF\_KIND\_R4),   intent(in) :: value
!     \item real (ESMF\_KIND\_R8),   intent(in) :: value
!     \item logical,                 intent(in) :: value
!     \item character (len = *),     intent(in) :: value
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object
!     \item [name]
!           The name of the Attribute to set
!     \item [<value argument>]
!           The value of the Attribute to set
!     \item [{[attpack}]]
!           An optional handle to the Attribute package that is to be created
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeSet - Set an Attribute to point to internal class information
!
! !INTERFACE:
!     subroutine ESMF_AttributeSet(<object>, name, <value>, inputList, attpack, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values
!     character (len = *), intent(in)            :: name
!     <value>, see below for supported values
!     character (len = *), intent(in),  optional :: inputList(:)
!     type(ESMF_Attribute), intent(in), optional :: attpack
!     integer,             intent(out), optional :: rc
!
! !DESCRIPTION:
!     Attach an Attribute to <object>, or set an Attribute in an
!     Attribute package.  The Attribute has a {\tt name} and {\tt value},
!     and, if in an Attribute package, a {\tt attpack}.
!     See Section~\ref{sec:AttPacks} for a description of Attribute packages.  
!     The Attribute can
!     also be set to be a pointer to internal class information.  See Section
!     \ref{sec:InternalInfo} for a description of this capability.
!
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Grid), intent(inout) :: grid
!     \end{description}
!
!     Supported values for the <value> are:
!     \begin{description}
!     \item character (len = *), intent(in), :: value
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object
!     \item [name]
!           The name of the Attribute to set
!     \item [<value argument>]
!           The value of the Attribute to set
!     \item [{[inputList]}]
!           A list of the input parameters required to set internal info
!     \item [{[attpack}]]
!           An optional handle to the Attribute package that is to be created
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeSet - Set an Attribute
!
! !INTERFACE:
!     subroutine ESMF_AttributeSet(<object>, name, <valueList>, &
!       attpack, itemCount, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values
!     character (len = *), intent(in)            :: name
!     <valueList>, see below for supported values
!     type(ESMF_Attribute), intent(in), optional :: attpack
!     integer,             intent(in),  optional :: itemCount
!     integer,             intent(out), optional :: rc
!
! !DESCRIPTION:
!     Attach an Attribute to <object>, or set an Attribute in an
!     Attribute package.  The Attribute has a {\tt name} and a
!     {\tt valueList}, with an {\tt itemCount}, and, if in an Attribute
!     package, a {\tt attpack}.  See Section~\ref{sec:AttPacks} for a
!     description of Attribute packages.
!
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array),       intent(inout) :: array
!     \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
!     \item type(ESMF\_CplComp),     intent(inout) :: comp
!     \item type(ESMF\_GridComp),    intent(inout) :: comp
!     \item type(ESMF\_SciComp),     intent(inout) :: comp
!     \item type(ESMF\_DistGrid),    intent(inout) :: distgrid
!     \item type(ESMF\_Field),       intent(inout) :: field
!     \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
!     \item type(ESMF\_Grid),        intent(inout) :: grid
!     \item type(ESMF\_State),       intent(inout) :: state
!     \end{description}
!
!     Supported values for the <valueList> are:
!     \begin{description}
!     \item integer(ESMF\_KIND\_I4), intent(in) :: valueList(:)
!     \item integer(ESMF\_KIND\_I8), intent(in) :: valueList(:)
!     \item real (ESMF\_KIND\_R4),   intent(in) :: valueList(:)
!     \item real (ESMF\_KIND\_R8),   intent(in) :: valueList(:)
!     \item logical,                 intent(in) :: valueList(:)
!     \item character (len = *),     intent(in) :: valueList(:)
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object
!     \item [name]
!           The name of the Attribute to set
!     \item [<valueList argument>]
!           The valueList of the Attribute to set
!     \item [{[attpack}]]
!           An optional handle to the Attribute package that is to be created
!     \item [{[itemCount]}]
!           The number of items in a multi-valued Attribute
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeUpdate  - Update an Attribute hierarchy
!
! !INTERFACE:
!     subroutine ESMF_AttributeUpdate(<object>, vm, rootList, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values
!     type(ESMF_VM), intent(in)            :: vm
!     integer,       intent(in)            :: rootList(:)
!     integer,       intent(out), optional :: rc
!
! !DESCRIPTION:
!     Update an Attribute hierarchy during runtime.  This call will not work
!     if changes have been made to the underlying object hierarchy and
!     ESMF\_StateReconcile() has not already been called.  There is a check
!     that will fail if this case is encountered.  The information from
!     the PETs in the 'rootList' is transferred to the PETs that are not
!     in the 'rootList'.  Care should be taken to ensure that the information
!     contained in the Attributes on the PETs in the 'rootList' is consistent.
!
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array),       intent(inout) :: array
!     \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
!     \item type(ESMF\_CplComp),     intent(inout) :: comp
!     \item type(ESMF\_GridComp),    intent(inout) :: comp
!     \item type(ESMF\_SciComp),     intent(inout) :: comp
!     \item type(ESMF\_Field),       intent(inout) :: field
!     \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
!     \item type(ESMF\_State),       intent(inout) :: state
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object
!     \item [vm]
!           The virtural machine over which this Attribute hierarchy
!           should be updated
!     \item [rootList]
!           The list of ``root'' PETs that are to be used to update
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeWrite  - Write an Attribute package
! \label{api:AttributeWrite}
!
! !INTERFACE:
!     subroutine ESMF_AttributeWrite(<object>, convention, purpose, &
!       attwriteflag, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values
!     character (len = *),     intent(in),  optional :: convention
!     character (len = *),     intent(in),  optional :: purpose
!     type(ESMF_AttWriteFlag), intent(in),  optional :: attwriteflag
!     integer,                 intent(out), optional :: rc
!
! !DESCRIPTION:
!     Write the Attribute package for <object>.  The Attribute package defines
!     the convention, purpose, and object type of the associated Attributes.  Either
!     tab-delimited or xml format is acheived by using {\tt attwriteflag}.
!     Currently, only ESMF/ESG/CF Field Attribute packages can be written in
!     tab-delimited format.  See Section~\ref{sec:AttPacks} for a description
!     of Attribute packages and their conventions, purposes, and object types.
!
!     This call is collective across the current VM.
!
!     Writing Attribute XML files is performed with the standard C++ output
!     file stream facility.
!
!     Note:  For an object type of {\tt ESMF\_GridComp}, convention='WaterML',
!     purpose='TimeSeries', and
!     \newline
!     attwriteflag=ESMF\_ATTWRITE\_XML, an XML file
!     conforming to a hydrologic standard called WaterML will be written.  See
!     the following for more information:
!
!     \begin{description}
!     \item{"http://his.cuahsi.org/wofws.html"}
!     \item{"http://www.earthsystemcurator.org/projects/waterml.shtml"}
!     \end{description}
!
!     An ESMF Use Test Case is available which showcases an example of how
!     to write a WaterML file; please see
!
!     \begin{description}
!     \item{"http://esmf.cvs.sourceforge.net/viewvc/esmf/use\_test\_cases/ESMF\_WaterML"}
!     \item{"http://esmf.cvs.sourceforge.net/viewvc/esmf/use\_test\_cases/README"}
!     \end{description}
!
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array),       intent(in) :: array
!     \item type(ESMF\_ArrayBundle), intent(in) :: arraybundle
!     \item type(ESMF\_CplComp),     intent(in) :: comp
!     \item type(ESMF\_GridComp),    intent(in) :: comp
!     \item type(ESMF\_SciComp),     intent(in) :: comp
!     \item type(ESMF\_Field),       intent(in) :: field
!     \item type(ESMF\_FieldBundle), intent(in) :: fieldbundle
!     \item type(ESMF\_Grid),        intent(in) :: grid
!     \item type(ESMF\_State),       intent(in) :: state
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object
!     \item [{[convention]}]
!           The convention of the Attribute package
!     \item [{[purpose]}]
!           The purpose of the Attribute package
!     \item [{[attwriteflag]}]
!           The flag to specify which format is desired for the write, the
!           default is ESMF\_ATTWRITE\_TAB.  This flag is documented in
!           section \ref{const:attwrite}.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
!     \end{description}
!
!EOP
!------------------------------------------------------------------------------


!-------------------------------------------------------------------------
!  Macro versions of the routines
!-------------------------------------------------------------------------

#define AttPackGetMacro(mclass, mthis, mthisfield) \
@\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttPackGet" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttPackGet - Retrieve a handle to an Attribute package @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttPackGet() @\
      subroutine mclass##AttPackGet(mthis, attpack, & @\
        convention, purpose, attPackInstanceName, rc) @\
 @\
      type(mclass), intent(in) :: mthis   @\
	    type(ESMF_Attribute), intent(inout) :: attpack @\
      character (len = *), intent(in) :: convention @\
      character (len = *), intent(in) :: purpose @\
      character (len = *), intent(in), optional :: attPackInstanceName @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!      Returns an Attribute from the object. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [attpack] @\
!           The Attribute package to return. @\
!     \item [convention] @\
!           The convention of the Attribute package. @\
!     \item [purpose] @\
!           The purpose of the Attribute package. @\
!     \item [{[attPackInstanceName]}] @\
!           The name of an Attribute package instance, specifying which one @\
!           of multiple Attribute package instances of the same convention @\
!           and purpose, within a nest.  If not specified, defaults to the @\
!           first instance.  @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc @\
      character(len=*), parameter :: fobject=#mthis @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      call c_ESMC_AttPackGet(mthisfield, attpack, & @\
      						convention, purpose, & @\
                            fobject, attPackInstanceName, localrc) @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttPackGet @\
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------

#define AttAddPackStandardMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttAddPackStd" @\
 @\
!BOPI @\
! !IROUTINE: AttAddPackStd - Add an ESMF standard Attribute package @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeAdd() @\
      subroutine mclass##AttAddPackStd(mthis, convention, purpose, attpack, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis @\
      character (len = *), intent(in) :: convention @\
      character (len = *), intent(in) :: purpose @\
 	    type(ESMF_Attribute), intent(inout), optional :: attpack @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Add an ESMF standard Attribute package @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!      An {\tt mclass} object. @\
!     \item [convention] @\
!      The convention of the new Attribute package. @\
!     \item [purpose] @\
!      The purpose of the new Attribute package. @\
!     \item [{[attpack}]] @\
!      An optional handle to the Attribute package that is to be created. @\
!     \item [{[rc]}]  @\
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc                           ! Error status @\
      character (len=*), parameter :: object=#mthis @\
 @\
      ! Initialize return code; assume failure until success is certain @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      if (.not.((convention.eq."ESG" .and.purpose.eq."General").or. & @\
                (convention.eq."ESMF".and.purpose.eq."General").or. & @\
                (convention.eq."CF".and.purpose.eq."General").or. & @\
                (convention.eq."CF".and.purpose.eq."Extended").or. & @\
                (convention.eq."CIM 1.5.1".and.purpose.eq."grids").or. & @\
                (convention.eq."CIM 1.5".and.purpose.eq."ModelComp").or. & @\
                (convention.eq."CIM 1.5".and.purpose.eq."Inputs"))) then @\
        call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, & @\
          msg="See ESMF Reference Manual for ESMF standard Attribute package convention and purpose values", & @\
          ESMF_CONTEXT, rcToReturn=rc) @\
        return @\
      endif @\
 @\
      call c_ESMC_AttPackCreateStandard(mthisfield, convention, & @\
        purpose, object, localrc) @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
         ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
 	  ! retrieve the optional attribute package handle @\
 	  if (present(attpack)) then @\
 @\
 	    ! set the created macro @\
        ESMF_INIT_SET_CREATED(attpack) @\
 @\
        call mclass##AttPackGet(mthis, attpack, & @\
                                convention, purpose, rc=localrc) @\
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
      endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttAddPackStd

!------------------------------------------------------------------------------

#define AttAddPackStandardNMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttAddPackStdN" @\
 @\
!BOPI @\
! !IROUTINE: AttAddPackStdN - Add an ESMF standard Attribute package with nested standard Attribute packages @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeAdd() @\
      subroutine mclass##AttAddPackStdN(mthis, convention, purpose, & @\
      nestConvention, nestPurpose, nestAttPackInstanceCountList, & @\
      nestAttPackInstanceNameList, nestCount, & @\
      nestAttPackInstanceNameCount, attpack, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis @\
      character (len = *), intent(in) :: convention @\
      character (len = *), intent(in) :: purpose @\
      character (len = *), dimension(:), intent(in) :: nestConvention @\
      character (len = *), dimension(:), intent(in) :: nestPurpose @\
      integer, dimension(:), intent(in) :: nestAttPackInstanceCountList @\
      character (len = *), dimension(:), intent(out) :: nestAttPackInstanceNameList @\
      integer, intent(in), optional :: nestCount @\
      integer, intent(out), optional :: nestAttPackInstanceNameCount @\
 	    type(ESMF_Attribute), intent(inout), optional :: attpack @\
      integer, intent(out), optional :: rc @\
 @\
! @\
! !DESCRIPTION: @\
!     Add an ESMF standard Attribute package which contains a user-specified @\
!     number of nested standard Attribute packages.  ESMF generates and @\
!     returns default instance names for the nested Attribute packages.  @\
!     These names can be used later to distinguish among multiple nested @\
!     Attribute packages of the same type in calls to @\
!     {\tt ESMF\_AttributeGet()}, {\tt ESMF\_AttributeSet()}, and @\
!     {\tt ESMF\_AttributeRemove()}.  See Section~\ref{sec:AttPacks} for a @\
!     description of Attribute packages and their conventions, purposes, @\
!     and object types. @\
! @\
!     Add an ESMF standard Attribute package which contains a user-specified @\
!     number of nested standard Attribute packages.  The user specifies the @\
!     names of the nested Attribute package instances (not yet implemented), @\
!     or ESMF generates and returns default instance names. These names can @\
!     be used later to distinguish among multiple nested Attribute packages @\
!     of the same type in calls to {\tt ESMF\_AttributeGet()}, @\
!     {\tt ESMF\_AttributeSet()}, and {\tt ESMF\_AttributeRemove()}. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!      An ESMF object. @\
!     \item [attpack] @\
!      The Attribute package to be created. @\
!     \item [convention] @\
!      The convention of the new Attribute package. @\
!     \item [purpose] @\
!      The purpose of the new Attribute package. @\
!     \item [nestConvention] @\
!      The convention(s) of the standard Attribute package type(s) around @\
!      which to nest the new Attribute package. @\
!     \item [nestPurpose] @\
!      The purpose(s) of the standard Attribute package type(s) around @\
!      which to nest the new Attribute package. @\
!     \item [nestAttPackInstanceCountList] @\
!      The desired number of nested Attribute package instances for each @\
!      nested (nestConvention, nestPurpose) package type. Note: if only one @\
!      of each nested package type is desired, then the @\
!      {\tt ESMF\_AttributeAdd()} overloaded method @\
!      {\tt ESMF\_AttAddPackStd()} should be used. @\
!     \item [nestAttPackInstanceNameList] @\
!      The name(s) of the nested Attribute package instances, generated @\
!      by ESMF, used to distinguish between multiple instances of the @\
!      same convention and purpose. @\
!     \item [{[nestCount]}] @\
!      The count of the number of nested Attribute package types to add to @\
!      the new Attribute package. @\
!     \item [{[nestAttPackInstanceNameCount]}] @\
!      The number of nested Attribute package instance names. @\
!     \item [{[attpack}]] @\
!      An optional handle to the Attribute package that is to be created. @\
!     \item [{[rc]}]  @\
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, i, j, k @\
      integer :: localNestCount, localNestAPinstNameSize, totalInstances @\
      integer :: localNestAPinstNameCount @\
      character(len=*), parameter :: object=#mthis @\
      integer, dimension(size(nestConvention)) :: nestConvLens @\
      integer, dimension(size(nestPurpose)) :: nestPurpLens @\
      character(len=(size(nestConvention)*len(nestConvention))) :: nestConvString @\
      character(len=(size(nestPurpose)*len(nestPurpose))) :: nestPurpString @\
      integer, dimension(size(nestAttPackInstanceNameList)) :: nestAPinstNameLens @\
      character(len=(size(nestAttPackInstanceNameList)*len(nestAttPackInstanceNameList))) :: nestAPinstNameString @\
 @\
      ! Initialize return code; assume failure until success is certain @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      ! TODO: check if (convention, purpose) is standard attpack type @\
      !       if so, then check if (nestConvention, nestPurpose) are standard @\
      !       children of the parent @\
 @\
      if (size(nestConvention).ne.size(nestPurpose)) then @\
         call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & @\
           msg="number of items in nestConvention and nestPurpose must be the same", & @\
           ESMF_CONTEXT, rcToReturn=rc) @\
         return @\
      endif @\
 @\
      if (size(nestAttPackInstanceCountList).ne.size(nestConvention)) then @\
         call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & @\
           msg="number of items in nestAttPackInstanceCountList and nestConvention must be the same", & @\
           ESMF_CONTEXT, rcToReturn=rc) @\
         return @\
      endif @\
 @\
      if (present(nestCount)) then @\
        if (nestCount > size(nestConvention)) then @\
          call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & @\
            msg="nestCount cannot be larger than size(nestConvention)", & @\
            ESMF_CONTEXT, rcToReturn=rc) @\
          return @\
        endif @\
        localNestCount = nestCount @\
      else @\
        localNestCount = size(nestConvention) @\
      end if @\
      if (localNestCount .le. 0) then @\
        call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & @\
                   msg="size(nestConvention) and size(nestPurpose) or nestCount are <= 0", & @\
                    ESMF_CONTEXT, rcToReturn=rc) @\
        return @\
      endif @\
 @\
      ! pack conv,purp strings and lengths, add up instances @\
      j = 1 @\
      k = 1 @\
      totalInstances = 0 @\
      do  i=1,localNestCount @\
        nestConvLens(i) = len_trim(nestConvention(i)) @\
        nestPurpLens(i) = len_trim(nestPurpose(i)) @\
        nestConvString(j:(j+nestConvLens(i)-1)) = nestConvention(i) @\
        nestPurpString(k:(k+nestPurpLens(i)-1)) = nestPurpose(i) @\
        j = j + nestConvLens(i) @\
        k = k + nestPurpLens(i) @\
        totalInstances = totalInstances + nestAttPackInstanceCountList(i) @\
      enddo @\
 @\
      if (totalInstances.gt.size(nestAttPackInstanceNameList)) then @\
         call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & @\
           msg="size(nestAttPackInstanceNameList) not big enough for the number of instances specified in nestAttPackInstanceCountList", & @\
           ESMF_CONTEXT, rcToReturn=rc) @\
         return @\
      endif @\
 @\
      ! pack widths of NameList elements @\
      ! TODO: pack actual lengths (len_trim) when implementing name input @\
      localNestAPinstNameSize = size(nestAttPackInstanceNameList) @\
      do  i=1,localNestAPinstNameSize @\
        nestAPinstNameLens(i) = len(nestAttPackInstanceNameList(i)) @\
      enddo @\
 @\
      call c_ESMC_AttPackCreateStdNest(mthisfield, convention, & @\
        purpose, object, nestConvString, nestPurpString, & @\
        nestConvLens, nestPurpLens, nestAttPackInstanceCountList, & @\
        localNestCount, & @\
        nestAPinstNameString, nestAPinstNameLens, localNestAPinstNameSize, & @\
        localNestAPinstNameCount, localrc) @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
         ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      ! unpack returned attpack instance names @\
      j = 1 @\
      do  i=1,localNestAPinstNameCount @\
        nestAttPackInstanceNameList(i) = & @\
                       nestAPinstNameString(j:(j+nestAPinstNameLens(i)-1)) @\
        j = j + nestAPinstNameLens(i) @\
      enddo @\
 @\
      ! return number of attpack instance names @\
      if (present(nestAttPackInstanceNameCount)) then @\
        nestAttPackInstanceNameCount = localNestAPinstNameCount @\
      endif @\
 @\
 	  ! retrieve the optional attribute package handle @\
 	  if (present(attpack)) then @\
 @\
 	    ! set the created macro @\
        ESMF_INIT_SET_CREATED(attpack) @\
 @\
        call mclass##AttPackGet(mthis, attpack, & @\
                                convention, purpose, rc=localrc) @\
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
      endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttAddPackStdN

!------------------------------------------------------------------------------

#define AttAddPackCustomMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttAddPackCst" @\
!BOPI @\
! !IROUTINE: AttAddPackCst - Add a custom Attribute package @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeAdd() @\
      subroutine mclass##AttAddPackCst(mthis, attrList, convention, purpose, & @\
      count, attpack, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), dimension(:), intent(in) :: attrList @\
      character (len = *), intent(in) :: convention @\
      character (len = *), intent(in) :: purpose @\
      integer, intent(in), optional :: count @\
 	    type(ESMF_Attribute), intent(inout), optional :: attpack @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Add a custom Attribute package for the object, or modify an existing @\
!     Attribute package. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!      An ESMF object. @\
!     \item [attrList] @\
!      An array of character strings specifying the names of the user defined Attributes @\
!     \item [convention] @\
!      The convention of the new Attribute package. @\
!     \item [purpose] @\
!      The purpose of the new Attribute package. @\
!     \item [{[count]}] @\
!      The count of the number of Attributes to add to the package @\
!     \item [{[attpack}]] @\
!      An optional handle to the Attribute package that is to be created. @\
!     \item [{[rc]}]  @\
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, i, localCount @\
      character(len=*), parameter :: object=#mthis @\
 @\
      ! Initialize return code; assume failure until success is certain @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      if (present(count)) then @\
        if (count > size(attrList)) then @\
          call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & @\
            msg="count cannot be larger than size(attrList)", & @\
            ESMF_CONTEXT, rcToReturn=rc) @\
          return @\
        endif @\
        if (count .le. 0) then @\
          call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & @\
            msg="count is <= 0", & @\
            ESMF_CONTEXT, rcToReturn=rc) @\
          return @\
        endif @\
        localCount = count @\
      else @\
        localCount = size(attrList) @\
      end if @\
 @\
      call c_ESMC_AttPackCreateCustom(mthisfield, convention, & @\
        purpose, object, localrc) @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
         ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      do i = 1, localCount @\
        call c_ESMC_AttPackAddAttribute(mthisfield, attrList(i), & @\
                           convention, purpose, object, localrc) @\
      end do @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
         ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
 	  ! retrieve the optional attribute package handle @\
 	  if (present(attpack)) then @\
 @\
 	    ! set the created macro @\
        ESMF_INIT_SET_CREATED(attpack) @\
 @\
        call mclass##AttPackGet(mthis, attpack, & @\
                                convention, purpose, rc=localrc) @\
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
      endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttAddPackCst

!------------------------------------------------------------------------------

#define AttAddPackCustomNMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttAddPackCstN" @\
!BOPI @\
! !IROUTINE: AttAddPackCstN - Add a custom Attribute package with nested Attribute Packages @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeAdd() @\
      subroutine mclass##AttAddPackCstN(mthis, convention, purpose, & @\
      attrList, count, nestConvention, nestPurpose, nestCount, attpack, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), dimension(:), intent(in), optional :: attrList @\
      character (len = *), intent(in) :: convention @\
      character (len = *), intent(in) :: purpose @\
      integer, intent(in), optional :: count @\
      character (len = *), dimension(:), intent(in) :: nestConvention @\
      character (len = *), dimension(:), intent(in) :: nestPurpose @\
      integer, intent(in), optional :: nestCount @\
 	    type(ESMF_Attribute), intent(inout), optional :: attpack @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Add a custom Attribute package for the object, with one or more nested @\
!     Attribute packages, or modify an existing Attribute package. @\
!     Allows for building full multiple-child Attribute hierarchies @\
!     (multi-child trees). @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!      An ESMF object. @\
!     \item [{[attrList]}] @\
!      An array of character strings specifying the names of the user defined Attributes @\
!     \item [convention] @\
!      The convention of the new Attribute package. @\
!     \item [purpose] @\
!      The purpose of the new Attribute package. @\
!     \item [{[count]}] @\
!      The count of the number of Attributes to add to the package @\
!     \item [nestConvention] @\
!      The convention(s) of the Attribute package(s) around which to nest the @\
!      new Attribute package. @\
!     \item [nestPurpose] @\
!      The purpose(s) of the Attribute package(s) around which to nest the @\
!      new Attribute package. @\
!     \item [{[nestCount]}] @\
!      The count of the number of nested Attribute packages to add to the @\
!      new Attribute package @\
!     \item [{[attpack}]] @\
!      An optional handle to the Attribute package that is to be created. @\
!     \item [{[rc]}]  @\
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, i, j, k, localCount, localNestCount @\
      character(len=*), parameter :: object=#mthis @\
      integer, dimension(size(nestConvention)) :: nestConvLens @\
      integer, dimension(size(nestPurpose)) :: nestPurpLens @\
      character(len=(size(nestConvention)*len(nestConvention))) :: nestConvString @\
      character(len=(size(nestPurpose)*len(nestPurpose))) :: nestPurpString @\
 @\
      ! Initialize return code; assume failure until success is certain @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      localCount = 0 @\
      if (present(attrList)) then @\
        if (present(count)) then @\
          if (count > size(attrList)) then @\
            call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & @\
              msg="count cannot be larger than size(attrList)", & @\
              ESMF_CONTEXT, rcToReturn=rc) @\
            return @\
          endif @\
          if (count .lt. 0) then @\
            call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & @\
              msg="count is negative", & @\
              ESMF_CONTEXT, rcToReturn=rc) @\
            return @\
          endif @\
          localCount = count @\
        else @\
          localCount = size(attrList) @\
        end if @\
      end if @\
 @\
      if (size(nestConvention).ne.size(nestPurpose)) then @\
         call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & @\
           msg="number of items in nestConvention and nestPurpose must be the same", & @\
           ESMF_CONTEXT, rcToReturn=rc) @\
         return @\
      endif @\
 @\
      if (present(nestCount)) then @\
        if (nestCount > size(nestConvention)) then @\
          call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, & @\
            msg="nestCount cannot be larger than size(nestConvention)", & @\
            ESMF_CONTEXT, rcToReturn=rc) @\
          return @\
        endif @\
        localNestCount = nestCount @\
      else @\
        localNestCount = size(nestConvention) @\
      end if @\
      if (localNestCount .le. 0) then @\
        call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & @\
                   msg="size(nestConvention) and size(nestPurpose) or nestCount are <= 0", & @\
                    ESMF_CONTEXT, rcToReturn=rc) @\
        return @\
      endif @\
 @\
      j = 1 @\
      k = 1 @\
      do  i=1,localNestCount @\
        nestConvLens(i) = len_trim(nestConvention(i)) @\
        nestPurpLens(i) = len_trim(nestPurpose(i)) @\
        nestConvString(j:(j+nestConvLens(i)-1)) = nestConvention(i) @\
        nestPurpString(k:(k+nestPurpLens(i)-1)) = nestPurpose(i) @\
        j = j + nestConvLens(i) @\
        k = k + nestPurpLens(i) @\
      enddo @\
 @\
      call c_ESMC_AttPackNest(mthisfield, convention, & @\
        purpose, object, localNestCount, nestConvString, nestPurpString, & @\
        nestConvLens, nestPurpLens, localrc) @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
         ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (localCount .gt. 0) then @\
        do i = 1, localCount @\
          call c_ESMC_AttPackAddAttribute(mthisfield, attrList(i), & @\
                             convention, purpose, object, localrc) @\
        end do @\
      endif @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
         ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
 	  ! retrieve the optional attribute package handle @\
 	  if (present(attpack)) then @\
 @\
 	    ! set the created macro @\
        ESMF_INIT_SET_CREATED(attpack) @\
 @\
        call mclass##AttPackGet(mthis, attpack, & @\
                                convention, purpose, rc=localrc) @\
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
      endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttAddPackCstN

!------------------------------------------------------------------------------

#define AttAddPackCustomN1Macro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttAddPackCstN1" @\
!BOPI @\
! !IROUTINE: AttAddPackCstN1 - Add a custom Attribute package with a single nested Attribute package @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeAdd() @\
      subroutine mclass##AttAddPackCstN1(mthis, attrList, convention, purpose, & @\
      count, nestConvention, nestPurpose, attpack, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), dimension(:), intent(in), optional :: attrList @\
      character (len = *), intent(in) :: convention @\
      character (len = *), intent(in) :: purpose @\
      integer, intent(in), optional :: count @\
      character (len = *), intent(in) :: nestConvention @\
      character (len = *), intent(in) :: nestPurpose @\
 	    type(ESMF_Attribute), intent(inout), optional :: attpack @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Add a custom Attribute package for the object, with a single @\
!     nested Attribute package, or modify an existing Attribute package. @\
!     Allows for building single-child Attribute hierarchies @\
!     (single-child trees). @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!      An ESMF object. @\
!     \item [{[attrList]}] @\
!      An array of character strings specifying the names of the user defined Attributes @\
!     \item [convention] @\
!      The convention of the new Attribute package. @\
!     \item [purpose] @\
!      The purpose of the new Attribute package. @\
!     \item [{[count]}] @\
!      The count of the number of Attributes to add to the package @\
!     \item [nestConventio] @\
!      The convention of the Attribute package around which to nest the @\
!      new Attribute package. @\
!     \item [nestPurpose] @\
!      The purpose of the Attribute package around which to nest the @\
!      new Attribute package. @\
!     \item [{[attpack}]] @\
!      An optional handle to the Attribute package that is to be created. @\
!     \item [{[rc]}]  @\
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc @\
      character(len=len(nestConvention)), dimension(1) :: nestConvString @\
      character(len=len(nestPurpose)), dimension(1) :: nestPurpString @\
 @\
      ! Initialize return code; assume failure until success is certain @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      nestConvString(1) = nestConvention @\
      nestPurpString(1) = nestPurpose @\
 @\
      call mclass##AttAddPackCstN(mthis, & @\
                                  convention, purpose, & @\
                                  attrList, count, & @\
                                  nestConvString, nestPurpString, & @\
                                  nestCount=1, attpack=attpack, rc=localrc) @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
         ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
 	  ! retrieve the optional attribute package handle @\
 	  if (present(attpack)) then @\
 @\
 	    ! set the created macro @\
        ESMF_INIT_SET_CREATED(attpack) @\
 @\
        call mclass##AttPackGet(mthis, attpack, & @\
                                convention, purpose, rc=localrc) @\
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
      endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttAddPackCstN1

!------------------------------------------------------------------------------

#define AttCopyMacro(mclass1, mclass2, mthis1, mthis2, mthisfield1, mthisfield2) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttributeCopy" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeCopy - Copy an Attribute hierarchy between objects @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeCopy() @\
      subroutine mclass1##AttCopy(mthis1, mthis2, copyflag, atttreeflag, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass1), intent(in) :: mthis1   @\
      type(mclass2), intent(inout) :: mthis2 @\
      type(ESMF_Copy_Flag), intent(in) :: copyflag @\
      type(ESMF_AttTreeFlag), intent(in) :: atttreeflag @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Copy all Attributes in one hierarchy to another. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis1] @\
!      An {\tt mclass1} object. @\
!     \item [mthis2] @\
!      An {\tt mclass2} object. @\
!     \item [copyflag] @\
!      A flag to determine if the copy is to be by reference, value, or both @\
!     \item [atttreeflag] @\
!      A flag to determine if the copy is supposed to descend the Attribute @\
!      hierarchy @\
!     \item [{[rc]}] @\
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass1##GetInit,mthis1,rc) @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass2##GetInit,mthis2,rc) @\
 @\
      call c_ESMC_AttributeCopy(mthisfield1, mthisfield2, & @\
                                copyflag, atttreeflag, localrc) @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
         ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass1##AttCopy @\

!------------------------------------------------------------------------------

#define AttGetDoc() \
!BOPI @\
!EOPI @\


#define AttGetBMacro(mtype, mtypekind, mclass, mthis, mthisfield) \
@\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGet" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet() @\
      subroutine mclass##AttGet##mtypekind(mthis, name, value, & @\
        defaultvalue, inputList, attpack, isPresent, rc) @\
 @\
      type(mclass), intent(in) :: mthis   @\
      character (len = *), intent(in) :: name @\
      mtype(ESMF_KIND_##mtypekind), intent(out) :: value @\
      mtype(ESMF_KIND_##mtypekind), intent(in), optional :: defaultvalue @\
      character (len=*), intent(in), optional :: inputList(:) @\
	    type(ESMF_Attribute), intent(in), optional :: attpack @\
      logical, intent(out), optional :: isPresent @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!      Returns an Attribute from the object. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to retrieve. @\
!     \item [value] @\
!           The real value of the named Attribute. @\
!     \item [{[defaultvalue]}] @\
!           The real default value of the named Attribute. @\
!     \item [{[inputList]}] @\
!           A list of the input parameters required to retrieve internal info. @\
!     \item [{[attpack]}] @\
!           An Attribute package handle containing identifying information. @\
!     \item [{[isPresent]}] @\
!           A logical flag to tell if this Attribute is present or not @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
@\
      integer :: localrc, i @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_Logical) :: lisPresent @\
      integer :: count @\
      !! TODO: this needs to be dynamically sized !!! @\
      character (len=ESMF_MAXSTR) :: modName @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      lisPresent = ESMF_FALSE @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      !!!! TODO: this can go away once modName is dynamically sized !!! @\
      if (len(name) > ESMF_MAXSTR) then @\
        call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & @\
          msg="len(name) cannot be larger than ESMF_MAXSTR for now", & @\
          ESMF_CONTEXT, rcToReturn=rc) @\
        return @\
      endif @\
      ! Call into routine to retrieve internal class info @\
      ! return directly from here if info is found @\
      if (AttributeInternalInfo(name, modName)) then @\
        call ESMF_AttributeGetInfo(mthis, name=modName, & @\
          value=value, inputList=inputList, rc=localrc) @\
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        if (present(rc)) rc = ESMF_SUCCESS @\
        return @\
      endif @\
 @\
      count = 1 @\
 @\
      if (present(attpack)) then @\
        call c_ESMC_AttPackIsPresent(mthisfield, name, attpack, & @\
        							 lisPresent, localrc) @\
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        if (lisPresent == ESMF_TRUE) then @\
          call c_ESMC_AttPackGetValue(mthisfield, name, attpack, & @\
            ESMF_TYPEKIND_##mtypekind, count, & @\
            value, localrc) @\
        endif @\
      else @\
       @\
        call c_ESMC_AttributeIsPresent(mthisfield, name, lisPresent, localrc) @\
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
        if (lisPresent == ESMF_TRUE) then @\
          call c_ESMC_AttributeGetValue(mthisfield, name, & @\
            ESMF_TYPEKIND_##mtypekind, count, value, localrc) @\
        endif @\
      endif @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(isPresent)) then @\
        isPresent = lisPresent @\
      endif @\
 @\
      if(lisPresent .ne. ESMF_TRUE) then @\
        if(present(defaultvalue)) then @\
          value = defaultvalue @\
        else @\
          call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & @\
            msg="Attribute not found and default value not given", & @\
            ESMF_CONTEXT, rcToReturn=rc) @\
          return @\
        endif @\
      endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttGet##mtypekind @\
!------------------------------------------------------------------------------

#define AttGet1DBMacro(mtype, mtypekind, mclass, mthis, mthisfield) \
@\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGet1D" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet() @\
      subroutine mclass##AttGet1D##mtypekind(mthis, name, valueList, & @\
        defaultvalueList, inputList, attpack, & @\
        itemCount, isPresent, rc) @\
 @\
      type(mclass), intent(in) :: mthis   @\
      character (len=*), intent(in) :: name @\
      mtype(ESMF_KIND_##mtypekind), dimension(:), intent(out) :: valueList @\
      mtype(ESMF_KIND_##mtypekind), dimension(:), intent(in), optional :: defaultvalueList @\
      character (len=*), intent(in), optional :: inputList(:) @\
 	    type(ESMF_Attribute), intent(in), optional :: attpack @\
      integer, intent(out), optional :: itemCount    @\
      logical, intent(out), optional :: isPresent @\
      integer, intent(out), optional :: rc @\
 @\
! @\
! !DESCRIPTION: @\
!      Returns an Attribute from the object. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to retrieve. @\
!     \item [valueList] @\
!           The list of real values of the named Attribute. @\
!     \item [{[defaultvalueList]}] @\
!           The list of real default values of the named Attribute. @\
!     \item [{[inputList]}] @\
!           A list of the input parameters required to retrieve internal info. @\
!     \item [{[attpack]}] @\
!           An Attribute package handle containing identifying information. @\
!     \item [{[isPresent]}] @\
!           A logical flag to tell if this Attribute is present or not @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, litemCount, i @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_Logical) :: lisPresent @\
      type(ESMF_TypeKind_Flag) :: localTk @\
      !! TODO: this needs to be dynamically sized !!! @\
      character (len=ESMF_MAXSTR) :: modName @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      lisPresent = ESMF_FALSE @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      !!!! TODO: this can go away once modName is dynamically sized !!! @\
      if (len(name) > ESMF_MAXSTR) then @\
        call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & @\
          msg="len(name) cannot be larger than ESMF_MAXSTR for now", & @\
          ESMF_CONTEXT, rcToReturn=rc) @\
        return @\
      endif @\
      ! Call into routine to retrieve internal class info @\
      ! return directly from here if info is found @\
      if (AttributeInternalInfo(name, modName)) then @\
        call ESMF_AttributeGetInfo(mthis, name=modName, & @\
          valueList=valueList, inputList=inputList, rc=localrc) @\
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        if (present(rc)) rc = ESMF_SUCCESS @\
        return @\
      endif @\
 @\
      litemcount = size(valueList) @\
 @\
      if (present(attpack)) then @\
        call c_ESMC_AttPackIsPresent(mthisfield, name, attpack, & @\
          							 lisPresent, localrc) @\
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        if (lisPresent == ESMF_TRUE) then @\
        call c_ESMC_AttPackGetValue(mthisfield, name, attpack, & @\
          ESMF_TYPEKIND_##mtypekind, litemCount, & @\
          valueList, localrc) @\
        end if @\
      else @\
        call c_ESMC_AttributeIsPresent(mthisfield, name, lisPresent, localrc) @\
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        if (lisPresent == ESMF_TRUE) then @\
          call c_ESMC_AttributeGetValue(mthisfield, name, & @\
           ESMF_TYPEKIND_##mtypekind, litemCount, valueList, localrc) @\
        endif @\
      endif @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(isPresent)) then @\
        isPresent = lisPresent @\
      endif @\
 @\
      if(lisPresent .ne. ESMF_TRUE) then @\
        if(present(defaultvalueList)) then @\
          if(size(valueList) .lt. size(defaultvalueList)) then @\
            do i=1,size(valueList) @\
              valueList(i) = defaultvalueList(i) @\
            enddo @\
            if(present(itemCount)) then @\
              itemCount = size(valueList) @\
            endif @\
          else @\
            do i=1,size(defaultvalueList) @\
              valueList(i) = defaultvalueList(i) @\
            enddo @\
            if(present(itemCount)) then @\
              itemCount = size(defaultvalueList) @\
            endif @\
          endif @\
        else @\
          ! must set itemCount to 0 in this case because it will not have been @\
          ! modified from the original size of the given valueList @\
          if(present(itemCount)) then @\
            itemCount = 0 @\
          endif @\
          call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & @\
               msg="Attribute not found and default value not given", & @\
               ESMF_CONTEXT, rcToReturn=rc) @\
            return @\
        endif @\
 @\
      else @\
 @\
        if(present(itemCount)) then @\
          call c_ESMC_AttributeGetInfoName(mthisfield, name, localTk, & @\
            litemCount, localrc) @\
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
            ESMF_CONTEXT, rcToReturn=rc)) return @\
          itemCount = litemCount @\
        endif @\
 @\
      endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttGet1D##mtypekind @\

!------------------------------------------------------------------------------

#define AttGetLogicalBMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGetLgcl" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet() @\
      subroutine mclass##AttGetLgcl(mthis, name, value, defaultvalue, & @\
        attpack, isPresent, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(in) :: mthis   @\
      character (len = *), intent(in) :: name @\
      logical, intent(out) :: value @\
      logical, intent(in), optional :: defaultvalue @\
	    type(ESMF_Attribute), intent(in), optional :: attpack @\
      logical, intent(out), optional :: isPresent @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!      Returns a logical Attribute from the {\tt array}. @\
!  @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to retrieve. @\
!     \item [value] @\
!           The logical value of the named Attribute. @\
!     \item [{[defaultvalue]}] @\
!           The logical default value of the named Attribute. @\
!     \item [{[attpack]}] @\
!           An Attribute package handle containing identifying information. @\
!     \item [{[isPresent]}] @\
!           A logical flag to tell if this Attribute is present or not @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_Logical) :: lisPresent, localvalue @\
      integer :: count @\
@\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      lisPresent = ESMF_FALSE @\
 @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      count = 1 @\
 @\
      if (present(attpack)) then @\
        call c_ESMC_AttPackIsPresent(mthisfield, name, attpack, & @\
          							 lisPresent, localrc) @\
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        if (lisPresent == ESMF_TRUE) then @\
          call c_ESMC_AttPackGetValue(mthisfield, name, attpack, & @\
            ESMF_TYPEKIND_LOGICAL, count, & @\
            localvalue, localrc) @\
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
            ESMF_CONTEXT, rcToReturn=rc)) return @\
          value = localvalue   @\
        end if @\
      else @\
        call c_ESMC_AttributeIsPresent(mthisfield, name, lisPresent, localrc) @\
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        if (lisPresent == ESMF_TRUE) then @\
          call c_ESMC_AttributeGetValue(mthisfield, name, & @\
            ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) @\
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
            ESMF_CONTEXT, rcToReturn=rc)) return @\
          value = localvalue @\
        endif @\
      endif @\
 @\
      if (present(isPresent)) then @\
        isPresent = lisPresent @\
      endif @\
 @\
      if(lisPresent .ne. ESMF_TRUE) then @\
        if(present(defaultvalue)) then @\
          value = defaultvalue @\
        else @\
          call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & @\
               msg="Attribute not found and default values not given", & @\
               ESMF_CONTEXT, rcToReturn=rc) @\
          return @\
        endif @\
      endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttGetLgcl @\
 @\
!------------------------------------------------------------------------------ @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGetLgclList" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet() @\
      subroutine mclass##AttGetLgclList(mthis, name, valueList, & @\
        defaultvalueList, inputList, attpack, itemCount, isPresent, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(in) :: mthis   @\
      character (len=*), intent(in) :: name @\
      logical, dimension(:), intent(out) :: valueList @\
      logical, dimension(:), intent(in), optional :: defaultvalueList @\
      character (len=*), intent(in), optional :: inputList(:) @\
	    type(ESMF_Attribute), intent(in), optional :: attpack @\
      integer, intent(out), optional :: itemCount @\
      logical, intent(out), optional :: isPresent @\
      integer, intent(out), optional :: rc @\
 @\
! @\
! !DESCRIPTION: @\
!      Returns a logical list Attribute from the object. @\
!  @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to retrieve. @\
!     \item [valueList] @\
!           The logical values of the named Attribute. @\
!     \item [{[defaultvalueList]}] @\
!           The logical default value of the named Attribute. @\
!     \item [{[inputList]}] @\
!           A list of the input parameters required to retrieve internal info. @\
!     \item [{[attpack]}] @\
!           An Attribute package handle containing identifying information. @\
!     \item [{[itemCount]}] @\
!           The number of values in the Attribute. @\
!     \item [{[isPresent]}] @\
!           A logical flag to tell if this Attribute is present or not @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, litemCount, i @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_Logical) :: lisPresent @\
      type(ESMF_TypeKind_Flag) :: localTk @\
      !! TODO: this needs to be dynamically sized !!! @\
      character (len=ESMF_MAXSTR) :: modName @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      lisPresent = ESMF_FALSE @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      !!!! TODO: this can go away once modName is dynamically sized !!! @\
      if (len(name) > ESMF_MAXSTR) then @\
        call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & @\
          msg="len(name) cannot be larger than ESMF_MAXSTR for now", & @\
          ESMF_CONTEXT, rcToReturn=rc) @\
        return @\
      endif @\
      ! Call into routine to retrieve internal class info @\
      ! return directly from here if info is found @\
      if (AttributeInternalInfo(name, modName)) then @\
        call ESMF_AttributeGetInfo(mthis, name=modName, & @\
          valueList=valueList, inputList=inputList, rc=localrc) @\
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        if (present(rc)) rc = ESMF_SUCCESS @\
        return @\
      endif @\
 @\
      litemCount = size(valueList) @\
 @\
      if (present(attpack)) then @\
        call c_ESMC_AttPackIsPresent(mthisfield, name, attpack, & @\
          							 lisPresent, localrc) @\
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        if (lisPresent == ESMF_TRUE) then @\
          call c_ESMC_AttPackGetValue(mthisfield, name, attpack, & @\
            ESMF_TYPEKIND_LOGICAL, litemCount, & @\
            valueList, localrc) @\
        end if @\
      else @\
        call c_ESMC_AttributeIsPresent(mthisfield, name, lisPresent, localrc) @\
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        if (lisPresent == ESMF_TRUE) then @\
          call c_ESMC_AttributeGetValue(mthisfield, name, & @\
            ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) @\
        endif @\
      endif @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(isPresent)) then @\
        isPresent = lisPresent @\
      endif @\
 @\
      if(lisPresent .ne. ESMF_TRUE) then @\
        if(present(defaultvalueList)) then @\
          if(size(valueList) .lt. size(defaultvalueList)) then @\
            do i=1,size(valueList) @\
              valueList(i) = defaultvalueList(i) @\
            enddo @\
            if(present(itemCount)) then @\
              itemCount = size(valueList) @\
            endif @\
          else @\
            do i=1,size(defaultvalueList) @\
              valueList(i) = defaultvalueList(i) @\
            enddo @\
            if(present(itemCount)) then @\
              itemCount = size(defaultvalueList) @\
            endif @\
          endif @\
        else @\
          ! must set itemCount to 0 in this case because it will not have been @\
          ! modified from the original size of the given valueList @\
          if(present(itemCount)) then @\
            itemCount = 0 @\
          endif @\
          call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & @\
               msg="Attribute not found and default values not given", & @\
               ESMF_CONTEXT, rcToReturn=rc) @\
          return @\
        endif @\
 @\
      else @\
 @\
        if(present(itemCount)) then @\
          call c_ESMC_AttributeGetInfoName(mthisfield, name, localTk, & @\
            litemCount, localrc) @\
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
            ESMF_CONTEXT, rcToReturn=rc)) return @\
          itemCount = litemCount @\
        endif @\
 @\
      endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttGetLgclList @\

!------------------------------------------------------------------------------

#define AttGetCharacterBMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGetChar" @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet() @\
      subroutine mclass##AttGetChar(mthis, name, value, defaultvalue, & @\
        attpack, isPresent, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(in) :: mthis   @\
      character (len = *), intent(in) :: name @\
      character (len = *), intent(out) :: value @\
      character (len = *), intent(in), optional :: defaultvalue @\
 	    type(ESMF_Attribute), intent(in), optional :: attpack @\
      logical, intent(out), optional :: isPresent @\
      integer, intent(out), optional :: rc @\
 @\
! @\
! !DESCRIPTION: @\
!      Returns a character Attribute from the object. @\
!  @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to retrieve. @\
!     \item [value] @\
!           The character value of the named Attribute. @\
!     \item [{[defaultvalue]}] @\
!           The character default value of the named Attribute. @\
!     \item [{[attpack]}] @\
!           An Attribute package handle containing identifying information. @\
!     \item [{[isPresent]}] @\
!           A logical flag to tell if this Attribute is present or not @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_Logical) :: lisPresent @\
      integer, dimension(1) :: lens @\
      integer :: count @\
      !! TODO: this needs to be dynamically sized !!! @\
      character (len=ESMF_MAXSTR) :: modName @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      lisPresent = ESMF_FALSE @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
@\
      !!!! TODO: this can go away once modName is dynamically sized !!! @\
      if (len(name) > ESMF_MAXSTR) then @\
        call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & @\
          msg="len(name) cannot be larger than ESMF_MAXSTR for now", & @\
          ESMF_CONTEXT, rcToReturn=rc) @\
        return @\
      endif @\
      ! Call into routine to retrieve internal class info @\
      ! return directly from here if info is found @\
      if (AttributeInternalInfo(name, modName)) then @\
        call ESMF_AttributeGetInfo(mthis, name=modName, & @\
          value=value, rc=localrc) @\
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        if (present(rc)) rc = ESMF_SUCCESS @\
        return @\
      endif @\
 @\
      lens(1) = len(value) @\
      count = 1 @\
 @\
      if (present(attpack)) then @\
        call c_ESMC_AttPackIsPresent(mthisfield, name, attpack, & @\
          							 lisPresent, localrc) @\
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        if (lisPresent == ESMF_TRUE) then @\
          call c_ESMC_AttPackGetCharList(mthisfield, attpack, name, attpack, & @\
            ESMF_TYPEKIND_CHARACTER, count, lens, & @\
            value, localrc) @\
        end if @\
      else @\
        call c_ESMC_AttributeIsPresent(mthisfield, name, lisPresent, localrc) @\
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        if (lisPresent == ESMF_TRUE) then @\
          call c_ESMC_AttributeGetCharList(mthisfield, name, & @\
          	ESMF_TYPEKIND_CHARACTER, count, lens, value, localrc) @\
        endif @\
      endif @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(isPresent)) then @\
        isPresent = lisPresent @\
      endif @\
 @\
      if(lisPresent .ne. ESMF_TRUE) then @\
        if(present(defaultvalue)) then @\
          value = defaultvalue @\
        else @\
          call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & @\
            msg="Attribute not found and default value not given", & @\
            ESMF_CONTEXT, rcToReturn=rc) @\
          return @\
        endif @\
      endif @\
 @\
      if (present(rc)) rc = localrc @\
 @\
      end subroutine mclass##AttGetChar @\
 @\
!------------------------------------------------------------------------------ @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGetCharList" @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet() @\
      subroutine mclass##AttGetCharList(mthis, name, valueList, & @\
        defaultvalueList, attpack, & @\
        itemCount, isPresent, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(in) :: mthis   @\
      character (len = *), intent(in) :: name @\
      character (len=*), dimension(:), intent(out) :: valueList @\
      character (len=*), dimension(:), intent(in), optional :: defaultvalueList @\
  	  type(ESMF_Attribute), intent(in), optional :: attpack @\
      integer, intent(out), optional :: itemCount @\
      logical, intent(out), optional :: isPresent @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!      Returns a character Attribute from the object. @\
!  @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to retrieve. @\
!     \item [valueList] @\
!           The character list values of the named Attribute. @\
!     \item [{[defaultvalueList]}] @\
!           The character list default value of the named Attribute. @\
!     \item [{[attpack]}] @\
!           An Attribute package handle containing identifying information. @\
!     \item [{[itemCount]}] @\
!           The itemCount of the character items to retrieve @\
!     \item [{[isPresent]}] @\
!           A logical flag to tell if this Attribute is present or not @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, i, j, litemCount @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_Logical) :: lisPresent @\
      type(ESMF_TypeKind_Flag) :: localTk @\
      integer, dimension(size(valueList)) :: lens @\
      character(len=(size(valueList)*len(valueList))) :: valueString @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      lisPresent = ESMF_FALSE @\
      valueString = "" @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
	  litemCount = size(valueList) @\
 @\
      do  i=1,litemCount @\
        lens(i) = len(valueList) @\
      enddo @\
 @\
      if (present(attpack)) then @\
        call c_ESMC_AttPackIsPresent(mthisfield, name, attpack, & @\
        							 lisPresent, localrc) @\
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        if (lisPresent == ESMF_TRUE) then @\
          call c_ESMC_AttPackGetCharList(mthisfield, name, attpack, & @\
            ESMF_TYPEKIND_CHARACTER, litemCount, lens, valueString, localrc) @\
        end if @\
      else @\
        call c_ESMC_AttributeIsPresent(mthisfield, name, lisPresent, localrc) @\
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        if (lisPresent == ESMF_TRUE) then @\
          call c_ESMC_AttributeGetCharList(mthisfield, name, ESMF_TYPEKIND_CHARACTER, & @\
            litemCount, lens, valueString, localrc) @\
        endif @\
      endif @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(isPresent)) then @\
        isPresent = lisPresent @\
      endif @\
 @\
      if(lisPresent .ne. ESMF_TRUE) then @\
        if(present(defaultvalueList)) then @\
          if(size(valueList) .lt. size(defaultvalueList)) then @\
            do i=1,size(valueList) @\
              valueList(i) = defaultvalueList(i) @\
            enddo @\
            if(present(itemCount)) then @\
              itemCount = size(valueList) @\
            endif @\
          else @\
            do i=1,size(defaultvalueList) @\
              valueList(i) = defaultvalueList(i) @\
            enddo @\
            if(present(itemCount)) then @\
              itemCount = size(defaultvalueList) @\
            endif @\
          endif @\
        else @\
          ! must set itemCount to 0 in this case because it will not have been @\
          ! modified from the original size of the given valueList @\
          if(present(itemCount)) then @\
            itemCount = 0 @\
          endif @\
          call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & @\
               msg="Attribute not found and default values not given", & @\
               ESMF_CONTEXT, rcToReturn=rc) @\
          return @\
        endif @\
 @\
      else @\
 @\
        j = 1 @\
        do  i=1,litemCount @\
          valueList(i) = valueString(j:(j+lens(i)-1)) @\
          j = j + lens(i) @\
        enddo @\
 @\
        if(present(itemCount)) then @\
          call c_ESMC_AttributeGetInfoName(mthisfield, name, localTk, & @\
            litemCount, localrc) @\
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
            ESMF_CONTEXT, rcToReturn=rc)) return @\
          itemCount = litemCount @\
        endif @\
 @\
      endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttGetCharList @\

!------------------------------------------------------------------------------

#define AttGetMacro(mtype, mtypekind, mclass, mthis, mthisfield) \
@\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGet" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet() @\
      subroutine mclass##AttGet##mtypekind(mthis, name, value, & @\
        defaultvalue, attpack, isPresent, rc) @\
 @\
      type(mclass), intent(in) :: mthis   @\
      character (len = *), intent(in) :: name @\
      mtype(ESMF_KIND_##mtypekind), intent(out) :: value @\
      mtype(ESMF_KIND_##mtypekind), intent(in), optional :: defaultvalue @\
	    type(ESMF_Attribute), intent(in), optional :: attpack @\
      logical, intent(out), optional :: isPresent @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!      Returns an Attribute from the object. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to retrieve. @\
!     \item [value] @\
!           The real value of the named Attribute. @\
!     \item [{[defaultvalue]}] @\
!           The real default value of the named Attribute. @\
!     \item [{[attpack]}] @\
!           An Attribute package handle containing identifying information. @\
!     \item [{[isPresent]}] @\
!           A logical flag to tell if this Attribute is present or not @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
@\
      integer :: localrc @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_Logical) :: lisPresent @\
      integer :: count @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      lisPresent = ESMF_FALSE @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      count = 1 @\
 @\
 @\
      if (present(attpack)) then @\
        call c_ESMC_AttPackIsPresent(mthisfield, name, attpack, & @\
        							 lisPresent, localrc) @\
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        if (lisPresent == ESMF_TRUE) then @\
          call c_ESMC_AttPackGetValue(mthisfield, name, attpack, & @\
            ESMF_TYPEKIND_##mtypekind, count, value, localrc) @\
        endif @\
      else @\
       @\
        call c_ESMC_AttributeIsPresent(mthisfield, name, lisPresent, localrc) @\
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
        if (lisPresent == ESMF_TRUE) then @\
          call c_ESMC_AttributeGetValue(mthisfield, name, & @\
            ESMF_TYPEKIND_##mtypekind, count, value, localrc) @\
        endif @\
      endif @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(isPresent)) then @\
        isPresent = lisPresent @\
      endif @\
 @\
      if(lisPresent .ne. ESMF_TRUE) then @\
        if(present(defaultvalue)) then @\
          value = defaultvalue @\
        else @\
          call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & @\
               msg="Attribute not found and default value not given", & @\
               ESMF_CONTEXT, rcToReturn=rc) @\
          return @\
        endif @\
      endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttGet##mtypekind @\
!------------------------------------------------------------------------------

#define AttGet1DMacro(mtype, mtypekind, mclass, mthis, mthisfield) \
@\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGet1D" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet() @\
      subroutine mclass##AttGet1D##mtypekind(mthis, name, valueList, & @\
        defaultvalueList, attpack, itemCount, isPresent, rc) @\
 @\
      type(mclass), intent(in) :: mthis   @\
      character (len=*), intent(in) :: name @\
      mtype(ESMF_KIND_##mtypekind), dimension(:), intent(out) :: valueList @\
      mtype(ESMF_KIND_##mtypekind), dimension(:), intent(in), optional :: defaultvalueList @\
	    type(ESMF_Attribute), intent(in), optional :: attpack @\
      integer, intent(out), optional :: itemCount    @\
      logical, intent(out), optional :: isPresent @\
      integer, intent(out), optional :: rc @\
 @\
! @\
! !DESCRIPTION: @\
!      Returns an Attribute from the object. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to retrieve. @\
!     \item [valueList] @\
!           The list of real values of the named Attribute. @\
!     \item [{[defaultvalueList]}] @\
!           The list of real default values of the named Attribute. @\
!     \item [{[attpack]}] @\
!           An Attribute package handle containing identifying information. @\
!     \item [{[isPresent]}] @\
!           A logical flag to tell if this Attribute is present or not @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, litemCount, i @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_Logical) :: lisPresent @\
      type(ESMF_TypeKind_Flag) :: localTk @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      lisPresent = ESMF_FALSE @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      litemcount = size(valueList) @\
 @\
      if (present(attpack)) then @\
        call c_ESMC_AttPackIsPresent(mthisfield, name, attpack, & @\
        							 lisPresent, localrc) @\
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        if (lisPresent == ESMF_TRUE) then @\
        call c_ESMC_AttPackGetValue(mthisfield, name, attpack, & @\
          ESMF_TYPEKIND_##mtypekind, litemCount, valueList, localrc) @\
        end if @\
      else @\
        call c_ESMC_AttributeIsPresent(mthisfield, name, lisPresent, localrc) @\
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        if (lisPresent == ESMF_TRUE) then @\
          call c_ESMC_AttributeGetValue(mthisfield, name, & @\
           ESMF_TYPEKIND_##mtypekind, litemCount, valueList, localrc) @\
        endif @\
      endif @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(isPresent)) then @\
        isPresent = lisPresent @\
      endif @\
 @\
      if(lisPresent .ne. ESMF_TRUE) then @\
        if(present(defaultvalueList)) then @\
          if(size(valueList) .lt. size(defaultvalueList)) then @\
            do i=1,size(valueList) @\
              valueList(i) = defaultvalueList(i) @\
            enddo @\
            if(present(itemCount)) then @\
              itemCount = size(valueList) @\
            endif @\
          else @\
            do i=1,size(defaultvalueList) @\
              valueList(i) = defaultvalueList(i) @\
            enddo @\
            if(present(itemCount)) then @\
              itemCount = size(defaultvalueList) @\
            endif @\
          endif @\
        else @\
          ! must set itemCount to 0 in this case because it will not have been @\
          ! modified from the original size of the given valueList @\
          if(present(itemCount)) then @\
            itemCount = 0 @\
          endif @\
          call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & @\
               msg="Attribute not found and default value not given", & @\
               ESMF_CONTEXT, rcToReturn=rc) @\
            return @\
        endif @\
 @\
      else @\
 @\
        if(present(itemCount)) then @\
          call c_ESMC_AttributeGetInfoName(mthisfield, name, localTk, & @\
            litemCount, localrc) @\
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
            ESMF_CONTEXT, rcToReturn=rc)) return @\
          itemCount = litemCount @\
        endif @\
 @\
      endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttGet1D##mtypekind @\

!------------------------------------------------------------------------------

#define AttGetLogicalMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGetLgcl" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet() @\
      subroutine mclass##AttGetLgcl(mthis, name, value, defaultvalue, & @\
        attpack, isPresent, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(in) :: mthis   @\
      character (len = *), intent(in) :: name @\
      logical, intent(out) :: value @\
      logical, intent(in), optional :: defaultvalue @\
	    type(ESMF_Attribute), intent(in), optional :: attpack @\
      logical, intent(out), optional :: isPresent @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!      Returns a logical Attribute from the {\tt array}. @\
!  @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to retrieve. @\
!     \item [value] @\
!           The logical value of the named Attribute. @\
!     \item [{[defaultvalue]}] @\
!           The logical default value of the named Attribute. @\
!     \item [{[attpack]}] @\
!           An Attribute package handle containing identifying information. @\
!     \item [{[isPresent]}] @\
!           A logical flag to tell if this Attribute is present or not @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_Logical) :: lisPresent, localvalue @\
      integer :: count @\
@\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      lisPresent = ESMF_FALSE @\
 @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      count = 1 @\
 @\
      if (present(attpack)) then @\
        call c_ESMC_AttPackIsPresent(mthisfield, name, attpack, & @\
        							 lisPresent, localrc) @\
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        if (lisPresent == ESMF_TRUE) then @\
          call c_ESMC_AttPackGetValue(mthisfield, name, attpack, & @\
            ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) @\
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
            ESMF_CONTEXT, rcToReturn=rc)) return @\
          value = localvalue   @\
        end if @\
      else @\
        call c_ESMC_AttributeIsPresent(mthisfield, name, lisPresent, localrc) @\
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        if (lisPresent == ESMF_TRUE) then @\
          call c_ESMC_AttributeGetValue(mthisfield, name, & @\
            ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) @\
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
            ESMF_CONTEXT, rcToReturn=rc)) return @\
          value = localvalue @\
        endif @\
      endif @\
 @\
      if (present(isPresent)) then @\
        isPresent = lisPresent @\
      endif @\
 @\
      if(lisPresent .ne. ESMF_TRUE) then @\
        if(present(defaultvalue)) then @\
          value = defaultvalue @\
        else @\
          call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & @\
               msg="Attribute not found and default values not given", & @\
               ESMF_CONTEXT, rcToReturn=rc) @\
          return @\
        endif @\
      endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttGetLgcl @\
 @\
!------------------------------------------------------------------------------ @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGetLgclList" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet() @\
      subroutine mclass##AttGetLgclList(mthis, name, valueList, & @\
        defaultvalueList, attpack, itemCount, isPresent, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(in) :: mthis   @\
      character (len=*), intent(in) :: name @\
      logical, dimension(:), intent(out) :: valueList @\
      logical, dimension(:), intent(in), optional :: defaultvalueList @\
 	    type(ESMF_Attribute), intent(in), optional :: attpack @\
      integer, intent(out), optional :: itemCount    @\
      logical, intent(out), optional :: isPresent @\
      integer, intent(out), optional :: rc @\
 @\
! @\
! !DESCRIPTION: @\
!      Returns a logical list Attribute from the object. @\
!  @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to retrieve. @\
!     \item [valueList] @\
!           The logical values of the named Attribute. @\
!     \item [{[defaultvalueList]}] @\
!           The logical default value of the named Attribute. @\
!     \item [{[attpack]}] @\
!           An Attribute package handle containing identifying information. @\
!     \item [{[itemCount]}] @\
!           The number of values in the Attribute. @\
!     \item [{[isPresent]}] @\
!           A logical flag to tell if this Attribute is present or not @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, litemCount, i @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_Logical) :: lisPresent @\
      type(ESMF_TypeKind_Flag) :: localTk @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      lisPresent = ESMF_FALSE @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      litemCount = size(valueList) @\
 @\
      if (present(attpack)) then @\
        call c_ESMC_AttPackIsPresent(mthisfield, name, attpack, & @\
        							 lisPresent, localrc) @\
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        if (lisPresent == ESMF_TRUE) then @\
          call c_ESMC_AttPackGetValue(mthisfield, name, attpack, & @\
            ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) @\
        end if @\
      else @\
        call c_ESMC_AttributeIsPresent(mthisfield, name, lisPresent, localrc) @\
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        if (lisPresent == ESMF_TRUE) then @\
          call c_ESMC_AttributeGetValue(mthisfield, name, & @\
            ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) @\
        endif @\
      endif @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(isPresent)) then @\
        isPresent = lisPresent @\
      endif @\
 @\
      if(lisPresent .ne. ESMF_TRUE) then @\
        if(present(defaultvalueList)) then @\
          if(size(valueList) .lt. size(defaultvalueList)) then @\
            do i=1,size(valueList) @\
              valueList(i) = defaultvalueList(i) @\
            enddo @\
            if(present(itemCount)) then @\
              itemCount = size(valueList) @\
            endif @\
          else @\
            do i=1,size(defaultvalueList) @\
              valueList(i) = defaultvalueList(i) @\
            enddo @\
            if(present(itemCount)) then @\
              itemCount = size(defaultvalueList) @\
            endif @\
          endif @\
        else @\
          ! must set itemCount to 0 in this case because it will not have been @\
          ! modified from the original size of the given valueList @\
          if(present(itemCount)) then @\
            itemCount = 0 @\
          endif @\
          call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & @\
               msg="Attribute not found and default values not given", & @\
               ESMF_CONTEXT, rcToReturn=rc) @\
          return @\
        endif @\
 @\
      else @\
 @\
        if(present(itemCount)) then @\
          call c_ESMC_AttributeGetInfoName(mthisfield, name, localTk, & @\
            litemCount, localrc) @\
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
            ESMF_CONTEXT, rcToReturn=rc)) return @\
          itemCount = litemCount @\
        endif @\
 @\
      endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttGetLgclList @\

!------------------------------------------------------------------------------

#define AttGetCharacterMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGetChar" @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet() @\
      subroutine mclass##AttGetChar(mthis, name, value, defaultvalue, & @\
        attpack, isPresent, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(in) :: mthis   @\
      character (len = *), intent(in) :: name @\
      character (len = *), intent(out) :: value @\
      character (len = *), intent(in), optional :: defaultvalue @\
  	  type(ESMF_Attribute), intent(in), optional :: attpack @\
      logical, intent(out), optional :: isPresent @\
      integer, intent(out), optional :: rc @\
 @\
! @\
! !DESCRIPTION: @\
!      Returns a character Attribute from the object. @\
!  @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to retrieve. @\
!     \item [value] @\
!           The character value of the named Attribute. @\
!     \item [{[defaultvalue]}] @\
!           The character default value of the named Attribute. @\
!     \item [{[attpack]}] @\
!           An Attribute package handle containing identifying information. @\
!     \item [{[isPresent]}] @\
!           A logical flag to tell if this Attribute is present or not @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_Logical) :: lisPresent @\
      integer, dimension(1) :: lens @\
      integer :: count @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      lisPresent = ESMF_FALSE @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
@\
      lens(1) = len(value) @\
      count = 1 @\
@\
      if (present(attpack)) then @\
        call c_ESMC_AttPackIsPresent(mthisfield, name, attpack, & @\
        							 lisPresent, localrc) @\
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        if (lisPresent == ESMF_TRUE) then @\
          call c_ESMC_AttPackGetCharList(mthisfield, name, attpack, & @\
            ESMF_TYPEKIND_CHARACTER, count, lens, value, localrc) @\
        end if @\
      else @\
        call c_ESMC_AttributeIsPresent(mthisfield, name, lisPresent, localrc) @\
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        if (lisPresent == ESMF_TRUE) then @\
          call c_ESMC_AttributeGetCharList(mthisfield, name, ESMF_TYPEKIND_CHARACTER, & @\
            count, lens, value, localrc) @\
        endif @\
      endif @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(isPresent)) then @\
        isPresent = lisPresent @\
      endif @\
 @\
      if(lisPresent .ne. ESMF_TRUE) then @\
        if(present(defaultvalue)) then @\
          value = defaultvalue @\
        else @\
          call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & @\
               msg="Attribute not found and default value not given", & @\
               ESMF_CONTEXT, rcToReturn=rc) @\
          return @\
        endif @\
      endif @\
 @\
      if (present(rc)) rc = localrc @\
 @\
      end subroutine mclass##AttGetChar @\
 @\
!------------------------------------------------------------------------------ @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGetCharList" @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet() @\
      subroutine mclass##AttGetCharList(mthis, name, valueList, & @\
        defaultvalueList, attpack, itemCount, isPresent, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(in) :: mthis   @\
      character (len = *), intent(in) :: name @\
      character (len=*), dimension(:), intent(out) :: valueList @\
      character (len=*), dimension(:), intent(in), optional :: defaultvalueList @\
   	  type(ESMF_Attribute), intent(in), optional :: attpack @\
      integer, intent(out), optional :: itemCount @\
      logical, intent(out), optional :: isPresent @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!      Returns a character Attribute from the object. @\
!  @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to retrieve. @\
!     \item [valueList] @\
!           The character list values of the named Attribute. @\
!     \item [{[defaultvalueList]}] @\
!           The character list default value of the named Attribute. @\
!     \item [{[attpack]}] @\
!           An Attribute package handle containing identifying information. @\
!     \item [{[itemCount]}] @\
!           The itemCount of the character items to retrieve @\
!     \item [{[isPresent]}] @\
!           A logical flag to tell if this Attribute is present or not @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, i, j, litemCount @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_Logical) :: lisPresent @\
      type(ESMF_TypeKind_Flag) :: localTk @\
      integer, dimension(size(valueList)) :: lens @\
      character(len=(size(valueList)*len(valueList))) :: valueString @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      lisPresent = ESMF_FALSE @\
      valueString = "" @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
	  litemCount = size(valueList) @\
 @\
      do  i=1,litemCount @\
        lens(i) = len(valueList) @\
      enddo @\
 @\
      if (present(attpack)) then @\
        call c_ESMC_AttPackIsPresent(mthisfield, name, attpack, & @\
        							 lisPresent, localrc) @\
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        if (lisPresent == ESMF_TRUE) then @\
          call c_ESMC_AttPackGetCharList(mthisfield, name, attpack, & @\
            ESMF_TYPEKIND_CHARACTER, litemCount, lens, valueString, localrc) @\
        end if @\
      else @\
        call c_ESMC_AttributeIsPresent(mthisfield, name, lisPresent, localrc) @\
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        if (lisPresent == ESMF_TRUE) then @\
          call c_ESMC_AttributeGetCharList(mthisfield, name, ESMF_TYPEKIND_CHARACTER, & @\
            litemCount, lens, valueString, localrc) @\
        endif @\
      endif @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(isPresent)) then @\
        isPresent = lisPresent @\
      endif @\
 @\
      if(lisPresent .ne. ESMF_TRUE) then @\
        if(present(defaultvalueList)) then @\
          if(size(valueList) .lt. size(defaultvalueList)) then @\
            do i=1,size(valueList) @\
              valueList(i) = defaultvalueList(i) @\
            enddo @\
            if(present(itemCount)) then @\
              itemCount = size(valueList) @\
            endif @\
          else @\
            do i=1,size(defaultvalueList) @\
              valueList(i) = defaultvalueList(i) @\
            enddo @\
            if(present(itemCount)) then @\
              itemCount = size(defaultvalueList) @\
            endif @\
          endif @\
        else @\
          ! must set itemCount to 0 in this case because it will not have been @\
          ! modified from the original size of the given valueList @\
          if(present(itemCount)) then @\
            itemCount = 0 @\
          endif @\
          call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & @\
               msg="Attribute not found and default values not given", & @\
               ESMF_CONTEXT, rcToReturn=rc) @\
          return @\
        endif @\
 @\
      else @\
 @\
        j = 1 @\
        do  i=1,litemCount @\
          valueList(i) = valueString(j:(j+lens(i)-1)) @\
          j = j + lens(i) @\
        enddo @\
 @\
        if(present(itemCount)) then @\
          call c_ESMC_AttributeGetInfoName(mthisfield, name, localTk, & @\
            litemCount, localrc) @\
          if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
            ESMF_CONTEXT, rcToReturn=rc)) return @\
          itemCount = litemCount @\
        endif @\
 @\
      endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttGetCharList @\

!------------------------------------------------------------------------------

#define GetCountNameNumberMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGetCount" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet()  @\
      subroutine mclass##AttGetCount(mthis, count, attcountflag, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(in) :: mthis   @\
      integer, intent(out) :: count    @\
      type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Returns the number of Attributes associated with the given object  @\
!     in the argument {\tt count}. @\
!  @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [count] @\
!           The number of Attributes associated with this object. @\
!     \item [attcountflag] @\
!           Flag to determine which Attribute count to return. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc  @\
      type(ESMF_AttGetCountFlag) :: lattcountflag @\
 @\
      ! Initialize  @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      if (present(attcountflag)) then @\
        lattcountflag = attcountflag @\
      else @\
        lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE @\
      endif @\
 @\
      call c_ESMC_AttributeGetCount(mthisfield, count, lattcountflag, localrc) @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttGetCount @\
 @\
!------------------------------------------------------------------------------ @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGetInfoByNam" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Query Attributes by name @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet() @\
      subroutine mclass##AttGetInfoByNam(mthis, name, keywordEnforcer, & @\
                             attpack, typekind, itemCount, isPresent, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(in) :: mthis   @\
      character(len=*), intent(in) :: name @\
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below @\
	    type(ESMF_Attribute), intent(in), optional :: attpack @\
      type(ESMF_TypeKind_Flag), intent(out), optional :: typekind @\
      integer, intent(out), optional :: itemCount    @\
      logical, intent(out), optional :: isPresent @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Returns information associated with the named Attribute,  @\
!     including {\tt typekind} and {\tt itemCount}. @\
!  @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to query. @\
!     \item [{[attpack]}] @\
!           An Attribute package handle containing identifying information. @\
!     \item [{[typekind]}] @\
!           The typekind of the Attribute. @\
!     \item [{[itemCount]}] @\
!           The number of items in this Attribute.  For character types, @\
!           the length of the character string. @\
!     \item [{[isPresent]}] @\
!           A logical flag to tell if this Attribute is present or not @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc              @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_Logical) :: lisPresent @\
      type(ESMF_TypeKind_Flag) :: localTk @\
      integer :: litemCount @\
 @\
      ! Initialize  @\
      lisPresent = ESMF_FALSE @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      if (present(attpack)) then @\
        call c_ESMC_AttPackIsPresent(mthisfield, name, attpack, & @\
          							 lisPresent, localrc) @\
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        if (lisPresent == ESMF_TRUE) then @\
          call c_ESMC_AttPackGetInfoName(mthisfield, name, attpack, & @\
          								 localTk, litemCount, localrc) @\
        end if @\
      else @\
        call c_ESMC_AttributeIsPresent(mthisfield, name, lisPresent, localrc) @\
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        if (lisPresent == ESMF_TRUE) then @\
          call c_ESMC_AttributeGetInfoName(mthisfield, name, & @\
            localTk, litemCount, localrc) @\
        endif @\
      endif @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(isPresent)) then @\
        isPresent = lisPresent @\
      endif @\
 @\
      if(lisPresent .eq. ESMF_TRUE) then @\
        if (present(typekind)) typekind = localTk @\
        if (present(itemCount)) itemCount = litemCount @\
      else @\
        if (present(typekind)) typekind = ESMF_NOKIND @\
        if (present(itemCount)) itemCount = 0 @\
        if (.not.present(isPresent).and..not.present(itemCount).and..not.present(typekind)) then @\
          call ESMF_LogSetError(rcToCheck=ESMF_RC_ATTR_NOTSET, & @\
             msg="Attribute not found and neither default values nor isPresent flag was given", & @\
             ESMF_CONTEXT, rcToReturn=rc) @\
          return @\
        endif @\
      endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttGetInfoByNam @\
 @\
!------------------------------------------------------------------------------ @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGetInfoByNum" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Query Attributes by index number @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet() @\
      subroutine mclass##AttGetInfoByNum(mthis, attributeIndex, name, & @\
        typekind, itemCount, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(in) :: mthis   @\
      integer, intent(in) :: attributeIndex @\
      character(len=*), intent(out) :: name @\
      type(ESMF_TypeKind_Flag), intent(out), optional :: typekind @\
      integer, intent(out), optional :: itemCount @\
      integer, intent(out), optional :: rc @\
 @\
! @\
! !DESCRIPTION: @\
!      Returns information associated with the indexed Attribute,  @\
!      including {\tt name}, {\tt typekind} and {\tt itemCount}. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [attributeIndex] @\
!           The index number of the Attribute to query. @\
!     \item [name] @\
!           Returns the name of the Attribute. @\
!     \item [{[typekind]}] @\
!           Returns the typekind of the Attribute. @\
!     \item [{[itemCount]}] @\
!           Returns the number of items in this Attribute.  For character @\
!           types, this is the length of the character string. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc  @\
      character(len=len(name)) :: localName @\
      type(ESMF_TypeKind_Flag) :: localTk @\
      integer :: litemCount @\
 @\
      ! Initialize  @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      call c_ESMC_AttributeGetInfoNum(mthisfield, attributeIndex, & @\
        localName, localTk, litemCount, localrc) @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      name = localName @\
      if (present(typekind)) typekind = localTk @\
      if (present(itemCount)) itemCount = litemCount @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttGetInfoByNum @\
 @\

!------------------------------------------------------------------------------

#define AttGetAPinstNamesMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGetAPinstNames" @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Retrieve a list of AttPack instance names @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet() @\
      subroutine mclass##AttGetAPinstNames(mthis, convention, purpose, & @\
        attPackInstanceNameList, attPackInstanceNameCount, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(in) :: mthis @\
      character (len = *), intent(in) :: convention @\
      character (len = *), intent(in) :: purpose @\
      character (len = *), dimension(:), intent(out) :: attPackInstanceNameList @\
      integer, intent(out) :: attPackInstanceNameCount @\
      integer, intent(out), optional :: rc @\
 @\
! @\
! !DESCRIPTION: @\
!     Get the Attribute package instance names of the specified convention @\
!     and purpose.  Also get the number of such names. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!      An ESMF object. @\
!     \item [convention] @\
!      The convention of the Attribute package instances. @\
!     \item [purpose] @\
!      The purpose of the Attribute package instances. @\
!     \item [attPackInstanceNameList] @\
!      The name(s) of the Attribute package instances of the given @\
!      convention and purpose. @\
!     \item [attPackInstanceNameCount] @\
!      The number of Attribute package instance names. @\
!     \item [{[rc]}]  @\
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, i, j, APinstNameSize @\
      character(len=*), parameter :: object=#mthis @\
      integer, dimension(size(attPackInstanceNameList)) :: APinstNameLens @\
      character(len=(size(attPackInstanceNameList)*len(attPackInstanceNameList))) :: APinstNameString @\
@\
      ! Initialize return code; assume failure until success is certain @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      ! pack widths of NameList elements @\
      APinstNameSize = size(attPackInstanceNameList) @\
      do  i=1,APinstNameSize @\
        APinstNameLens(i) = len(attPackInstanceNameList(i)) @\
      enddo @\
 @\
      call c_ESMC_AttPackGetAPinstNames(mthisfield, & @\
        convention, purpose, object, & @\
        APinstNameString, APinstNameLens, APinstNameSize, & @\
        attPackInstanceNameCount, localrc) @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
         ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      ! unpack returned attpack instance names @\
      j = 1 @\
      do  i=1,attPackInstanceNameCount @\
        attPackInstanceNameList(i) = & @\
                       APinstNameString(j:(j+APinstNameLens(i)-1)) @\
        j = j + APinstNameLens(i) @\
      enddo @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttGetAPinstNames @\

!-----------------------------------------------------------------------------

#define AttLinkMacro(mclass1, mclass2, mclass2short, mthis1, mthis2, mthisfield1, mthisfield2) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttLink" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeLink() @\
      subroutine mclass1##AttLink##mclass2short(mthis1, mthis2, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass1), intent(inout) :: mthis1 @\
      type(mclass2), intent(in)  :: mthis2 @\
      integer, intent(out), optional  :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Attaches two Attribute hierarchies @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis1] @\
!      An {\tt mclass1} object. @\
!     \item [mthis2] @\
!      An {\tt mclass2} object. @\
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc                           ! Error status @\
      type(ESMF_Logical) :: linkChange @\
 @\
      ! Initialize return code; assume failure until success is certain @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(mclass1##GetInit,mthis1,rc) @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(mclass2##GetInit,mthis2,rc) @\
 @\
      linkChange = ESMF_TRUE @\
      call c_ESMC_AttributeLink(mthisfield1, mthisfield2, linkChange, localrc) @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass1##AttLink##mclass2short @\

!-----------------------------------------------------------------------------

#define AttLinkCompMacro(mclass1, mclass2, mclass2short, mthis1, mthis2, mthisfield1, mthisfield2) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttLink" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeLink() @\
      subroutine mclass1##AttLink##mclass2short(mthis1, mthis2, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass1), intent(inout) :: mthis1 @\
      type(mclass2), intent(in)  :: mthis2 @\
      integer, intent(out), optional  :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Attaches two Attribute hierarchies @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis1] @\
!      An {\tt mclass1} object. @\
!     \item [mthis2] @\
!      An {\tt mclass2} object. @\
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc                           ! Error status @\
      type(ESMF_Logical) :: linkChange @\
 @\
      ! Initialize return code; assume failure until success is certain @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(mclass1##GetInit,mthis1,rc) @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(mclass2##GetInit,mthis2,rc) @\
 @\
      linkChange = ESMF_FALSE @\
      call c_ESMC_AttributeLink(mthisfield1, mthisfield2, linkChange, localrc) @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass1##AttLink##mclass2short @\

!-----------------------------------------------------------------------------

#define AttLinkStateMacro(mclass, mclassshort, mthis1, mthis2, mthisfield1, mthisfield2, mthisfield3, mobj) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_StateAttLink" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeLink() @\
      subroutine ESMF_StateAttLink##mclassshort(mthis1, mthis2, rc) @\
! @\
! !ARGUMENTS: @\
      type(ESMF_State), intent(inout) :: mthis1 @\
      type(mclass), intent(in)  :: mthis2 @\
      integer, intent(out), optional  :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Attaches two Attribute hierarchies @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis1] @\
!      An {\tt ESMF\_State} object. @\
!     \item [mthis2] @\
!      An {\tt mclass} object. @\
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc                           ! Error status @\
      type(ESMF_Logical) :: lvalue1, lvalue2 @\
      character (len=*), parameter :: lobject = #mobj @\
      character (len=*), parameter :: lname1 = 'import' @\
      character (len=*), parameter :: lname2 = 'export' @\
      type(ESMF_Logical) :: linkChange @\
 @\
      ! Initialize return code; assume failure until success is certain @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,mthis1,rc) @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis2,rc) @\
 @\
      linkChange = ESMF_TRUE @\
      call c_ESMC_AttributeLink(mthisfield1, mthisfield2, linkChange, localrc) @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      ! set the import and export Attributes on any Field connected to this State @\
      lvalue1 = .true. @\
      lvalue2 = .false. @\
      if (mthis1%mthisfield3 == ESMF_STATEINTENT_IMPORT) then @\
        call c_ESMC_AttributeSetObjsInTree(mthisfield1, lobject, lname1, & @\
          ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc) @\
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        call c_ESMC_AttributeSetObjsInTree(mthisfield1, lobject, lname2, & @\
          ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc) @\
      else if (mthis1%mthisfield3 == ESMF_STATEINTENT_EXPORT) then @\
        call c_ESMC_AttributeSetObjsInTree(mthisfield1, lobject, lname1, & @\
          ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc) @\
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc)) return @\
        call c_ESMC_AttributeSetObjsInTree(mthisfield1, lobject, lname2, & @\
          ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc) @\
      endif @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine ESMF_StateAttLink##mclassshort @\

!-----------------------------------------------------------------------------

#define AttLinkRemoveMacro(mclass1, mclass2, mclass2short, mthis1, mthis2, mthisfield1, mthisfield2) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttLinkRemove" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeLinkRemove() @\
      subroutine mclass1##AttLinkRm##mclass2short(mthis1, mthis2, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass1), intent(inout) :: mthis1 @\
      type(mclass2), intent(in)  :: mthis2 @\
      integer, intent(out), optional  :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Unattaches two Attribute hierarchies @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis1] @\
!      An {\tt mclass1} object. @\
!     \item [mthis2] @\
!      An {\tt mclass2} object. @\
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc                           ! Error status @\
      type(ESMF_Logical) :: linkChange @\
 @\
      ! Initialize return code; assume failure until success is certain @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(mclass1##GetInit,mthis1,rc) @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(mclass2##GetInit,mthis2,rc) @\
 @\
      linkChange = ESMF_TRUE @\
      call c_ESMC_AttributeLinkRemove(mthisfield1, mthisfield2, linkChange, localrc) @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass1##AttLinkRm##mclass2short @\

!-----------------------------------------------------------------------------

#define AttLinkRemoveCompMacro(mclass1, mclass2, mclass2short, mthis1, mthis2, mthisfield1, mthisfield2) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttLinkRemove" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeLinkRemove() @\
      subroutine mclass1##AttLinkRm##mclass2short(mthis1, mthis2, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass1), intent(inout) :: mthis1 @\
      type(mclass2), intent(in)  :: mthis2 @\
      integer, intent(out), optional  :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Unattaches two Attribute hierarchies @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis1] @\
!      An {\tt mclass1} object. @\
!     \item [mthis2] @\
!      An {\tt mclass2} object. @\
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc                           ! Error status @\
      type(ESMF_Logical) :: linkChange @\
 @\
      ! Initialize return code; assume failure until success is certain @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(mclass1##GetInit,mthis1,rc) @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(mclass2##GetInit,mthis2,rc) @\
 @\
      linkChange = ESMF_FALSE @\
      call c_ESMC_AttributeLinkRemove(mthisfield1, mthisfield2, linkChange, localrc) @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass1##AttLinkRm##mclass2short @\

!-----------------------------------------------------------------------------

#define AttReadMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttRead" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeRead - Read an Attribute package @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeRead() @\
      subroutine mclass##AttRead(mthis, fileName, schemaFileName, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis @\
      character (len=*),   intent(in), optional :: fileName @\
      character (len=*),   intent(in), optional :: schemaFileName @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Read the Attribute package for the {\tt mthis}. @\
!     The Attribute package defines the associated Attributes. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!      An {\tt mclass} object. @\
!     \item [{[fileName]}] @\
!      The file name to read from. @\
!     \item [{[schemaFileName]}] @\
!      The name of the XSD file to validate fileName. @\
!     \item [{[rc]}]  @\
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      ! initialize fileName length to zero for non-existent name @\
      integer :: fileNameLen, schemaFileNameLen, localrc @\
 @\
      fileNameLen = 0 @\
      schemaFileNameLen = 0 @\
 @\
      ! Initialize return code; assume failure until success is certain @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
      localrc = ESMF_RC_NOT_IMPL @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      ! get length of given fileNames for C++ validation @\
      if (present(fileName)) then @\
        fileNameLen = len_trim(fileName) @\
      end if @\
 @\
      if (present(schemaFileName)) then @\
        schemaFileNameLen = len_trim(schemaFileName) @\
      end if @\
 @\
      ! invoke C to C++ entry point @\
      call c_ESMC_AttributeRead(mthisfield, fileNameLen, fileName, & @\
                                schemaFileNameLen, schemaFileName, localrc) @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttRead @\

!------------------------------------------------------------------------------

#define AttRemoveMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttRemove" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeRemove  - Remove an Attribute or Attribute Package @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeRemove() @\
      subroutine mclass##AttRemove(mthis, name, attpack, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in), optional :: name @\
      type(ESMF_Attribute), intent(in), optional :: attpack @\
      integer, intent(out), optional :: rc    @\
! @\
! !DESCRIPTION: @\
!     Removes an Attribute on the object. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to destroy. @\
!     \item [{[attpack]}] @\
!           An Attribute package handle containing identifying information. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      if (present(attpack) .and. .not.present(name)) then @\
        call c_ESMC_AttPackRemove(mthisfield, attpack, localrc) @\
      else if (present(attpack) .and. present(name)) then @\
        call c_ESMC_AttPackRemoveAttribute(mthisfield, name, attpack, localrc) @\
      else if (present(name)) then @\
        call c_ESMC_AttributeRemove(mthisfield, name, localrc) @\
      endif @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttRemove @\

!------------------------------------------------------------------------------

#define AttSetDoc() \
!BOPI @\
!EOPI @\

#define AttSetMacro(mtype, mtypekind, mclass, mthis, mthisfield) \
 @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttSet" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeSet - Set an Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeSet() @\
      subroutine mclass##AttSet##mtypekind(mthis, name, value, attpack, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in) :: name @\
      mtype(ESMF_KIND_##mtypekind), intent(in) :: value @\
      type(ESMF_Attribute), intent(in), optional :: attpack @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Attach an Attribute to the object. @\
!     The Attribute has a {\tt name} and a {\tt value}. @\
!  @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to add. @\
!     \item [value] @\
!           The integer value of the Attribute to add. @\
!     \item [{[attpack]}] @\
!           An Attribute package handle containing identifying information. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc  @\
      character(len=*), parameter :: fobject=#mthis @\
      integer :: count @\
      character (len=ESMF_MAXSTR) :: modName @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      count = 1 @\
 @\
      !!!! TODO: this can go away once modName is dynamically sized !!! @\
      if (len(name) > ESMF_MAXSTR) then @\
        call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & @\
          msg="len(name) cannot be larger than ESMF_MAXSTR for now", & @\
          ESMF_CONTEXT, rcToReturn=rc) @\
        return @\
      endif @\
      ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'@\
      if (AttributeInternalInfo(name, modName)) then @\
        call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & @\
          msg="Attribute names starting with 'ESMF:' are not allowed!", & @\
          ESMF_CONTEXT, rcToReturn=rc) @\
        return @\
      endif @\
 @\
      if (present(attpack)) then @\
        call c_ESMC_AttPackSetValue(mthisfield, name, & @\
          ESMF_TYPEKIND_##mtypekind, count, value, & @\
          attpack, localrc) @\
      else @\
        call c_ESMC_AttributeSetValue(mthisfield, name, & @\
          ESMF_TYPEKIND_##mtypekind, count, value, localrc) @\
      endif @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttSet##mtypekind @\
 @\
!------------------------------------------------------------------------------ @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttSet1D" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeSet - Set an Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeSet() @\
      subroutine mclass##AttSet1D##mtypekind(mthis, name, valueList, & @\
        attpack, itemCount, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in) :: name @\
      mtype(ESMF_KIND_##mtypekind), dimension(:), intent(in) :: valueList @\
      type(ESMF_Attribute), intent(in), optional :: attpack @\
      integer, intent(in), optional :: itemCount    @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Attach an Attribute to the object. @\
!     The Attribute has a {\tt name} and a {\tt valueList}. @\
!     The number of integer items in the {\tt valueList} is @\
!     given by {\tt itemCount}. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to add. @\
!     \item [valueList] @\
!           The integer values of the Attribute to add. @\
!     \item [{[attpack]}] @\
!           An Attribute package handle containing identifying information. @\
!     \item [{[itemCount]}] @\
!           The number of integers in the {\tt valueList}. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
@\
      integer :: localrc, litemCount @\
      character(len=*), parameter :: fobject=#mthis @\
      character (len=ESMF_MAXSTR) :: modName @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      !!!! TODO: this can go away once modName is dynamically sized !!! @\
      if (len(name) > ESMF_MAXSTR) then @\
        call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & @\
          msg="len(name) cannot be larger than ESMF_MAXSTR for now", & @\
          ESMF_CONTEXT, rcToReturn=rc) @\
        return @\
      endif @\
      ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'@\
      if (AttributeInternalInfo(name, modName)) then @\
        call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & @\
          msg="Attribute names starting with 'ESMF:' are not allowed!", & @\
          ESMF_CONTEXT, rcToReturn=rc) @\
        return @\
      endif @\
@\
      if (present(itemCount)) then @\
        if (itemCount > size(valueList)) then @\
          call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & @\
                              msg="itemCount cannot be larger than size(valueList)", & @\
                              ESMF_CONTEXT, rcToReturn=rc) @\
          return @\
        endif @\
      	litemCount = itemCount @\
      else @\
      	litemCount = size(valueList) @\
      end if @\
 @\
      if (litemCount .le. 0) then @\
        call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & @\
                              msg="valueList is too small", & @\
                              ESMF_CONTEXT, rcToReturn=rc) @\
        return @\
      endif @\
 @\
      if (present(attpack)) then @\
        call c_ESMC_AttPackSetValue(mthisfield, name, & @\
          ESMF_TYPEKIND_##mtypekind, litemCount, valueList, & @\
          attpack, localrc) @\
      else @\
        call c_ESMC_AttributeSetValue(mthisfield, name, & @\
          ESMF_TYPEKIND_##mtypekind, litemCount, valueList, localrc) @\
      endif @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttSet1D##mtypekind @\

!------------------------------------------------------------------------------

#define AttSetLogicalMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttSetLgcl" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeSet() @\
      subroutine mclass##AttSetLgcl(mthis, name, value, attpack, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in) :: name @\
      logical, intent(in) :: value @\
      type(ESMF_Attribute), intent(in), optional :: attpack @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Attach a logical Attribute to the object. @\
!     The Attribute has a {\tt name} and a {\tt value}. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to add. @\
!     \item [value] @\
!           The logical true/false value of the Attribute to add. @\
!     \item [{[attpack]}] @\
!           An Attribute package handle containing identifying information. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_Logical) :: localvalue @\
      integer :: count @\
      character (len=ESMF_MAXSTR) :: modName @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      !!!! TODO: this can go away once modName is dynamically sized !!! @\
      if (len(name) > ESMF_MAXSTR) then @\
        call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & @\
          msg="len(name) cannot be larger than ESMF_MAXSTR for now", & @\
          ESMF_CONTEXT, rcToReturn=rc) @\
        return @\
      endif @\
      ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'@\
      if (AttributeInternalInfo(name, modName)) then @\
        call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & @\
          msg="Attribute names starting with 'ESMF:' are not allowed!", & @\
          ESMF_CONTEXT, rcToReturn=rc) @\
        return @\
      endif @\
 @\
      count = 1 @\
 @\
      localvalue = value @\
      if (present(attpack)) then @\
        call c_ESMC_AttPackSetValue(mthisfield, name, & @\
          ESMF_TYPEKIND_LOGICAL, count, localvalue, & @\
          attpack, localrc) @\
      else @\
        call c_ESMC_AttributeSetValue(mthisfield, name, & @\
          ESMF_TYPEKIND_LOGICAL, count, localvalue, localrc) @\
      endif @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttSetLgcl @\
 @\
!------------------------------------------------------------------------------ @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttSetLgclList" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeSet() @\
      subroutine mclass##AttSetLgclList(mthis, name, valueList, attpack, & @\
        itemCount, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in) :: name @\
      logical, dimension(:), intent(in) :: valueList @\
      type(ESMF_Attribute), intent(in), optional :: attpack @\
      integer, intent(in), optional :: itemCount    @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Attach a logical list Attribute to the object. @\
!     The Attribute has a {\tt name} and a {\tt valueList}. @\
!     The number of logical items in the {\tt valueList} is @\
!     given by {\tt itemCount}. @\
!  @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to add. @\
!     \item [value] @\
!           The logical true/false values of the Attribute. @\
!     \item [{[attpack]}] @\
!           An Attribute package handle containing identifying information. @\
!     \item [{[itemCount]}] @\
!           The number of logicals in the {\tt valueList}. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, litemCount @\
      character(len=*), parameter :: fobject=#mthis @\
      character (len=ESMF_MAXSTR) :: modName @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      !!!! TODO: this can go away once modName is dynamically sized !!! @\
      if (len(name) > ESMF_MAXSTR) then @\
        call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & @\
          msg="len(name) cannot be larger than ESMF_MAXSTR for now", & @\
          ESMF_CONTEXT, rcToReturn=rc) @\
        return @\
      endif @\
      ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'@\
      if (AttributeInternalInfo(name, modName)) then @\
        call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & @\
          msg="Attribute names starting with 'ESMF:' are not allowed!", & @\
          ESMF_CONTEXT, rcToReturn=rc) @\
        return @\
      endif @\
@\
      if (present(itemCount)) then @\
        if (itemCount > size(valueList)) then @\
          call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & @\
                              msg="itemCount cannot be larger than size(valueList)", & @\
                              ESMF_CONTEXT, rcToReturn=rc) @\
          return @\
        endif @\
      	litemCount = itemCount @\
      else @\
      	litemCount = size(valueList) @\
      end if @\
 @\
      if (litemCount .le. 0) then @\
        call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & @\
                              msg="valueList is too small", & @\
                              ESMF_CONTEXT, rcToReturn=rc) @\
        return @\
      endif @\
 @\
      if (present(attpack)) then @\
        call c_ESMC_AttPackSetValue(mthisfield, name, & @\
          ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & @\
          attpack, localrc) @\
      else @\
        call c_ESMC_AttributeSetValue(mthisfield, name, & @\
          ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) @\
      endif @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttSetLgclList @\

!------------------------------------------------------------------------------

#define AttSetCharacterMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttSetChar" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeSet() @\
      subroutine mclass##AttSetChar(mthis, name, value, attpack, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in) :: name @\
      character (len = *), intent(in) :: value @\
      type(ESMF_Attribute), intent(in), optional :: attpack @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Attach a character Attribute to the object. @\
!     The Attribute has a {\tt name} and a {\tt value}. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to add. @\
!     \item [value] @\
!           The character value of the Attribute to add. @\
!     \item [{[attpack]}] @\
!           An Attribute package handle containing identifying information. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc @\
      character(len=*), parameter :: fobject=#mthis @\
      integer, dimension(1) :: lens @\
      integer :: count @\
      character (len=ESMF_MAXSTR) :: modName @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      !!!! TODO: this can go away once modName is dynamically sized !!! @\
      if (len(name) > ESMF_MAXSTR) then @\
        call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & @\
          msg="len(name) cannot be larger than ESMF_MAXSTR for now", & @\
          ESMF_CONTEXT, rcToReturn=rc) @\
        return @\
      endif @\
      ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'@\
      if (AttributeInternalInfo(name, modName)) then @\
        call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & @\
          msg="Attribute names starting with 'ESMF:' are not allowed!", & @\
          ESMF_CONTEXT, rcToReturn=rc) @\
        return @\
      endif @\
@\
      lens(1) = len_trim(value) @\
      count = 1 @\
 @\
      if (present(attpack)) then @\
        call c_ESMC_AttPackSetCharList(mthisfield, name, ESMF_TYPEKIND_CHARACTER, & @\
          count, value, lens, attpack, localrc) @\
      else @\
        call c_ESMC_AttributeSetCharList(mthisfield, name, ESMF_TYPEKIND_CHARACTER, & @\
          count, value, lens, localrc) @\
      endif @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttSetChar @\
 @\
!------------------------------------------------------------------------------ @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttSetCharList" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute list @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeSet() @\
      subroutine mclass##AttSetCharList(mthis, name, valueList, & @\
        attpack, itemCount, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis @\
      character(len=*), intent(in) :: name @\
      character (len = *), dimension(:), intent(in) :: valueList @\
      type(ESMF_Attribute), intent(in), optional :: attpack @\
      integer, intent(in), optional :: itemCount @\
      integer, intent(out), optional :: rc @\
 @\
! @\
! !DESCRIPTION: @\
!     Attach a character Attribute to the object. @\
!     The Attribute has a {\tt name} and a {\tt value}. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to add. @\
!     \item [value] @\
!           The character value of the Attribute to add. @\
!     \item [{[attpack]}] @\
!           An Attribute package handle containing identifying information. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, i, j, litemCount @\
      character(len=*), parameter :: fobject=#mthis @\
      integer, dimension(size(valueList)) :: lens @\
      character(len=(size(valueList)*len(valueList))) :: valueString @\
      character (len=ESMF_MAXSTR) :: modName @\
@\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      !!!! TODO: this can go away once modName is dynamically sized !!! @\
      if (len(name) > ESMF_MAXSTR) then @\
        call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & @\
          msg="len(name) cannot be larger than ESMF_MAXSTR for now", & @\
          ESMF_CONTEXT, rcToReturn=rc) @\
        return @\
      endif @\
      ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'@\
      if (AttributeInternalInfo(name, modName)) then @\
        call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & @\
          msg="Attribute names starting with 'ESMF:' are not allowed!", & @\
          ESMF_CONTEXT, rcToReturn=rc) @\
        return @\
      endif @\
@\
      if (present(itemCount)) then @\
        if (itemCount > size(valueList)) then @\
          call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & @\
                              msg="itemCount cannot be larger than size(valueList)", & @\
                              ESMF_CONTEXT, rcToReturn=rc) @\
          return @\
        endif @\
        litemCount = itemCount @\
      else @\
        litemCount = size(valueList) @\
      end if @\
 @\
      if (litemCount .le. 0) then @\
        call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & @\
                              msg="valueList is too small", & @\
                              ESMF_CONTEXT, rcToReturn=rc) @\
        return @\
      endif @\
 @\
      j = 1 @\
      do  i=1,litemCount @\
        lens(i) = len_trim(valueList(i)) @\
        valueString(j:(j+lens(i)-1)) = valueList(i) @\
        j = j + lens(i) @\
      enddo @\
 @\
      if (present(attpack)) then @\
        call c_ESMC_AttPackSetCharList(mthisfield, name, ESMF_TYPEKIND_CHARACTER, & @\
          litemCount, valueString, lens, attpack, localrc) @\
      else @\
        call c_ESMC_AttributeSetCharList(mthisfield, name, ESMF_TYPEKIND_CHARACTER, & @\
          litemCount, valueString, lens, localrc) @\
      endif @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttSetCharList @\

#define AttSetCharacterBMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttSetChar" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeSet() @\
      subroutine mclass##AttSetChar(mthis, name, value, inputList, & @\
        attpack, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis @\
      character (len = *), intent(in) :: name @\
      character (len = *), intent(in) :: value @\
      character (len = *), intent(in), optional :: inputList(:) @\
      type(ESMF_Attribute), intent(in), optional :: attpack @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Attach a character Attribute to the object. @\
!     The Attribute has a {\tt name} and a {\tt value}. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to add. @\
!     \item [value] @\
!           The character value of the Attribute to add. @\
!     \item [{[inputList]}] @\
!           A list of the input parameters required to set internal info. @\
!     \item [{[attpack]}] @\
!           An Attribute package handle containing identifying information. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, memstat @\
      character(len=*), parameter :: fobject=#mthis @\
      integer, allocatable :: lens(:) @\
      integer :: litemCount, i, j @\
      character (len=ESMF_MAXSTR) :: modName @\
      character, allocatable :: valueString(:) @\
      integer :: lens_size, valuestring_size, tag_size @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
      tag_size = 6 ! ':Input:' is 7 characters long @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      !!!! TODO: this can go away once modName is dynamically sized !!! @\
      if (len(name) > ESMF_MAXSTR) then @\
        call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & @\
          msg="len(name) cannot be larger than ESMF_MAXSTR for now", & @\
          ESMF_CONTEXT, rcToReturn=rc) @\
        return @\
      endif @\
      ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'@\
      if (AttributeInternalInfo(name, modName)) then @\
        call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & @\
          msg="Attribute names starting with 'ESMF:' are not allowed!", & @\
          ESMF_CONTEXT, rcToReturn=rc) @\
        return @\
      endif @\
@\
      ! allocate arrays @\
      if (present (inputList)) then @\
        valuestring_size = len(value) @\
        lens_size = 1 @\
        do i=1,size(inputList) @\
          if (len_trim(inputList(i)) > 0) then @\
            valuestring_size = valuestring_size + len_trim(inputList(i)) + tag_size @\
            lens_size = lens_size + 1 @\
          endif @\
        enddo @\
        ! set the size of the new valueList @\
        litemCount =  lens_size @\
      else @\
        valuestring_size = len(value) @\
        ! this is required for bluefire, it does not function well with 0 size allocations @\
        if (len(value) == 0) then @\
          valuestring_size = 1 @\
        endif @\
        lens_size = 1 @\
        ! set the size of the new valueList @\
        litemCount = 1 @\
      end if @\
 @\
      allocate (lens (lens_size), stat = memstat) @\
      lens = 0 @\
      if (ESMF_LogFoundAllocError(memstat, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT,  rcToReturn=rc)) return @\
      allocate (valueString (valuestring_size), stat = memstat) @\
      valueString = "" @\
      if (ESMF_LogFoundAllocError(memstat, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT,  rcToReturn=rc)) then @\
        deallocate(lens) @\
        return @\
      endif @\
 @\
      ! this is required for bluefire, this block of code will not work with empty @\
      ! attribute values, but that case should not happen with inputLists.. @\
      if (len_trim(value) > 0) then @\
        ! also for internal Attributes, must append inputList to the Attribute value @\
        lens(1) = len_trim(value) @\
        valueString(1:lens(1)) = ESMF_String2Array(trim(value)) @\
      endif @\
      if (present(inputList)) then @\
        j = lens(1) + 1 @\
        do i=2,litemCount @\
          if (len_trim(inputList(i-1)) > 0) then @\
            ! put inputList values into valueString @\
            lens(i) = len_trim(inputList(i-1))+tag_size @\
            valueString(j:(j+tag_size-1)) = ESMF_String2Array("Input:") @\
            j = j + tag_size @\
            valueString(j:(j+lens(i)-tag_size-1)) =  & @\
              ESMF_String2Array(trim(inputList(i-1))) @\
            j = j + lens(i) @\
          endif @\
        enddo @\
      endif @\
 @\
 @\
      if (present(attpack)) then @\
        call c_ESMC_AttPackSetCharList(mthisfield, name, ESMF_TYPEKIND_CHARACTER, & @\
          litemCount, valueString, lens, attpack, localrc) @\
      else @\
        call c_ESMC_AttributeSetCharList(mthisfield, name, ESMF_TYPEKIND_CHARACTER, & @\
          litemCount, valueString, lens, localrc) @\
      endif @\
 @\
      ! deallocate @\
      deallocate(lens) @\
      deallocate(valueString) @\
 @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttSetChar @\
 @\
!------------------------------------------------------------------------------ @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttSetCharList" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute list @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeSet() @\
      subroutine mclass##AttSetCharList(mthis, name, valueList, & @\
        attpack, itemCount, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis @\
      character(len=*), intent(in) :: name @\
      character (len = *), dimension(:), intent(in) :: valueList @\
      type(ESMF_Attribute), intent(in), optional :: attpack @\
      integer, intent(in), optional :: itemCount @\
      integer, intent(out), optional :: rc @\
 @\
! @\
! !DESCRIPTION: @\
!     Attach a character Attribute to the object. @\
!     The Attribute has a {\tt name} and a {\tt value}. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to add. @\
!     \item [value] @\
!           The character value of the Attribute to add. @\
!     \item [{[attpack]}] @\
!           An Attribute package handle containing identifying information. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, i, j, litemCount @\
      character(len=*), parameter :: fobject=#mthis @\
      integer, dimension(size(valueList)) :: lens @\
      character(len=(size(valueList)*len(valueList))) :: valueString @\
      character (len=ESMF_MAXSTR) :: modName @\
@\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      !!!! TODO: this can go away once modName is dynamically sized !!! @\
      if (len(name) > ESMF_MAXSTR) then @\
        call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & @\
          msg="len(name) cannot be larger than ESMF_MAXSTR for now", & @\
          ESMF_CONTEXT, rcToReturn=rc) @\
        return @\
      endif @\
      ! If internal info is implied, bail out, cannot set Attribute starting with 'ESMF:'@\
      if (AttributeInternalInfo(name, modName)) then @\
        call ESMF_LogSetError(rcToCheck=ESMF_RC_NOT_VALID, & @\
          msg="Attribute names starting with 'ESMF:' are not allowed!", & @\
          ESMF_CONTEXT, rcToReturn=rc) @\
        return @\
      endif @\
@\
      if (present(itemCount)) then @\
        if (itemCount > size(valueList)) then @\
          call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & @\
                              msg="itemCount cannot be larger than size(valueList)", & @\
                              ESMF_CONTEXT, rcToReturn=rc) @\
          return @\
        endif @\
        litemCount = itemCount @\
      else @\
        litemCount = size(valueList) @\
      end if @\
 @\
      if (litemCount .le. 0) then @\
        call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_BAD, & @\
                              msg="valueList is too small", & @\
                              ESMF_CONTEXT, rcToReturn=rc) @\
        return @\
      endif @\
 @\
      j = 1 @\
      do  i=1,litemCount @\
        lens(i) = len_trim(valueList(i)) @\
        valueString(j:(j+lens(i)-1)) = valueList(i) @\
        j = j + lens(i) @\
      enddo @\
 @\
      if (present(attpack)) then @\
        call c_ESMC_AttPackSetCharList(mthisfield, name, ESMF_TYPEKIND_CHARACTER, & @\
          litemCount, valueString, lens, attpack, localrc) @\
      else @\
        call c_ESMC_AttributeSetCharList(mthisfield, name, ESMF_TYPEKIND_CHARACTER, & @\
          litemCount, valueString, lens, localrc) @\
      endif @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttSetCharList @\

!-----------------------------------------------------------------------------

#define AttUpdateMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttUpdate" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeUpdate - Update an Attribute hierarchy @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeUpdate() @\
      subroutine mclass##AttUpdate(mthis, vm, rootList, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis @\
      type(ESMF_VM), intent(in) :: vm @\
      integer, dimension(:), intent(in) :: rootList @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Update an Attribute hierarchy. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!      An {\tt mclass} object. @\
!     \item [vm] @\
!      The virtural machine over which this Attribute hierarchy  @\
!      should be updated. @\
!     \item [rootList] @\
!      The list of "root" PETs that are to be used to update. @\
!     \item [{[rc]}]  @\
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, count                           ! Error status @\
 @\
      ! Initialize return code; assume failure until success is certain @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      count = size(rootList) @\
      call c_ESMC_AttributeUpdate(mthisfield, vm, rootList, count, localrc) @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttUpdate @\

!-----------------------------------------------------------------------------

#define AttWriteMacro(mclass, mthis, mthisfield, mthisobj, mthistar) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttWrite" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeWrite - Write an Attribute package to file @\
 @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeWrite() @\
      subroutine mclass##AttWrite(mthis, convention, purpose, attwriteflag, rc) @\
 @\
! !ARGUMENTS: @\
      type(mclass), intent(in) :: mthis   @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Write the Attribute package for the {\tt state}. @\
!     The Attribute package defines the convention, purpose, and object type  @\
!     of the associated Attributes. @\
! @\
! This call is collective across the current VM. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [state] @\
!      An {\tt ESMF\_State} object. @\
!     \item [convention] @\
!      The convention of the Attribute package. @\
!     \item [purpose] @\
!      The purpose of the Attribute package. @\
!     \item [attwriteflag] @\
!      Flag to determine the format for writing the Attributes. @\
!     \item [{[rc]}]  @\
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc @\
      character(len=*), parameter :: fobject=#mthisobj @\
      character(len=*), parameter :: ftarobj=#mthistar @\
      type(ESMF_AttWriteFlag) :: writeflag @\
      type(ESMF_Logical) :: attpack @\
      type(ESMF_VM) :: vm @\
 @\
      ! Initialize return code; assume failure until success is certain @\
      attpack = ESMF_FALSE @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      if (present(convention).or.present(purpose)) then @\
        if (present(convention).and..not.present(purpose).or. & @\
            present(purpose).and..not.present(convention)) then @\
          call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_INCOMP, & @\
            msg="both convention and purpose must be present or not", & @\
            ESMF_CONTEXT, rcToReturn=rc) @\
          return @\
        endif @\
        attpack = ESMF_TRUE @\
      endif @\
 @\
      if (present(attwriteflag)) then @\
        writeflag = attwriteflag @\
      else @\
        writeflag = ESMF_ATTWRITE_TAB @\
      endif @\
 @\
      if (attpack == ESMF_TRUE) then @\
        if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then @\
          call c_ESMC_AttributeWriteTab(mthisfield, convention, & @\
            purpose, fobject, ftarobj, localrc) @\
        else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then @\
          call c_ESMC_AttributeWriteXML(mthisfield, convention, & @\
            purpose, fobject, ftarobj, localrc) @\
      	endif @\
      endif @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      call ESMF_VMGetCurrent(vm, rc=rc) @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
      call ESMF_VMBarrier(vm, rc=rc) @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttWrite @\

!-------------------------------------------------------------------------
!  CplComp
!-------------------------------------------------------------------------

AttPackGetMacro(ESMF_CplComp, comp, comp%compp%base)

AttAddPackStandardMacro(ESMF_CplComp, comp, comp%compp%base)
AttAddPackStandardNMacro(ESMF_CplComp, comp, comp%compp%base)
AttAddPackCustomMacro(ESMF_CplComp, comp, comp%compp%base)
AttAddPackCustomNMacro(ESMF_CplComp, comp, comp%compp%base)
AttAddPackCustomN1Macro(ESMF_CplComp, comp, comp%compp%base)
AttCopyMacro(ESMF_CplComp, ESMF_CplComp, comp1, comp2, comp1%compp%base, comp2%compp%base)

TypeKind3DeclarationMacro(AttGet, ESMF_CplComp, comp, comp%compp%base)
TypeKind3NoDocDeclarationMacro(AttGet1D, ESMF_CplComp, comp, comp%compp%base)
AttGetLogicalMacro(ESMF_CplComp, comp, comp%compp%base)
AttGetCharacterMacro(ESMF_CplComp, comp, comp%compp%base)

GetCountNameNumberMacro(ESMF_CplComp, comp, comp%compp%base)
AttGetAPinstNamesMacro(ESMF_CplComp, comp, comp%compp%base)

AttLinkCompMacro(ESMF_CplComp, ESMF_CplComp, CplComp, comp1, comp2, & @\
                comp1%compp%base, comp2%compp%base)
AttLinkCompMacro(ESMF_CplComp, ESMF_GridComp, GridComp, comp1, comp2,  & @\
                comp1%compp%base, comp2%compp%base)
AttLinkCompMacro(ESMF_CplComp, ESMF_SciComp, SciComp, comp1, comp2,  & @\
                comp1%compp%base, comp2%compp%base)
AttLinkCompMacro(ESMF_CplComp, ESMF_State, State, comp, state,  & @\
                comp%compp%base, state%statep%base)
AttLinkRemoveCompMacro(ESMF_CplComp, ESMF_CplComp, CplComp, comp1, comp2, & @\
                comp1%compp%base, comp2%compp%base)
AttLinkRemoveCompMacro(ESMF_CplComp, ESMF_GridComp, GridComp, comp1, comp2,  & @\
                comp1%compp%base, comp2%compp%base)
AttLinkRemoveCompMacro(ESMF_CplComp, ESMF_SciComp, SciComp, comp1, comp2,  & @\
                comp1%compp%base, comp2%compp%base)
AttLinkRemoveCompMacro(ESMF_CplComp, ESMF_State, State, comp, state,  & @\
                comp%compp%base, state%statep%base)

AttReadMacro(ESMF_CplComp, comp, comp%compp%base)

AttRemoveMacro(ESMF_CplComp, comp, comp%compp%base)

TypeKind3DeclarationMacro(AttSet, ESMF_CplComp, comp, comp%compp%base)
AttSetLogicalMacro(ESMF_CplComp, comp, comp%compp%base)
AttSetCharacterMacro(ESMF_CplComp, comp, comp%compp%base)

AttUpdateMacro(ESMF_CplComp, comp, comp%compp%base)
AttWriteMacro(ESMF_CplComp, comp, comp%compp%base, comp, field)

!-------------------------------------------------------------------------
!  GridComp
!-------------------------------------------------------------------------

AttPackGetMacro(ESMF_GridComp, comp, comp%compp%base)

AttAddPackStandardMacro(ESMF_GridComp, comp, comp%compp%base)
AttAddPackStandardNMacro(ESMF_GridComp, comp, comp%compp%base)
AttAddPackCustomMacro(ESMF_GridComp, comp, comp%compp%base)
AttAddPackCustomNMacro(ESMF_GridComp, comp, comp%compp%base)
AttAddPackCustomN1Macro(ESMF_GridComp, comp, comp%compp%base)
AttCopyMacro(ESMF_GridComp, ESMF_GridComp, comp1, comp2, comp1%compp%base, comp2%compp%base)
AttRemoveMacro(ESMF_GridComp, comp, comp%compp%base)

TypeKind3DeclarationMacro(AttGet, ESMF_GridComp, comp, comp%compp%base)
TypeKind3NoDocDeclarationMacro(AttGet1D, ESMF_GridComp, comp, comp%compp%base)
AttGetLogicalMacro(ESMF_GridComp, comp, comp%compp%base)
AttGetCharacterMacro(ESMF_GridComp, comp, comp%compp%base)

GetCountNameNumberMacro(ESMF_GridComp, comp, comp%compp%base)
AttGetAPinstNamesMacro(ESMF_GridComp, comp, comp%compp%base)

AttLinkCompMacro(ESMF_GridComp, ESMF_CplComp, CplComp, comp1, comp2, & @\
                comp1%compp%base, comp2%compp%base)
AttLinkCompMacro(ESMF_GridComp, ESMF_GridComp, GridComp, comp1, comp2, & @\
                comp1%compp%base, comp2%compp%base)
AttLinkCompMacro(ESMF_GridComp, ESMF_SciComp, SciComp, comp1, comp2, & @\
                comp1%compp%base, comp2%compp%base)
AttLinkCompMacro(ESMF_GridComp, ESMF_State, State, comp, state, & @\
                comp%compp%base, state%statep%base)
AttLinkRemoveCompMacro(ESMF_GridComp, ESMF_CplComp, CplComp, comp1, comp2, & @\
                comp1%compp%base, comp2%compp%base)
AttLinkRemoveCompMacro(ESMF_GridComp, ESMF_GridComp, GridComp, comp1, comp2, & @\
                comp1%compp%base, comp2%compp%base)
AttLinkRemoveCompMacro(ESMF_GridComp, ESMF_SciComp, SciComp, comp1, comp2, & @\
                comp1%compp%base, comp2%compp%base)
AttLinkRemoveCompMacro(ESMF_GridComp, ESMF_State, State, comp, state, & @\
                comp%compp%base, state%statep%base)

AttReadMacro(ESMF_GridComp, comp, comp%compp%base)

TypeKind3DeclarationMacro(AttSet, ESMF_GridComp, comp, comp%compp%base)
AttSetLogicalMacro(ESMF_GridComp, comp, comp%compp%base)
AttSetCharacterMacro(ESMF_GridComp, comp, comp%compp%base)

AttUpdateMacro(ESMF_GridComp, comp, comp%compp%base)
AttWriteMacro(ESMF_GridComp, comp, comp%compp%base, comp, field)

!-------------------------------------------------------------------------
!  SciComp
!-------------------------------------------------------------------------

AttPackGetMacro(ESMF_SciComp, comp, comp%compp%base)

AttAddPackStandardMacro(ESMF_SciComp, comp, comp%compp%base)
AttAddPackStandardNMacro(ESMF_SciComp, comp, comp%compp%base)
AttAddPackCustomMacro(ESMF_SciComp, comp, comp%compp%base)
AttAddPackCustomNMacro(ESMF_SciComp, comp, comp%compp%base)
AttAddPackCustomN1Macro(ESMF_SciComp, comp, comp%compp%base)
AttCopyMacro(ESMF_SciComp, ESMF_SciComp, comp1, comp2, comp1%compp%base, comp2%compp%base)
AttRemoveMacro(ESMF_SciComp, comp, comp%compp%base)

TypeKind3DeclarationMacro(AttGet, ESMF_SciComp, comp, comp%compp%base)
TypeKind3NoDocDeclarationMacro(AttGet1D, ESMF_SciComp, comp, comp%compp%base)
AttGetLogicalMacro(ESMF_SciComp, comp, comp%compp%base)
AttGetCharacterMacro(ESMF_SciComp, comp, comp%compp%base)

GetCountNameNumberMacro(ESMF_SciComp, comp, comp%compp%base)
AttGetAPinstNamesMacro(ESMF_SciComp, comp, comp%compp%base)

AttLinkCompMacro(ESMF_SciComp, ESMF_CplComp, CplComp, comp1, comp2, & @\
                comp1%compp%base, comp2%compp%base)
AttLinkCompMacro(ESMF_SciComp, ESMF_GridComp, GridComp, comp1, comp2, & @\
                comp1%compp%base, comp2%compp%base)
AttLinkCompMacro(ESMF_SciComp, ESMF_SciComp, SciComp, comp1, comp2, & @\
                comp1%compp%base, comp2%compp%base)
AttLinkCompMacro(ESMF_SciComp, ESMF_State, State, comp, state, & @\
                comp%compp%base, state%statep%base)
AttLinkRemoveCompMacro(ESMF_SciComp, ESMF_CplComp, CplComp, comp1, comp2, & @\
                comp1%compp%base, comp2%compp%base)
AttLinkRemoveCompMacro(ESMF_SciComp, ESMF_GridComp, GridComp, comp1, comp2, & @\
                comp1%compp%base, comp2%compp%base)
AttLinkRemoveCompMacro(ESMF_SciComp, ESMF_SciComp, SciComp, comp1, comp2, & @\
                comp1%compp%base, comp2%compp%base)
AttLinkRemoveCompMacro(ESMF_SciComp, ESMF_State, State, comp, state, & @\
                comp%compp%base, state%statep%base)

AttReadMacro(ESMF_SciComp, comp, comp%compp%base)

TypeKind3DeclarationMacro(AttSet, ESMF_SciComp, comp, comp%compp%base)
AttSetLogicalMacro(ESMF_SciComp, comp, comp%compp%base)
AttSetCharacterMacro(ESMF_SciComp, comp, comp%compp%base)

AttUpdateMacro(ESMF_SciComp, comp, comp%compp%base)
AttWriteMacro(ESMF_SciComp, comp, comp%compp%base, comp, field)

!-------------------------------------------------------------------------
!  STATE
!-------------------------------------------------------------------------

AttPackGetMacro(ESMF_State, state, state%statep%base)

AttAddPackStandardMacro(ESMF_State, state, state%statep%base)
AttAddPackCustomMacro(ESMF_State, state, state%statep%base)
AttAddPackCustomNMacro(ESMF_State, state, state%statep%base)
AttAddPackCustomN1Macro(ESMF_State, state, state%statep%base)
AttCopyMacro(ESMF_State, ESMF_State, state1, state2, state1%statep%base, state2%statep%base)

TypeKind3DeclarationMacro(AttGet, ESMF_State, state, state%statep%base)
TypeKind3NoDocDeclarationMacro(AttGet1D, ESMF_State, state, state%statep%base)
AttGetLogicalMacro(ESMF_State, state, state%statep%base)
AttGetCharacterMacro(ESMF_State, state, state%statep%base)

GetCountNameNumberMacro(ESMF_State, state, state%statep%base)

AttLinkStateMacro(ESMF_Array, Array, state, array, state%statep%base, & @\
                          array, statep%st, array)
AttLinkStateMacro(ESMF_ArrayBundle, ArrayBundle, state, arraybundle, state%statep%base, & @\
                          arraybundle, statep%st, array)
AttLinkStateMacro(ESMF_Field, Field, state, field, state%statep%base, & @\
                          field%ftypep%base, statep%st, field)
AttLinkStateMacro(ESMF_FieldBundle, FieldBundle, state, fieldbundle, state%statep%base, & @\
                          fieldbundle%this%base, statep%st, field)
AttLinkStateMacro(ESMF_State, State, state1, state2, state1%statep%base, & @\
                          state2%statep%base, statep%st, field)
AttLinkRemoveMacro(ESMF_State, ESMF_Array, Array, state, array, & @\
                state%statep%base, array)
AttLinkRemoveMacro(ESMF_State, ESMF_ArrayBundle, ArrayBundle, state, arraybundle, & @\
                state%statep%base, arraybundle)
AttLinkRemoveMacro(ESMF_State, ESMF_Field, Field, state, field, & @\
                state%statep%base, field%ftypep%base)
AttLinkRemoveMacro(ESMF_State, ESMF_FieldBundle, FieldBundle, state, fieldbundle, & @\
                state%statep%base, fieldbundle%this%base)
AttLinkRemoveMacro(ESMF_State, ESMF_State, State, state1, state2, & @\
                state1%statep%base, state2%statep%base)

AttRemoveMacro(ESMF_State, state, state%statep%base)

AttReadMacro(ESMF_State, state, state%statep%base)

TypeKind3DeclarationMacro(AttSet, ESMF_State, state, state%statep%base)
AttSetLogicalMacro(ESMF_State, state, state%statep%base)
AttSetCharacterMacro(ESMF_State, state, state%statep%base)

AttUpdateMacro(ESMF_State, state, state%statep%base)
AttWriteMacro(ESMF_State, state, state%statep%base, state, field)

!-------------------------------------------------------------------------
!  FIELDBUNDLE
!-------------------------------------------------------------------------

AttPackGetMacro(ESMF_FieldBundle, fieldbundle, fieldbundle%this%base)

AttAddPackCustomMacro(ESMF_FieldBundle, fieldbundle, fieldbundle%this%base)
AttAddPackCustomNMacro(ESMF_FieldBundle, fieldbundle, fieldbundle%this%base)
AttAddPackCustomN1Macro(ESMF_FieldBundle, fieldbundle, fieldbundle%this%base)

TypeKind3DeclarationMacro(AttGet, ESMF_FieldBundle, fieldbundle, fieldbundle%this%base)
TypeKind3NoDocDeclarationMacro(AttGet1D, ESMF_FieldBundle, fieldbundle, fieldbundle%this%base)
AttGetLogicalMacro(ESMF_FieldBundle, fieldbundle, fieldbundle%this%base)
AttGetCharacterMacro(ESMF_FieldBundle, fieldbundle, fieldbundle%this%base)

GetCountNameNumberMacro(ESMF_FieldBundle, fieldbundle, fieldbundle%this%base)

AttLinkMacro(ESMF_FieldBundle, ESMF_Field, Field, fieldbundle, field, & @\
                fieldbundle%this%base, field%ftypep%base)
AttLinkMacro(ESMF_FieldBundle, ESMF_Grid, Grid, fieldbundle, grid, & @\
                fieldbundle%this%base, grid)
AttLinkRemoveMacro(ESMF_FieldBundle, ESMF_Field, Field, fieldbundle, field, & @\
                fieldbundle%this%base, field%ftypep%base)
AttLinkRemoveMacro(ESMF_FieldBundle, ESMF_Grid, Grid, fieldbundle, grid, & @\
                fieldbundle%this%base, grid)

AttReadMacro(ESMF_FieldBundle, fieldbundle, fieldbundle%this%base)

AttRemoveMacro(ESMF_FieldBundle, fieldbundle, fieldbundle%this%base)

TypeKind3DeclarationMacro(AttSet, ESMF_FieldBundle, fieldbundle, fieldbundle%this%base)
AttSetLogicalMacro(ESMF_FieldBundle, fieldbundle, fieldbundle%this%base)
AttSetCharacterMacro(ESMF_FieldBundle, fieldbundle, fieldbundle%this%base)

AttUpdateMacro(ESMF_FieldBundle, fieldbundle, fieldbundle%this%base)
AttWriteMacro(ESMF_FieldBundle, fieldbundle, fieldbundle%this%base, fieldbundle, field)

!-------------------------------------------------------------------------
!  FIELD
!-------------------------------------------------------------------------

AttPackGetMacro(ESMF_Field, field, field%ftypep%base)

AttAddPackStandardMacro(ESMF_Field, field, field%ftypep%base)
AttAddPackCustomMacro(ESMF_Field, field, field%ftypep%base)
AttAddPackCustomNMacro(ESMF_Field, field, field%ftypep%base)
AttAddPackCustomN1Macro(ESMF_Field, field, field%ftypep%base)

TypeKind3DeclarationMacro(AttGet, ESMF_Field, field, field%ftypep%base)
TypeKind3NoDocDeclarationMacro(AttGet1D, ESMF_Field, field, field%ftypep%base)
AttGetLogicalMacro(ESMF_Field, field, field%ftypep%base)
AttGetCharacterMacro(ESMF_Field, field, field%ftypep%base)

GetCountNameNumberMacro(ESMF_Field, field, field%ftypep%base)

AttLinkMacro(ESMF_Field, ESMF_Grid, Grid, field, grid, & @\
                field%ftypep%base, grid)
AttLinkRemoveMacro(ESMF_Field, ESMF_Grid, Grid, field, grid, & @\
                field%ftypep%base, grid)

AttReadMacro(ESMF_Field, field, field%ftypep%base)

AttRemoveMacro(ESMF_Field, field, field%ftypep%base)

TypeKind3DeclarationMacro(AttSet, ESMF_Field, field, field%ftypep%base)
AttSetLogicalMacro(ESMF_Field, field, field%ftypep%base)
AttSetCharacterMacro(ESMF_Field, field, field%ftypep%base)

AttUpdateMacro(ESMF_Field, field, field%ftypep%base)
AttWriteMacro(ESMF_Field, field, field%ftypep%base, field, field)

!-------------------------------------------------------------------------
!  ARRAYBUNDLE
!-------------------------------------------------------------------------

AttPackGetMacro(ESMF_ArrayBundle, arraybundle, arraybundle)

AttAddPackCustomMacro(ESMF_ArrayBundle, arraybundle, arraybundle)
AttAddPackCustomNMacro(ESMF_ArrayBundle, arraybundle, arraybundle)
AttAddPackCustomN1Macro(ESMF_ArrayBundle, arraybundle, arraybundle)
AttAddPackStandardMacro(ESMF_ArrayBundle, arraybundle, arraybundle)
AttRemoveMacro(ESMF_ArrayBundle, arraybundle, arraybundle)

TypeKind3DeclarationMacro(AttGet, ESMF_ArrayBundle, arraybundle, arraybundle)
TypeKind3NoDocDeclarationMacro(AttGet1D, ESMF_ArrayBundle, arraybundle, arraybundle)
AttGetLogicalMacro(ESMF_ArrayBundle, arraybundle, arraybundle)
AttGetCharacterMacro(ESMF_ArrayBundle, arraybundle, arraybundle)

GetCountNameNumberMacro(ESMF_ArrayBundle, arraybundle, arraybundle)

AttLinkMacro(ESMF_ArrayBundle, ESMF_Array, Array, arraybundle, array, & @\
                arraybundle, array)
AttLinkRemoveMacro(ESMF_ArrayBundle, ESMF_Array, Array, arraybundle, array, & @\
                arraybundle, array)

TypeKind3DeclarationMacro(AttSet, ESMF_ArrayBundle, arraybundle, arraybundle)
AttSetLogicalMacro(ESMF_ArrayBundle, arraybundle, arraybundle)
AttSetCharacterMacro(ESMF_ArrayBundle, arraybundle, arraybundle)

AttUpdateMacro(ESMF_ArrayBundle, arraybundle, arraybundle)
AttWriteMacro(ESMF_ArrayBundle, arraybundle, arraybundle, arraybundle, array)

!-------------------------------------------------------------------------
!  ARRAY
!-------------------------------------------------------------------------

AttPackGetMacro(ESMF_Array, array, array)

AttAddPackCustomMacro(ESMF_Array, array, array)
AttAddPackCustomNMacro(ESMF_Array, array, array)
AttAddPackCustomN1Macro(ESMF_Array, array, array)
AttAddPackStandardMacro(ESMF_Array, array, array)
AttRemoveMacro(ESMF_Array, array, array)

TypeKind3DeclarationMacro(AttGet, ESMF_Array, array, array)
TypeKind3NoDocDeclarationMacro(AttGet1D, ESMF_Array, array, array)
AttGetLogicalMacro(ESMF_Array, array, array)
AttGetCharacterMacro(ESMF_Array, array, array)

GetCountNameNumberMacro(ESMF_Array, array, array)

TypeKind3DeclarationMacro(AttSet, ESMF_Array, array, array)
AttSetLogicalMacro(ESMF_Array, array, array)
AttSetCharacterMacro(ESMF_Array, array, array)

AttUpdateMacro(ESMF_Array, array, array)
AttWriteMacro(ESMF_Array, array, array, array, array)

!-------------------------------------------------------------------------
!  GRID
!-------------------------------------------------------------------------

AttPackGetMacro(ESMF_Grid, grid, grid)

AttAddPackStandardMacro(ESMF_Grid, grid, grid)
AttAddPackCustomMacro(ESMF_Grid, grid, grid)
AttAddPackCustomNMacro(ESMF_Grid, grid, grid)
AttAddPackCustomN1Macro(ESMF_Grid, grid, grid)

^ifndef ESMF_NO_INTEGER_1_BYTE
funcname##Macro(integer, I1, ESMF_Grid, grid, grid)
^endif
^ifndef ESMF_NO_INTEGER_2_BYTE
funcname##Macro(integer, I2, ESMF_Grid, grid, grid)
^endif
AttGetBMacro(integer, I4, ESMF_Grid, grid, grid)
AttGet1DBMacro(integer, I4, ESMF_Grid, grid, grid)
AttGetMacro(integer, I8, ESMF_Grid, grid, grid)
AttGet1DMacro(integer, I8, ESMF_Grid, grid, grid)
AttGetMacro(real, R4, ESMF_Grid, grid, grid)
AttGet1DBMacro(real, R4, ESMF_Grid, grid, grid)
AttGetMacro(real, R8, ESMF_Grid, grid, grid)
AttGet1DBMacro(real, R8, ESMF_Grid, grid, grid)
AttGetLogicalBMacro(ESMF_Grid, grid, grid)
AttGetCharacterBMacro(ESMF_Grid, grid, grid)

GetCountNameNumberMacro(ESMF_Grid, grid, grid)

AttReadMacro(ESMF_Grid, grid, grid)

AttRemoveMacro(ESMF_Grid, grid, grid)

TypeKind3DeclarationMacro(AttSet, ESMF_Grid, grid, grid)
AttSetLogicalMacro(ESMF_Grid, grid, grid)
AttSetCharacterBMacro(ESMF_Grid, grid, grid)

AttWriteMacro(ESMF_Grid, grid, grid, grid, grid)

!-------------------------------------------------------------------------
!  DISTGRID
!-------------------------------------------------------------------------

AttPackGetMacro(ESMF_DistGrid, distgrid, distgrid)

AttAddPackCustomMacro(ESMF_DistGrid, distgrid, distgrid)
AttAddPackCustomNMacro(ESMF_DistGrid, distgrid, distgrid)
AttAddPackCustomN1Macro(ESMF_DistGrid, distgrid, distgrid)

TypeKind3DeclarationMacro(AttGet, ESMF_DistGrid, distgrid, distgrid)
TypeKind3NoDocDeclarationMacro(AttGet1D, ESMF_DistGrid, distgrid, distgrid)
AttGetLogicalMacro(ESMF_DistGrid, distgrid, distgrid)
AttGetCharacterMacro(ESMF_DistGrid, distgrid, distgrid)

GetCountNameNumberMacro(ESMF_DistGrid, distgrid, distgrid)

AttRemoveMacro(ESMF_DistGrid, distgrid, distgrid)

TypeKind3DeclarationMacro(AttSet, ESMF_DistGrid, distgrid, distgrid)
AttSetLogicalMacro(ESMF_DistGrid, distgrid, distgrid)
AttSetCharacterMacro(ESMF_DistGrid, distgrid, distgrid)

!------------------------------------------------------------------------------

end module ESMF_AttributeMod
