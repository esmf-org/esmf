! $Id$
!
! Earth System Modeling Framework
! Copyright (c) 2002-2025, University Corporation for Atmospheric Research,
! Massachusetts Institute of Technology, Geophysical Fluid Dynamics
! Laboratory, University of Michigan, National Centers for Environmental
! Prediction, Los Alamos National Laboratory, Argonne National Laboratory,
! NASA Goddard Space Flight Center.
! Licensed under the University of Illinois-NCSA License.
!
!==============================================================================
^define ESMF_FILENAME "ESMF_FieldCreate.F90"
!==============================================================================
!
! ESMF FieldCreate module
module ESMF_FieldCreateMod
!
!==============================================================================
!
! This file contains the FieldCreate() methods.
!
!------------------------------------------------------------------------------
! INCLUDES
! < ignore blank lines below.  they are created by the files which
!   define various macros. >
^include "ESMF.h"
#include "ESMF_TypeKindRankMacros.hcppF90"

!------------------------------------------------------------------------------
! !USES:
  use ESMF_UtilTypesMod
  use ESMF_BaseMod
  use ESMF_InitMacrosMod
  use ESMF_LogErrMod
  use ESMF_ArraySpecMod
  use ESMF_LocalArrayMod
  use ESMF_DELayoutMod
  use ESMF_StaggerLocMod
  use ESMF_GridMod
  use ESMF_XGridMod
  use ESMF_XGridCreateMod
  use ESMF_XGridGetMod
  use ESMF_XGridGeomBaseMod
  use ESMF_DistGridMod
  use ESMF_MeshMod
  use ESMF_LocStreamMod
  use ESMF_GeomMod
  use ESMF_ArrayMod
  use ESMF_ArrayGetMod
  use ESMF_ArrayCreateMod
  use ESMF_VMMod

  use ESMF_FieldMod
  use ESMF_FieldGetMod
  use ESMF_FieldEmptyMod

  implicit none

!------------------------------------------------------------------------------
! !PRIVATE TYPES:
  private

!------------------------------------------------------------------------------
! !PUBLIC MEMBER FUNCTIONS:

  public operator(==)
  public operator(/=)

  public ESMF_FieldCopy
  public ESMF_FieldCreate
  public ESMF_FieldDestroy            ! Destroy a Field
  public ESMF_FieldDestruct           ! For internal ESMF use only


!------------------------------------------------------------------------------
! The following line turns the CVS identifier string into a printable variable.
  character(*), parameter, private :: version = &
    '$Id$'

!==============================================================================
!
! INTERFACE BLOCKS
!
!==============================================================================


! -------------------------- ESMF-public method -------------------------------
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_FieldCreate - Create a new Field with data
!
! !INTERFACE:
  interface ESMF_FieldCreate

! !PRIVATE MEMBER FUNCTIONS:
!

    module procedure ESMF_FieldCreateGBTKR
    module procedure ESMF_FieldCreateGBArraySpec
    module procedure ESMF_FieldCreateGBArray
    TypeKindRankInterfaceMacro(FieldCreateGBData)
    TypeKindRankInterfaceMacro(FieldCreateGBDataPtr)
     
    module procedure ESMF_FieldCreateGridTKR
    module procedure ESMF_FieldCreateGridArraySpec
    module procedure ESMF_FieldCreateGridArray
    TypeKindRankInterfaceMacro(FieldCreateGridData)
    TypeKindRankInterfaceMacro(FieldCreateGridDataPtr)

    module procedure ESMF_FieldCreateLSTKR
    module procedure ESMF_FieldCreateLSArraySpec
    module procedure ESMF_FieldCreateLSArray
    TypeKindRankInterfaceMacro(FieldCreateLSData)
    TypeKindRankInterfaceMacro(FieldCreateLSDataPtr)

    module procedure ESMF_FieldCreateMeshTKR
    module procedure ESMF_FieldCreateMeshArraySpec
    module procedure ESMF_FieldCreateMeshArray
    TypeKindRankInterfaceMacro(FieldCreateMeshData)
    TypeKindRankInterfaceMacro(FieldCreateMeshDataPtr)

    module procedure ESMF_FieldCreateXGTKR
    module procedure ESMF_FieldCreateXGArraySpec
    module procedure ESMF_FieldCreateXGArray
    TypeKindRankInterfaceMacro(FieldCreateXGData)
    TypeKindRankInterfaceMacro(FieldCreateXGDataPtr)

    module procedure ESMF_FieldCreateFromField

! !DESCRIPTION:
!   This interface provides an entry point for methods that create a complete
!   {\tt ESMF\_Field}.  These method all contain an {\tt ESMF\_Grid} and
!   {\tt ESMF\_Data}.  The variations allow the user to specify the data
!   using either a Fortran array or an {\tt ESMF\_Array}.
  end interface
!EOPI
!------------------------------------------------------------------------------

!===============================================================================
! FieldOperator() interfaces
!===============================================================================

! -------------------------- ESMF-public method -------------------------------
!BOP
! !IROUTINE: ESMF_FieldAssignment(=) - Field assignment
!
! !INTERFACE:
!   interface assignment(=)
!   field1 = field2
!
! !ARGUMENTS:
!   type(ESMF_Field) :: field1
!   type(ESMF_Field) :: field2
!
!
! !STATUS:
! \begin{itemize}
! \item\apiStatusCompatibleVersion{5.2.0r}
! \end{itemize}
!
! !DESCRIPTION:
!   Assign field1 as an alias to the same ESMF Field object in memory
!   as field2. If field2 is invalid, then field1 will be equally invalid after
!   the assignment.
!
!   The arguments are:
!   \begin{description}
!   \item[field1]
!     The {\tt ESMF\_Field} object on the left hand side of the assignment.
!   \item[field2]
!     The {\tt ESMF\_Field} object on the right hand side of the assignment.
!   \end{description}
!
!EOP
!------------------------------------------------------------------------------


! -------------------------- ESMF-public method -------------------------------
!BOP
! !IROUTINE: ESMF_FieldOperator(==) - Field equality operator
!
! !INTERFACE:
  interface operator(==)
!   if (field1 == field2) then ... endif
!             OR
!   result = (field1 == field2)
! !RETURN VALUE:
!   logical :: result
!
! !ARGUMENTS:
!   type(ESMF_Field), intent(in) :: field1
!   type(ESMF_Field), intent(in) :: field2
!
!
! !STATUS:
! \begin{itemize}
! \item\apiStatusCompatibleVersion{5.2.0r}
! \end{itemize}
!
! !DESCRIPTION:
!   Test whether field1 and field2 are valid aliases to the same ESMF
!   Field object in memory. For a more general comparison of two ESMF Fields,
!   going beyond the simple alias test, the ESMF\_FieldMatch() function (not yet
!   implemented) must be used.
!
!   The arguments are:
!   \begin{description}
!   \item[field1]
!     The {\tt ESMF\_Field} object on the left hand side of the equality
!     operation.
!   \item[field2]
!     The {\tt ESMF\_Field} object on the right hand side of the equality
!     operation.
!   \end{description}
!
!EOP
    module procedure ESMF_FieldEQ

  end interface
!------------------------------------------------------------------------------


! -------------------------- ESMF-public method -------------------------------
!BOP
! !IROUTINE: ESMF_FieldOperator(/=) - Field not equal operator
!
! !INTERFACE:
  interface operator(/=)
!   if (field1 /= field2) then ... endif
!             OR
!   result = (field1 /= field2)
! !RETURN VALUE:
!   logical :: result
!
! !ARGUMENTS:
!   type(ESMF_Field), intent(in) :: field1
!   type(ESMF_Field), intent(in) :: field2
!
!
! !STATUS:
! \begin{itemize}
! \item\apiStatusCompatibleVersion{5.2.0r}
! \end{itemize}
!
! !DESCRIPTION:
!   Test whether field1 and field2 are {\it not} valid aliases to the
!   same ESMF Field object in memory. For a more general comparison of two ESMF
!   Fields, going beyond the simple alias test, the ESMF\_FieldMatch() function
!   (not yet implemented) must be used.
!
!   The arguments are:
!   \begin{description}
!   \item[field1]
!     The {\tt ESMF\_Field} object on the left hand side of the non-equality
!     operation.
!   \item[field2]
!     The {\tt ESMF\_Field} object on the right hand side of the non-equality
!     operation.
!   \end{description}
!
!EOP
    module procedure ESMF_FieldNE

  end interface
!------------------------------------------------------------------------------


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

contains

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


!-------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_FieldEQ()"
!BOPI
! !IROUTINE:  ESMF_FieldEQ - Compare two Fields for equality
!
! !INTERFACE:
  impure elemental function ESMF_FieldEQ(field1, field2)
!
! !RETURN VALUE:
    logical :: ESMF_FieldEQ

! !ARGUMENTS:
    type(ESMF_Field), intent(in) :: field1
    type(ESMF_Field), intent(in) :: field2

! !DESCRIPTION:
!   Test if both {\tt field1} and {\tt field2} alias the same ESMF Field
!   object.
!
!EOPI
!-------------------------------------------------------------------------------

    ESMF_INIT_TYPE finit1, finit2
    integer :: localrc1, localrc2
    logical :: lval1, lval2

    ! Use the following logic, rather than "ESMF-INIT-CHECK-DEEP", to gain
    ! init checks on both args, and in the case where both are uninitialized,
    ! to distinguish equality based on uninitialized type (uncreated,
    ! deleted).

    ! TODO: Consider moving this logic to C++: use Base class? status?
    !       Or replicate logic for C interface also.

    ! check inputs
    finit1 = ESMF_FieldGetInit(field1)
    finit2 = ESMF_FieldGetInit(field2)

    ! TODO: this line must remain split in two for SunOS f90 8.3 127000-03
    if (finit1 .eq. ESMF_INIT_CREATED .and. &
      finit2 .eq. ESMF_INIT_CREATED) then
      ESMF_FieldEQ = associated(field1%ftypep,field2%ftypep)
    else
      ESMF_FieldEQ = ESMF_FALSE
    endif

  end function ESMF_FieldEQ
!-------------------------------------------------------------------------------


!-------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_FieldNE()"
!BOPI
! !IROUTINE:  ESMF_FieldNE - Compare two Fields for non-equality
!
! !INTERFACE:
  impure elemental function ESMF_FieldNE(field1, field2)
!
! !RETURN VALUE:
    logical :: ESMF_FieldNE

! !ARGUMENTS:
    type(ESMF_Field), intent(in) :: field1
    type(ESMF_Field), intent(in) :: field2

! !DESCRIPTION:
!   Test if both {\tt field1} and {\tt field2} alias the same ESMF Field
!   object.
!
!EOPI
!-------------------------------------------------------------------------------

    ESMF_INIT_TYPE finit1, finit2
    integer :: localrc1, localrc2
    logical :: lval1, lval2

    ! Use the following logic, rather than "ESMF-INIT-CHECK-DEEP", to gain
    ! init checks on both args, and in the case where both are uninitialized,
    ! to distinguish equality based on uninitialized type (uncreated,
    ! deleted).

    ESMF_FieldNE = .not.ESMF_FieldEQ(field1, field2)

  end function ESMF_FieldNE
!-------------------------------------------------------------------------------

! -------------------------- ESMF-public method -------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_FieldCopy()"
!BOP
! !IROUTINE: ESMF_FieldCopy - Copy data from one Field object to another

! !INTERFACE:
  subroutine ESMF_FieldCopy(fieldOut, fieldIn, keywordEnforcer, rc)
!
! !ARGUMENTS:
       type(ESMF_Field),  intent(inout)          :: fieldOut
       type(ESMF_Field),  intent(in)             :: fieldIn
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
       integer,           intent(out),  optional :: rc
!
! !DESCRIPTION:
! Copy data from one {\tt ESMF\_Field} object to another.
!
! The arguments are:
! \begin{description}
! \item[fieldOut]
!     {\tt ESMF\_Field} object into which to copy the data. The incoming
!     {\tt fieldOut} must already references a matching memory allocation.
! \item[fieldIn]
!     {\tt ESMF\_Field} object that holds the data to be copied.
! \item[{[rc]}]
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!EOP
!------------------------------------------------------------------------------
    integer                 :: localrc    ! local return code

    ! Initialize return code; assume failure until success is certain
    localrc = ESMF_RC_NOT_IMPL
    if (present(rc)) rc = ESMF_RC_NOT_IMPL

    ESMF_INIT_CHECK_DEEP_SHORT(ESMF_FieldGetInit, fieldIn, rc)
    ESMF_INIT_CHECK_DEEP_SHORT(ESMF_FieldGetInit, fieldOut, rc)

    ! Call into the Array method
    call ESMF_ArrayCopy(fieldOut%ftypep%array, fieldIn%ftypep%array, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
      ESMF_CONTEXT, rcToReturn=rc)) return

    ! Return successfully
    if (present(rc)) rc = ESMF_SUCCESS

  end subroutine ESMF_FieldCopy
!------------------------------------------------------------------------------

! ESMF_FieldCreateGe

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_FieldCreateGBTKR"
!BOP
! !IROUTINE:   ESMF_FieldCreate - Create a Field from Geom and typekind

! !INTERFACE:
  ! Private name; call using ESMF_FieldCreate()
function ESMF_FieldCreateGBTKR(geom, typekind, keywordEnforcer, &
     gridToFieldMap, ungriddedLBound, ungriddedUBound, &
     totalLWidth, totalUWidth, pinflag, name, rc)
!
! !RETURN VALUE:
    type(ESMF_Field) :: ESMF_FieldCreateGBTKR
!
! !ARGUMENTS:
    type(ESMF_Geom),         intent(in)            :: geom
    type(ESMF_TypeKind_Flag),intent(in)            :: typekind
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
    integer,                 intent(in),  optional :: gridToFieldMap(:)
    integer,                 intent(in),  optional :: ungriddedLBound(:)
    integer,                 intent(in),  optional :: ungriddedUBound(:)
    integer,                 intent(in),  optional :: totalLWidth(:)
    integer,                 intent(in),  optional :: totalUWidth(:)
    type(ESMF_Pin_Flag),     intent(in),  optional :: pinflag
    character (len=*),       intent(in),  optional :: name
    integer,                 intent(out), optional :: rc
!
! !DESCRIPTION:
! Create an {\tt ESMF\_Field} and allocate space internally for an
! {\tt ESMF\_Array}.  Return a new {\tt ESMF\_Field}. For an example and
! associated documentation using this method see section
! \ref{sec:field:usage:create_grid_tkr}.
!
! The arguments are:
! \begin{description}
! \item [geom]
!       {\tt ESMF\_Geom} object.
! \item[typekind]
!      The typekind of the Field. See section \ref{const:typekind}
!      for a list of valid typekind options.
! \item [{[gridToFieldMap]}]
!       List with number of elements equal to the
!       {\tt grid}|s dimCount.  The list elements map each dimension
!       of the {\tt grid} to a dimension in the {\tt field} by
!       specifying the appropriate {\tt field} dimension index. The default is to
!       map all of the {\tt grid}|s dimensions against the lowest dimensions of
!       the {\tt field} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../).
!       The values of all {\tt gridToFieldMap} entries must be greater than or equal
!       to one and smaller than or equal to the {\tt field} rank.
!       It is erroneous to specify the same {\tt gridToFieldMap} entry
!       multiple times. The total ungridded dimensions in the {\tt field}
!       are the total {\tt field} dimensions less
!       the dimensions in
!       the {\tt grid}.  Ungridded dimensions must be in the same order they are
!       stored in the {\t field}.
!       If the Field dimCount is less than the Grid dimCount then the default
!       gridToFieldMap will contain zeros for the rightmost entries. A zero
!       entry in the {\tt gridToFieldMap} indicates that the particular
!       Grid dimension will be replicating the Field across the DEs along
!       this direction.
! \item [{[ungriddedLBound]}]
!       Lower bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded
!       dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. When field dimension count is
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound
!       must be specified. When both are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt field}.
! \item [{[ungriddedUBound]}]
!       Upper bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded
!       dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. When field dimension count is
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound
!       must be specified. When both are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt field}.
! \item [{[totalLWidth]}]
!       Lower bound of halo region.  The size of this array is the number
!       of gridded dimensions in the Field.  However, ordering of the elements
!       needs to be the same as they appear in the {\tt field}.  Values default
!       to 0.  If values for totalLWidth are specified they must be reflected in
!       the size of the {\tt field}.  That is, for each gridded dimension the
!       {\tt field} size should be max( {\tt totalLWidth} + {\tt totalUWidth}
!       + {\tt computationalCount}, {\tt exclusiveCount} ).
! \item [{[totalUWidth]}]
!       Upper bound of halo region.  The size of this array is the number
!       of gridded dimensions in the Field.  However, ordering of the elements
!       needs to be the same as they appear in the {\tt field}.  Values default
!       to 0.  If values for totalUWidth are specified they must be reflected in
!       the size of the {\tt field}.  That is, for each gridded dimension the
!       {\tt field} size should max( {\tt totalLWidth} + {\tt totalUWidth}
!       + {\tt computationalCount}, {\tt exclusiveCount} ).
! \item[{[pinflag]}]
!      Specify which type of resource DEs are pinned to.  See section 
!      \ref{const:pin_flag} for a list of valid pinning options.
!      The default is to pin DEs to PETs, i.e. only the PET on which a DE
!      was created considers the DE as local.
! \item [{[name]}]
!       Field name.
! \item [{[rc]}]
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!EOP
!------------------------------------------------------------------------------
    integer :: localrc                          !  Local error code
    type(ESMF_ArraySpec) :: arrayspec
    integer :: rank, ungridded_dimcount, ungridded_ldimcount, ungridded_udimcount
    integer :: memDimCount, grid_repdimcount, i
    character(320)  :: msgString

    ! Initialize
    localrc = ESMF_RC_NOT_IMPL

    ! Initialize return code
    if(present(rc)) rc = ESMF_RC_NOT_IMPL

    ! Get ungridded dim information
    ungridded_dimcount = 0
    if(present(ungriddedLBound)) then
      ungridded_ldimcount = size(ungriddedLBound)
      ungridded_dimcount = ungridded_ldimcount
    endif
    if(present(ungriddedUBound)) then
      ungridded_udimcount = size(ungriddedUBound)
      ungridded_dimcount = ungridded_udimcount
    endif

    if(present(ungriddedLBound) .and. present(ungriddedUBound)) then
      if(ungridded_ldimcount /= ungridded_udimcount) then
        call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, &
          msg="- ungriddedLBound size must equal to ungriddedUBound size", &
          ESMF_CONTEXT, rcToReturn=rc)
        return
      endif
    endif


    ! Get number of replicated dims
    grid_repdimcount = 0
    if (present(gridToFieldMap)) then
       do i = 1, size(gridToFieldMap)
           if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1
       enddo
    endif

    ! Get rank of geom
    call ESMF_GeomGet(geom, rank=memDimCount, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
        ESMF_CONTEXT, rcToReturn=rc)) return

    
    ! Calculate rank from dimension information
    rank = ungridded_dimcount + memDimCount - grid_repdimcount
    
#ifdef DEBUGGING
    write(msgString,*) "ESMF_FieldCreateGBTKR(): rank=", rank, &
      "ungridded_dimcount=", ungridded_dimcount, "memDimCount=", memDimCount, &
      "grid_repdimcount=", grid_repdimcount
    call ESMF_LogWrite(msgString, ESMF_LOGMSG_INFO, rc=rc)
#endif

    ! Set ArraySpec from rank and typekind input
    call ESMF_ArraySpecSet(arrayspec, rank=rank, typekind=typekind, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
        ESMF_CONTEXT, rcToReturn=rc)) return

    ESMF_FieldCreateGBTKR = ESMF_FieldCreate(geom, arrayspec, &
      gridToFieldMap=gridToFieldMap, ungriddedLBound=ungriddedLBound, &
      ungriddedUBound=ungriddedUBound, totalLWidth=totalLWidth, &
      totalUWidth=totalUWidth, pinflag=pinflag, name=name, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
        ESMF_CONTEXT, rcToReturn=rc)) return

    ! Return successfully
    if (present(rc)) rc = ESMF_SUCCESS

end function ESMF_FieldCreateGBTKR

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_FieldCreateGBArraySpec"
!BOP
! !IROUTINE:   ESMF_FieldCreate - Create a Field from Geom and ArraySpec

! !INTERFACE:
  ! Private name; call using ESMF_FieldCreate()
  function ESMF_FieldCreateGBArraySpec(geom, arrayspec, gridToFieldMap, &
    ungriddedLBound, ungriddedUBound, totalLWidth, totalUWidth, &
    pinflag, name, rc)
!
! !RETURN VALUE:
    type(ESMF_Field) :: ESMF_FieldCreateGBArraySpec
!
! !ARGUMENTS:
    type(ESMF_Geom) :: geom
    type(ESMF_ArraySpec), intent(in) :: arrayspec
    integer, intent(in), optional :: gridToFieldMap(:)
    integer, intent(in), optional :: ungriddedLBound(:)
    integer, intent(in), optional :: ungriddedUBound(:)
    integer, intent(in), optional :: totalLWidth(:)
    integer, intent(in), optional :: totalUWidth(:)
    type(ESMF_Pin_Flag),  intent(in), optional :: pinflag
    character (len=*),    intent(in), optional :: name
    integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Create an {\tt ESMF\_Field} and allocate space internally for an
! {\tt ESMF\_Array}.  Return a new {\tt ESMF\_Field}. For an example and
! associated documentation using this method see section
! \ref{sec:field:usage:create_grid_arrayspec}.
!
! The arguments are:
! \begin{description}
! \item [geom]
!       {\tt ESMF\_Geom} object.
! \item [arrayspec]
!       Data type and kind specification.
! \item [{[gridToFieldMap]}]
!       List with number of elements equal to the
!       {\tt grid}|s dimCount.  The list elements map each dimension
!       of the {\tt grid} to a dimension in the {\tt field} by
!       specifying the appropriate {\tt field} dimension index. The default is to
!       map all of the {\tt grid}|s dimensions against the lowest dimensions of
!       the {\tt field} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../).
!       The values of all {\tt gridToFieldMap} entries must be greater than or equal
!       to one and smaller than or equal to the {\tt field} rank.
!       It is erroneous to specify the same {\tt gridToFieldMap} entry
!       multiple times. The total ungridded dimensions in the {\tt field}
!       are the total {\tt field} dimensions less
!       the dimensions in
!       the {\tt grid}.  Ungridded dimensions must be in the same order they are
!       stored in the {\t field}.
! \item [{[ungriddedLBound]}]
!       Lower bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded
!       dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. When field dimension count is
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound
!       must be specified. When both are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt field}.
! \item [{[ungriddedUBound]}]
!       Upper bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded
!       dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. When field dimension count is
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound
!       must be specified. When both are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt field}.
! \item [{[totalLWidth]}]
!       Lower bound of halo region.  The size of this array is the number
!       of gridded dimensions in the Field.  However, ordering of the elements
!       needs to be the same as they appear in the {\tt field}.  Values default
!       to 0.  If values for totalLWidth are specified they must be reflected in
!       the size of the {\tt field}.  That is, for each gridded dimension the
!       {\tt field} size should be max( {\tt totalLWidth} + {\tt totalUWidth}
!       + {\tt computationalCount}, {\tt exclusiveCount} ).
! \item [{[totalUWidth]}]
!       Upper bound of halo region.  The size of this array is the number
!       of gridded dimensions in the Field.  However, ordering of the elements
!       needs to be the same as they appear in the {\tt field}.  Values default
!       to 0.  If values for totalUWidth are specified they must be reflected in
!       the size of the {\tt field}.  That is, for each gridded dimension the
!       {\tt field} size should max( {\tt totalLWidth} + {\tt totalUWidth}
!       + {\tt computationalCount}, {\tt exclusiveCount} ).
! \item[{[pinflag]}]
!      Specify which type of resource DEs are pinned to.  See section 
!      \ref{const:pin_flag} for a list of valid pinning options.
!      The default is to pin DEs to PETs, i.e. only the PET on which a DE
!      was created considers the DE as local.
! \item [{[name]}]
!       Field name.
! \item [{[rc]}]
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!EOP
!------------------------------------------------------------------------------
    type(ESMF_FieldType), pointer :: ftype      ! Pointer to new field
    integer :: localrc                          !  Local error code
    logical :: rcpresent                        ! Return code present
    integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount
    integer :: gridDimCount, gridDimCount_norep, grid_repdimcount
    integer :: fieldUndistDimCount
    integer :: i,j
    integer :: localGridToFieldMap(ESMF_MAXDIM)
    integer :: localMaxHaloLWidth (ESMF_MAXDIM)
    integer :: localMaxHaloUWidth (ESMF_MAXDIM)
    integer :: distgridToGridMap(ESMF_MAXDIM)
    logical :: flipflop(ESMF_MAXDIM)
    logical :: found
    type(ESMF_GridDecompType) :: decompType
    type(ESMF_GeomType_Flag) :: geomtype
    type(ESMF_Grid) :: grid
    integer :: arbdim
    character(320)  :: msgString

    ! Initialize
    localrc = ESMF_RC_NOT_IMPL
    rcpresent = .FALSE.
    nullify(ftype)
    nullify(ESMF_FieldCreateGBArraySpec%ftypep)

    ! Initialize return code
    if(present(rc)) then
      rcpresent=.TRUE.
      rc = ESMF_RC_NOT_IMPL
    endif

    ! check init status of input parameters
    ESMF_INIT_CHECK_DEEP(ESMF_GeomGetInit,geom,rc)
    ESMF_INIT_CHECK_SHALLOW(ESMF_ArraySpecGetInit, arrayspec, rc)

    ! Check if geom is a grid, if so, check if it is arbitrary
    decompType = ESMF_GRID_NONARBITRARY
    call ESMF_GeomGet(geom, geomtype=geomtype, rc=localrc)
    if (ESMF_LogFoundError(localrc, &
        ESMF_ERR_PASSTHRU, &
        ESMF_CONTEXT, rcToReturn=rc)) return

    if (geomtype .eq. ESMF_GEOMTYPE_GRID) then
       call ESMF_GeomGet(geom, grid=grid, rc=localrc)
       if (ESMF_LogFoundError(localrc, &
           ESMF_ERR_PASSTHRU, &
           ESMF_CONTEXT, rcToReturn=rc)) return
       call ESMF_GridGetDecompType(grid, decompType, rc=localrc)
       if (ESMF_LogFoundError(localrc, &
           ESMF_ERR_PASSTHRU, &
           ESMF_CONTEXT, rcToReturn=rc)) return
    endif

    ! Get rank of proposed Field.
    call ESMF_ArraySpecGet(arrayspec, rank=memDimCount, rc=localrc)
    if (ESMF_LogFoundError(localrc, &
         ESMF_ERR_PASSTHRU, &
         ESMF_CONTEXT, rcToReturn=rc)) return

    ! Get number of grid dimensions, number
    ! of distributed grid dimensions, distgrid,
    ! number of ungridded Field dimensions,
    ! and number of undistributed Field Dimensions
    call ESMF_GeomGet(geom, dimCount=gridDimCount, rc=localrc)
    if (ESMF_LogFoundError(localrc, &
        ESMF_ERR_PASSTHRU, &
        ESMF_CONTEXT, rcToReturn=rc)) return

    ! Error Check Input
    if (present(gridToFieldMap)) then
        if (size(gridToFieldMap) .ne. gridDimCount) then
           call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, &
             msg="- gridToFieldMap size must equal to grid_rank", &
             ESMF_CONTEXT, rcToReturn=rc)
            return
        endif
    endif

    grid_repdimcount = 0
    localGridToFieldMap = -1
    if (present(gridToFieldMap)) then
       localGridToFieldMap(1:gridDimCount) = &
         gridToFieldMap (1:gridDimCount)
       do i = 1, size(gridToFieldMap)
           if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1
       enddo
    else
      do i = 1, gridDimCount
        localGridToFieldMap(i) = i
      enddo
    endif
    gridDimCount_norep = gridDimCount - grid_repdimcount

    if (decompType .eq. ESMF_GRID_NONARBITRARY) then
            fieldDimCount = memDimCount
    else
        call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, &
            rc=localrc)
        if (ESMF_LogFoundError(localrc, &
            ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) return
        ! find out how many grid dimensions are arbitrarily distributed and calculate
        ! fieldDimCount accordingly
        arbdim = 0
        do i=1,gridDimCount
          if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1
        enddo
        fieldDimCount = memDimCount + arbdim - 1

        ! If there is any replicated dimension, check if any of the arb. dimensions are replicated.
        ! If one arb dimension is replicated, all the arb. dimensions have to be replicated
        if (grid_repdimcount .ne. 0) then
          do i = 1,gridDimCount
            if(localGridToFieldMap(i) == 0) then
                found = .false.
                do j=1,arbdim
                    if (distgridToGridMap(j) .eq. i) found = .true.
                enddo
                if (found) then
                  ! one arb.dimension is a replicated dimension, check if other arb dimensions are
                  ! also replicated
                  do j=1,arbdim
                    if (distgridToGridMap(j) .ne. i) then
                        if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then
                            call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, &
  msg="- Arb. grid dimensions have to be either all replicated or not replicated", &
  ESMF_CONTEXT, rcToReturn=rc)
                            return
                        endif
                    endif
                  enddo
                  ! all arb. dimension are replication, jump out of the first do loop
                  ! fieldDimCount should be the same as the memDimCount
                  fieldDimCount = memDimCount
                  exit
                endif   
             endif
           enddo
        endif           
    endif

    if(fieldDimCount .lt. gridDimCount_norep) then
      call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, &
        msg="- Field rank must be greater than or equal to its gridded rank", &
        ESMF_CONTEXT, rcToReturn=rc)
      return
    endif

    if(fieldDimCount .gt. gridDimCount_norep) then
      if( (.not. present(ungriddedLBound)) .or. &
          (.not. present(ungriddedUBound)) ) then
        call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_VALUE, &
          msg="- ungridded bounds must be present when Field has ungridded dimension(s)", &
          ESMF_CONTEXT, rcToReturn=rc)
        return
      endif
    endif

    fieldUngriddedDimCount = fieldDimCount-gridDimCount  + grid_repdimcount
    fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount

    if (present(ungriddedLBound)) then
       if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then
          write(msgString,*) "ungriddedLBound does not match: ", &
            " fieldUngriddedDimCount=", fieldUngriddedDimCount, &
            " fieldDimCount=", fieldDimCount, &
            " gridDimCount=", gridDimCount, &
            " grid_repdimcount=", grid_repdimcount
          call ESMF_LogWrite(msgString, ESMF_LOGMSG_INFO, rc=rc)
          call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, &
               msg="- ungriddedLBound size must equal to array_rank-grid_rank", &
               ESMF_CONTEXT, rcToReturn=rc)
          return
       endif
    endif

    if (present(ungriddedUBound)) then
       if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then
          call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, &
                 msg="- ungriddedUBound size must equal to array_rank-grid_rank", &
                 ESMF_CONTEXT, rcToReturn=rc)
          return
       endif
    endif

    if (present(totalLWidth)) then
        if (size(totalLWidth) .ne. gridDimCount_norep) then
            call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, &
              msg="- totalLWidth must equal to grid dimCount", &
                ESMF_CONTEXT, rcToReturn=rc)
            return
        endif
    endif

    if (present(totalUWidth)) then
       if (size(totalUWidth) .ne. gridDimCount_norep) then
           call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, &
              msg="- totalUWidth must equal to grid dimCount", &
                ESMF_CONTEXT, rcToReturn=rc)
           return
       endif
    endif

    ! gridToFieldMap elements must be in range 1...fieldRank and unique
    ! algorithm to check element uniqueness:
    !   run time: O(ESMF_MAXDIM)
    !   memory:   O(2*ESMF_MAXDIM)
    !          or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector
    flipflop = .false.
    do i = 1, gridDimCount
       if(localGridToFieldMap(i) .lt. 0 .and. &
         localGridToFieldMap(i) .gt. fieldDimCount) then
           call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_VALUE, &
             msg="- gridToFieldMap element must be within range 0...array rank", &
             ESMF_CONTEXT, rcToReturn=rc)
           return
       endif
       if(localGridToFieldMap(i) /= 0) then
           if(flipflop(localGridToFieldMap(i))) then
             call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_VALUE, &
               msg="- gridToFieldMap element must be unique", &
               ESMF_CONTEXT, rcToReturn=rc)
             return
           endif
           flipflop(localGridToFieldMap(i)) = .true.
       endif
    enddo

     if(present(totalLWidth)) then
       localMaxHaloLWidth(1:gridDimCount_norep) = &
          totalLWidth (1:gridDimCount_norep)
     else
          localMaxHaloLWidth = 0
     endif

     if(present(totalUWidth)) then
       localMaxHaloUWidth(1:gridDimCount_norep) = &
          totalUWidth (1:gridDimCount_norep)
     else
          localMaxHaloUWidth = 0
     endif

    ! allocate Fieldtype
    allocate(ftype, stat=localrc)
    if (ESMF_LogFoundAllocError(localrc, &
      msg="Allocating Field Type", &
      ESMF_CONTEXT, rcToReturn=rc)) return

    call ESMF_FieldInitialize(ftype, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
      ESMF_CONTEXT, rcToReturn=rc)) return

    ! Call construction method to allocate and initialize field internals.
    if (decompType .eq. ESMF_GRID_NONARBITRARY) then
       call ESMF_FieldConstructIANew(ftype, geom, arrayspec, &
                                localGridToFieldMap(1:gridDimCount), ungriddedLBound, &
                                ungriddedUBound, localMaxHaloLWidth(1:gridDimCount_norep), &
                                localMaxHaloUWidth(1:gridDimCount_norep), &
                                pinflag=pinflag, name=name, rc=localrc)
       if (ESMF_LogFoundError(localrc, &
         ESMF_ERR_PASSTHRU, &
         ESMF_CONTEXT, rcToReturn=rc)) return
    else
          call ESMF_FieldConstructIANew(ftype, geom, arrayspec, &
                                localGridToFieldMap(1:gridDimCount), ungriddedLBound, &
                                ungriddedUBound, &
                                pinflag=pinflag, name=name, rc=localrc)
       if (ESMF_LogFoundError(localrc, &
         ESMF_ERR_PASSTHRU, &
         ESMF_CONTEXT, rcToReturn=rc)) return
    endif

    ! Set return values.
    ESMF_FieldCreateGBArraySpec%ftypep => ftype

    ! Add reference to this object into ESMF garbage collection table
    ! Only call this in those Create() methods that call Construct()
    call c_ESMC_VMAddFObject(ESMF_FieldCreateGBArraySpec, &
      ESMF_ID_FIELD%objectID)

    ESMF_INIT_SET_CREATED(ESMF_FieldCreateGBArraySpec)

    call ESMF_FieldValidate(ESMF_FieldCreateGBArraySpec, rc=localrc)
    if (ESMF_LogFoundError(localrc, &
      ESMF_ERR_PASSTHRU, &
      ESMF_CONTEXT, rcToReturn=rc)) then
      call ESMF_BaseSetStatus(ftype%base, ESMF_STATUS_INVALID, rc=localrc)
      return
    endif

    if(rcpresent) rc = ESMF_SUCCESS

  end function ESMF_FieldCreateGBArraySpec
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_FieldCreateGBArray"
!BOP
! !IROUTINE: ESMF_FieldCreate - Create a Field from Geom and Array

! !INTERFACE:
  ! Private name; call using ESMF_FieldCreate()
  function ESMF_FieldCreateGBArray(geom, array, datacopyflag, &
    gridToFieldMap, ungriddedLBound, ungriddedUBound, &
    totalLWidth, totalUWidth, name, vm, rc)
!
! !RETURN VALUE:
    type(ESMF_Field) :: ESMF_FieldCreateGBArray
!
! !ARGUMENTS:
    type(ESMF_Geom), intent(in) :: geom
    type(ESMF_Array), intent(in) :: array
    type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag
    integer, intent(in), optional :: gridToFieldMap(:)
    integer, intent(in), optional :: ungriddedLBound(:)
    integer, intent(in), optional :: ungriddedUBound(:)
    integer, intent(in), optional :: totalLWidth(:)
    integer, intent(in), optional :: totalUWidth(:)
    character (len = *), intent(in),  optional :: name
    type(ESMF_VM),       intent(in),  optional :: vm
    integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Create an {\tt ESMF\_Field}.  This version of creation
! assumes the data exists already and is being
! passed in through an {\tt ESMF\_Array}.  For an example and
! associated documentation using this method see section
! \ref{sec:field:usage:create_grid_array}.
!
! The arguments are:
! \begin{description}
! \item [geom]
!       {\tt ESMF\_Geom} object.
! \item [array]
!       {\tt ESMF\_Array} object.
! \item [{[datacopyflag]}]
!       Indicates whether to copy the contents of the {\tt array} or reference it directly.
!       For valid values see \ref{const:datacopyflag}.  The default is
!       {\tt ESMF\_DATACOPY\_REFERENCE}.
! \item [{[gridToFieldMap]}]
!       List with number of elements equal to the
!       {\tt grid}|s dimCount.  The list elements map each dimension
!       of the {\tt grid} to a dimension in the {\tt field} by
!       specifying the appropriate {\tt field} dimension index. The default is to
!       map all of the {\tt grid}|s dimensions against the lowest dimensions of
!       the {\tt field} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../).
!       The values of all {\tt gridToFieldMap} entries must be greater than or equal
!       to one and smaller than or equal to the {\tt field} rank.
!       It is erroneous to specify the same {\tt gridToFieldMap} entry
!       multiple times. The total ungridded dimensions in the {\tt field}
!       are the total {\tt field} dimensions less
!       the dimensions in
!       the {\tt grid}.  Ungridded dimensions must be in the same order they are
!       stored in the {\t field}.
! \item [{[ungriddedLBound]}]
!       Lower bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded
!       dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. When field dimension count is
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound
!       must be specified. When both are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt field}.
! \item [{[ungriddedUBound]}]
!       Upper bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded
!       dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. When field dimension count is
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound
!       must be specified. When both are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt field}.
! \item [{[totalLWidth]}]
!       Lower bound of halo region.  The size of this array is the number
!       of gridded dimensions in the Field.  However, ordering of the elements
!       needs to be the same as they appear in the {\tt field}.  Values default
!       to 0.  If values for totalLWidth are specified they must be reflected in
!       the size of the {\tt field}.  That is, for each gridded dimension the
!       {\tt field} size should be max( {\tt totalLWidth} + {\tt totalUWidth}
!       + {\tt computationalCount}, {\tt exclusiveCount} ).
! \item [{[totalUWidth]}]
!       Upper bound of halo region.  The size of this array is the number
!       of gridded dimensions in the Field.  However, ordering of the elements
!       needs to be the same as they appear in the {\tt field}.  Values default
!       to 0.  If values for totalUWidth are specified they must be reflected in
!       the size of the {\tt field}.  That is, for each gridded dimension the
!       {\tt field} size should max( {\tt totalLWidth} + {\tt totalUWidth}
!       + {\tt computationalCount}, {\tt exclusiveCount} ).
! \item [{[name]}]
!       Field name.
! \item[{[vm]}]
!       If present, the Field object is created on the specified
!       {\tt ESMF\_VM} object. The default is to create on the VM of the
!       current component context.
! \item [{[rc]}]
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!EOP
!------------------------------------------------------------------------------
    type(ESMF_FieldType), pointer :: ftype  ! Pointer to new field
    integer :: localrc                       !  Local error code
    logical :: rcpresent                    ! Return code present

    integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount
    integer :: gridDimCount, gridDimCount_norep, grid_repdimcount
    integer :: fieldUndistDimCount
    integer :: i,j
    integer :: localGridToFieldMap(ESMF_MAXDIM)
    logical :: flipflop(ESMF_MAXDIM)
    type(ESMF_DataCopy_Flag)    :: l_datacopyflag
    type (ESMF_Index_Flag) :: arrayIndexFlag, gridIndexFlag
    integer :: distgridToGridMap(ESMF_MAXDIM)
    logical :: found
    type(ESMF_GridDecompType) :: decompType
    type(ESMF_GeomType_Flag) :: geomtype
    type(ESMF_Grid) :: grid
    integer :: arbdim
    type(ESMF_Pointer)                    :: vmThis
    logical                               :: actualFlag

    ! Initialize
    localrc = ESMF_RC_NOT_IMPL
    rcpresent = .FALSE.
    nullify(ftype)
    nullify(ESMF_FieldCreateGBArray%ftypep)

    ! Initialize return code
    if(present(rc)) then
      rcpresent = .TRUE.
      rc = ESMF_RC_NOT_IMPL
    endif

    ! Must make sure the local PET is associated with an actual member
    actualFlag = .true.
    if (present(vm)) then
      ESMF_INIT_CHECK_DEEP(ESMF_VMGetInit, vm, rc)
      call ESMF_VMGetThis(vm, vmThis)
      if (vmThis == ESMF_NULL_POINTER) then
        actualFlag = .false.  ! local PET is not for an actual member
      endif
    endif

    if (actualFlag) then

      ! check init status of input parameters
      ESMF_INIT_CHECK_DEEP(ESMF_GeomGetInit,geom,rc)
      ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc)

      ! Check if geom is a grid, if so, check if it is arbitrary
      decompType = ESMF_GRID_NONARBITRARY
      call ESMF_GeomGet(geom, geomtype=geomtype, rc=localrc)
      if (ESMF_LogFoundError(localrc, &
          ESMF_ERR_PASSTHRU, &
          ESMF_CONTEXT, rcToReturn=rc)) return

      if (geomtype .eq. ESMF_GEOMTYPE_GRID) then
         call ESMF_GeomGet(geom, grid=grid, rc=localrc)
         if (ESMF_LogFoundError(localrc, &
             ESMF_ERR_PASSTHRU, &
             ESMF_CONTEXT, rcToReturn=rc)) return
         call ESMF_GridGetDecompType(grid, decompType, rc=localrc)
         if (ESMF_LogFoundError(localrc, &
             ESMF_ERR_PASSTHRU, &
             ESMF_CONTEXT, rcToReturn=rc)) return
      endif

      ! Get rank of proposed Field.
      call ESMF_ArrayGet(array, rank=memDimCount, &
                         indexflag=arrayIndexFlag, rc=localrc)
      if (ESMF_LogFoundError(localrc, &
           ESMF_ERR_PASSTHRU, &
           ESMF_CONTEXT, rcToReturn=rc)) return

      ! Get number of grid dimensions, number
      ! of distributed grid dimensions, distgrid,
      ! number of ungridded Field dimensions,
      ! and number of undistributed Field Dimensions
      call ESMF_GeomGet(geom, dimCount=gridDimCount, &
                        indexflag=gridIndexFlag, rc=localrc)
      if (ESMF_LogFoundError(localrc, &
          ESMF_ERR_PASSTHRU, &
          ESMF_CONTEXT, rcToReturn=rc)) return

      ! Error Check Input
      if (present(gridToFieldMap)) then
          if (size(gridToFieldMap) .ne. gridDimCount) then
              call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, &
                msg="- gridToFieldMap size must equal to grid_rank", &
                ESMF_CONTEXT, rcToReturn=rc)
              return
          endif
      endif

      grid_repdimcount = 0
      localGridToFieldMap = -1
      if (present(gridToFieldMap)) then
         localGridToFieldMap(1:gridDimCount) = &
           gridToFieldMap (1:gridDimCount)
         do i = 1, size(gridToFieldMap)
             if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1
         enddo
      else
        do i = 1, gridDimCount
          localGridToFieldMap(i) = i
        enddo
      endif
      gridDimCount_norep = gridDimCount - grid_repdimcount

      if (decompType .eq. ESMF_GRID_NONARBITRARY) then
              fieldDimCount = memDimCount
      else
          call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, &
              rc=localrc)
          if (ESMF_LogFoundError(localrc, &
              ESMF_ERR_PASSTHRU, &
              ESMF_CONTEXT, rcToReturn=rc)) return
          ! find out how many grid dimensions are arbitrarily distributed and calculate
          ! fieldDimCount accordingly
          arbdim = 0
          do i=1,gridDimCount
            if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1
          enddo
          fieldDimCount = memDimCount + arbdim - 1

          ! If there is any replicated dimension, check if any of the arb. dimensions are replicated.
          ! If one arb dimension is replicated, all the arb. dimensions have to be replicated
          if (grid_repdimcount .ne. 0) then
            do i = 1,gridDimCount
              if(localGridToFieldMap(i) == 0) then
                  found = .false.
                  do j=1,arbdim
                      if (distgridToGridMap(j) .eq. i) found = .true.
                  enddo
                  if (found) then
                    ! one arb.dimension is a replicated dimension, check if other arb dimensions are
                    ! also replicated
                    do j=1,arbdim
                      if (distgridToGridMap(j) .ne. i) then
                          if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then
                              call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, &
    msg="- Arb. grid dimensions have to be either all replicated or not replicated", &
    ESMF_CONTEXT, rcToReturn=rc)
                              return
                          endif
                      endif
                    enddo
                    ! all arb. dimension are replication, jump out of the first do loop
                    ! fieldDimCount should be the same as the memDimCount
                    fieldDimCount = memDimCount
                    exit
                  endif
               endif
             enddo
          endif
      endif

      if(fieldDimCount .lt. gridDimCount_norep) then
          call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, &
            msg="- Field rank must be greater than or equal to its gridded rank", &
            ESMF_CONTEXT, rcToReturn=rc)
          return
      endif

      if(fieldDimCount .gt. gridDimCount_norep) then
        if( (.not. present(ungriddedLBound)) .or. &
            (.not. present(ungriddedUBound)) ) then
          call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_VALUE, &
           msg="- ungridded bounds must be present when Field has ungridded dimension(s)", &
             ESMF_CONTEXT, rcToReturn=rc)
          return
        endif
      endif

      fieldUngriddedDimCount = fieldDimCount-gridDimCount  + grid_repdimcount
      fieldUndistDimCount = fieldDimCount-gridDimCount  + grid_repdimcount

      ! Error Check Input
      if (present(gridToFieldMap)) then
          if (size(gridToFieldMap) .ne. gridDimCount) then
              call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, &
                msg="- gridToFieldMap size must equal to grid_rank", &
                ESMF_CONTEXT, rcToReturn=rc)
              return
          endif
      endif

      if (present(ungriddedLBound)) then
         if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then
            call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, &
              msg="- ungriddedLBound size must equal to array_rank-grid_rank", &
              ESMF_CONTEXT, rcToReturn=rc)
            return
         endif
      endif

      if (present(ungriddedUBound)) then
         if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then
            call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, &
              msg="- ungriddedUBound size must equal to array_rank-grid_rank", &
              ESMF_CONTEXT, rcToReturn=rc)
            return
         endif
      endif

      if (present(totalLWidth)) then
          if (size(totalLWidth) .ne. gridDimCount_norep) then
              call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, &
                msg="- totalLWidth must equal to grid dimCount", &
                ESMF_CONTEXT, rcToReturn=rc)
              return
          endif
      endif

      if (present(totalUWidth)) then
         if (size(totalUWidth) .ne. gridDimCount_norep) then
             call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, &
                msg="- totalUWidth must equal to grid dimCount", &
                ESMF_CONTEXT, rcToReturn=rc)
             return
         endif
      endif

      if (.not.(arrayIndexFlag .eq. gridIndexFlag)) then
          call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_VALUE, &
            msg="- Array indexflag must be the same as the Grid indexflag", &
            ESMF_CONTEXT, rcToReturn=rc)
          return
      endif

      if (present(datacopyflag)) then
          l_datacopyflag = datacopyflag
      else
          l_datacopyflag = ESMF_DATACOPY_REFERENCE
      endif

      ! gridToFieldMap elements must be in range 1...fieldRank and unique
      ! algorithm to check element uniqueness:
      !   run time: O(ESMF_MAXDIM)
      !   memory:   O(2*ESMF_MAXDIM)
      !          or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector
      flipflop = .false.
      do i = 1, gridDimCount
         if(localGridToFieldMap(i) .lt. 0 .and. &
           localGridToFieldMap(i) .gt. fieldDimCount) then
             call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_VALUE, &
               msg="- gridToFieldMap element must be within range 0...array rank", &
               ESMF_CONTEXT, rcToReturn=rc)
             return
         endif
         if(localGridToFieldMap(i) /= 0) then
             if(flipflop(localGridToFieldMap(i))) then
                 call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_VALUE, &
                   msg="- gridToFieldMap element must be unique", &
                   ESMF_CONTEXT, rcToReturn=rc)
                 return
             endif
             flipflop(localGridToFieldMap(i)) = .true.
         endif
      enddo

      allocate(ftype, stat=localrc)
      if (ESMF_LogFoundAllocError(localrc, msg="Allocating Field information", &
        ESMF_CONTEXT, rcToReturn=rc)) return
      call ESMF_FieldInitialize(ftype, rc=localrc)
      if (ESMF_LogFoundAllocError(localrc, msg="Default initialize Field", &
        ESMF_CONTEXT, rcToReturn=rc)) return

      if (decompType .eq. ESMF_GRID_NONARBITRARY) then
          ! Call construction method to allocate and initialize field internals.
          call ESMF_FieldConstructIANewArray(ftype, geom, array, l_datacopyflag, &
                                           localgridToFieldMap, &
                                           ungriddedLBound=ungriddedLBound, &
                                           ungriddedUBound=ungriddedUBound, &
                                           totalLWidth=totalLWidth, &
                                           totalUWidth=totalUWidth, &
                                           name=name, vm=vm, rc=localrc)
          if (ESMF_LogFoundError(localrc, &
            ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) return
      else
              ! Call construction method to allocate and initialize field internals.
          call ESMF_FieldConstructIANewArray(ftype, geom, array, l_datacopyflag, &
                                           localgridToFieldMap, &
                                           ungriddedLBound=ungriddedLBound, &
                                           ungriddedUBound=ungriddedUBound, &
                                           name=name, vm=vm, rc=localrc)
          if (ESMF_LogFoundError(localrc, &
            ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) return
      endif

    endif ! - actualFlag

    ! Set return values.
    ESMF_FieldCreateGBArray%ftypep => ftype
    ESMF_INIT_SET_CREATED(ESMF_FieldCreateGBArray)

    if (actualFlag) then
      ! Add reference to this object into ESMF garbage collection table
      ! Only call this in those Create() methods that call Construct()
      call c_ESMC_VMAddFObject(ESMF_FieldCreateGBArray, ESMF_ID_FIELD%objectID)

      call ESMF_FieldValidate(ESMF_FieldCreateGBArray, rc=localrc)
      if (ESMF_LogFoundError(localrc, &
        ESMF_ERR_PASSTHRU, &
        ESMF_CONTEXT, rcToReturn=rc)) then
        call ESMF_BaseSetStatus(ftype%base, ESMF_STATUS_INVALID, rc=localrc)
        return
      endif
    endif

    if(rcpresent) rc = ESMF_SUCCESS

  end function ESMF_FieldCreateGBArray
!------------------------------------------------------------------------------


#define FieldCreateGBDataDoc() \
!---------------------------------------------------------------------------- @\
!BOP @\
! !IROUTINE: ESMF_FieldCreate - Create a Field from Geom and Fortran array @\
! @\
! !INTERFACE: @\
! ! Private name; call using ESMF_FieldCreate() @\
! function ESMF_FieldCreateGBData<rank><type><kind>(geom, & @\
!   farray, indexflag, datacopyflag, gridToFieldMap, ungriddedLBound, & @\
!   ungriddedUBound, totalLWidth, totalUWidth, name, rc) @\
! @\
! !RETURN VALUE: @\
!   type(ESMF_Field) :: ESMF_FieldCreateGBData<rank><type><kind> @\
! @\
! !ARGUMENTS: @\
!   type(ESMF_Geom) :: geom                  @\
!   <type> (ESMF_KIND_<kind>), dimension(<rank>), target :: farray @\
!   type(ESMF_Index_Flag), intent(in)            :: indexflag @\
!   type(ESMF_DataCopy_Flag), intent(in), optional   :: datacopyflag @\
!   integer, intent(in), optional :: gridToFieldMap(:)     @\
!   integer, intent(in), optional :: ungriddedLBound(:) @\
!   integer, intent(in), optional :: ungriddedUBound(:) @\
!   integer, intent(in), optional :: totalLWidth(:) @\
!   integer, intent(in), optional :: totalUWidth(:) @\
!   character (len=*), intent(in), optional :: name  @\
!   integer, intent(out), optional :: rc                @\
! @\
! !DESCRIPTION: @\
! Create an {\tt ESMF\_Field} from a Fortran data array and {\tt ESMF\_Geom}. @\
! The Fortran data pointer inside {\tt ESMF\_Field} can be queried but deallocating @\
! the retrieved data pointer is not allowed. @\
! The arguments are: @\
! \begin{description} @\
! \item [geom]  @\
!       {\tt ESMF\_Geom} object.  The dimCount of the @\
!       Geom must be smaller than or equal to the rank of the {\tt farray}. @\
! \item [farray] @\
!       Native Fortran data array to be copied/referenced in the Field @\
!       The Field dimension (dimCount) will be the same as the dimCount @\
!       for the {\tt farray}. @\
! \item [indexflag] @\
!       Indicate how DE-local indices are defined. See section @\
!       \ref{const:indexflag} for a list of valid indexflag options. @\
! \item [{[datacopyflag]}] @\
!       Whether to copy the contents of the {\tt farray} or reference it directly. @\
!       For valid values see \ref{const:datacopyflag}.  The default is @\
!       {\tt ESMF\_DATACOPY\_REFERENCE}. @\
! \item [{[gridToFieldMap]}] @\
!       List with number of elements equal to the @\
!       {\tt grid}|s dimCount.  The list elements map each dimension @\
!       of the {\tt grid} to a dimension in the {\tt farray} by @\
!       specifying the appropriate {\tt farray} dimension index. The default is to @\
!       map all of the {\tt grid}|s dimensions against the lowest dimensions of @\
!       the {\tt farray} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../). @\
!       The values of all {\tt gridToFieldMap} entries must be greater than or equal @\
!       to one and smaller than or equal to the {\tt farray} rank. @\
!       It is erroneous to specify the same {\tt gridToFieldMap} entry @\
!       multiple times. The total ungridded dimensions in the {\tt field} @\
!       are the total {\tt farray} dimensions less @\
!       the total (distributed + undistributed) dimensions in @\
!       the {\tt grid}.  Ungridded dimensions must be in the same order they are @\
!       stored in the {\t farray}.  Permutations of the order of @\
!       dimensions are handled via individual communication methods.  For example, @\
!       an undistributed dimension can be remapped to a distributed dimension @\
!       as part of the {\tt ESMF\_ArrayRedist()} operation. @\
! \item [{[ungriddedLBound]}] @\
!       Lower bounds of the ungridded dimensions of the {\tt field}. @\
!       The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded @\
!       dimensions in the {\tt field}.  All ungridded dimensions of the @\
!       {\tt field} are also undistributed. When field dimension count is @\
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound @\
!       must be specified. When both are specified the values are checked @\
!       for consistency.  Note that the the ordering of @\
!       these ungridded dimensions is the same as their order in the {\tt farray}. @\
! \item [{[ungriddedUBound]}] @\
!       Upper bounds of the ungridded dimensions of the {\tt field}. @\
!       The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded @\
!       dimensions in the {\tt field}.  All ungridded dimensions of the @\
!       {\tt field} are also undistributed. When field dimension count is @\
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound @\
!       must be specified. When both are specified the values are checked @\
!       for consistency.  Note that the the ordering of @\
!       these ungridded dimensions is the same as their order in the {\tt farray}. @\
! \item [{[totalLWidth]}] @\
!       Lower bound of halo region.  The size of this array is the number @\
!       of gridded dimensions in the Field.  However, ordering of the elements @\
!       needs to be the same as they appear in the {\tt farray}.  Values default @\
!       to 0.  If values for totalLWidth are specified they must be reflected in @\
!       the size of the {\tt farray}.  That is, for each gridded dimension the @\
!       {\tt farray} size should be max( {\tt totalLWidth} + {\tt totalUWidth} @\
!       + {\tt computationalCount}, {\tt exclusiveCount} ). @\
! \item [{[totalUWidth]}] @\
!       Upper bound of halo region.  The size of this array is the number @\
!       of gridded dimensions in the Field.  However, ordering of the elements @\
!       needs to be the same as they appear in the {\tt farray}.  Values default @\
!       to 0.  If values for totalUWidth are specified they must be reflected in @\
!       the size of the {\tt farray}.  That is, for each gridded dimension the @\
!       {\tt farray} size should max( {\tt totalLWidth} + {\tt totalUWidth} @\
!       + {\tt computationalCount}, {\tt exclusiveCount} ). @\
! \item [{[name]}]  @\
!       Field name.  @\
! \item [{[rc]}]  @\
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
! \end{description} @\
! @\
!EOP @\
!---------------------------------------------------------------------------- @\

#define FieldCreateGBDataMacro(mname, mtypekind, mrank, mdim, mlen, mrng, mloc) \
!---------------------------------------------------------------------------- @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_FieldCreateGBData" @\
  function ESMF_FieldCreateGBData##mrank##D##mtypekind(geom, & @\
    farray, indexflag, datacopyflag, gridToFieldMap, ungriddedLBound, & @\
    ungriddedUBound, totalLWidth, totalUWidth, name, rc) @\
@\
    ! return value @\
    type(ESMF_Field) :: ESMF_FieldCreateGBData##mrank##D##mtypekind @\
@\
    ! input arguments @\
    type(ESMF_Geom) :: geom                  @\
    mname (ESMF_KIND_##mtypekind), dimension(mdim), target :: farray @\
    type(ESMF_Index_Flag), intent(in)            :: indexflag @\
    type(ESMF_DataCopy_Flag), intent(in), optional   :: datacopyflag @\
    integer, intent(in), optional :: gridToFieldMap(:)     @\
    integer, intent(in), optional :: ungriddedLBound(:) @\
    integer, intent(in), optional :: ungriddedUBound(:) @\
    integer, intent(in), optional :: totalLWidth(:) @\
    integer, intent(in), optional :: totalUWidth(:) @\
    character (len=*), intent(in), optional :: name  @\
    integer, intent(out), optional :: rc                @\
@\
    ! local variables @\
    integer          :: localrc @\
@\
    if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
    localrc = ESMF_RC_NOT_IMPL @\
@\
    ESMF_FieldCreateGBData##mrank##D##mtypekind = & @\
        ESMF_FieldEmptyCreate(name=name, rc=localrc) @\
@\
    if (ESMF_LogFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
@\
    call ESMF_FieldEmptyComplete( & @\
        ESMF_FieldCreateGBData##mrank##D##mtypekind, & @\
        geom, farray, indexflag=indexflag, datacopyflag=datacopyflag, & @\
        gridToFieldMap=gridToFieldMap, & @\
        ungriddedLBound=ungriddedLBound, ungriddedUBound=ungriddedUBound, & @\
        totalLWidth=totalLWidth, totalUWidth=totalUWidth, & @\
        rc=localrc) @\
@\
    if (ESMF_LogFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
@\
    call ESMF_FieldValidate(ESMF_FieldCreateGBData##mrank##D##mtypekind, & @\
        rc=localrc) @\
@\
    if (ESMF_LogFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
@\
    if (present(rc)) rc = ESMF_SUCCESS @\
  end function ESMF_FieldCreateGBData##mrank##D##mtypekind  @\
!------------------------------------------------------------------------------ @\

TypeKindRankDeclarationMacro(FieldCreateGBData)

!------------------------------------------------------------------------------ @\


!------------------------------------------------------------------------------ @\

#define FieldCreateGBDataPtrDoc() \
!---------------------------------------------------------------------------- @\
!BOP @\
! !IROUTINE: ESMF_FieldCreate - Create a Field from Geom and Fortran array pointer @\
! @\
! !INTERFACE: @\
! ! Private name; call using ESMF_FieldCreate() @\
! function ESMF_FieldCreateGBDataPtr<rank><type><kind>(geom, & @\
!   farrayPtr, datacopyflag, gridToFieldMap, & @\
!   totalLWidth, totalUWidth, name, rc) @\
! @\
! !RETURN VALUE: @\
!   type(ESMF_Field) :: ESMF_FieldCreateGBDataPtr<rank><type><kind> @\
! @\
! !ARGUMENTS: @\
!   type(ESMF_Geom) :: geom                  @\
!   <type> (ESMF_KIND_<kind>), dimension(<rank>), pointer :: farrayPtr @\
!   type(ESMF_DataCopy_Flag), intent(in), optional   :: datacopyflag @\
!   integer, intent(in), optional :: gridToFieldMap(:)     @\
!   integer, intent(in), optional :: totalLWidth(:) @\
!   integer, intent(in), optional :: totalUWidth(:) @\
!   character (len=*), intent(in), optional :: name  @\
!   integer, intent(out), optional :: rc                @\
! @\
! !DESCRIPTION: @\
! Create an {\tt ESMF\_Field} from a Fortran data pointer and {\tt ESMF\_Geom}. @\
! The Fortran data pointer inside {\tt ESMF\_Field} can be queried and deallocated when @\
! datacopyflag is {\tt ESMF\_DATACOPY\_REFERENCE}. Note that the {\tt ESMF\_FieldDestroy} call does not @\
! deallocate the Fortran data pointer in this case. This gives user more flexibility over memory management. @\
! @\
! @\
! The arguments are: @\
! \begin{description} @\
! \item [geom]  @\
!       {\tt ESMF\_Geom} object.  The dimCount of the @\
!       Geom must be smaller than or equal to the rank of the {\tt farrayPtr}. @\
! \item [farrayPtr] @\
!       Native Fortran data pointer to be copied/referenced in the Field @\
!       The Field dimension (dimCount) will be the same as the dimCount @\
!       for the {\tt farrayPtr}. @\
! \item [{[datacopyflag]}] @\
!       Whether to copy the contents of the {\tt farrayPtr} or reference it directly. @\
!       For valid values see \ref{const:datacopyflag}.  The default is @\
!       {\tt ESMF\_DATACOPY\_REFERENCE}. @\
! \item [{[gridToFieldMap]}] @\
!       List with number of elements equal to the @\
!       {\tt grid}|s dimCount.  The list elements map each dimension @\
!       of the {\tt grid} to a dimension in the {\tt farrayPtr} by @\
!       specifying the appropriate {\tt farrayPtr} dimension index. The default is to @\
!       map all of the {\tt grid}|s dimensions against the lowest dimensions of @\
!       the {\tt farrayPtr} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../). @\
!       The values of all {\tt gridToFieldMap} entries must be greater than or equal @\
!       to one and smaller than or equal to the {\tt farrayPtr} rank. @\
!       It is erroneous to specify the same {\tt gridToFieldMap} entry @\
!       multiple times. The total ungridded dimensions in the {\tt field} @\
!       are the total {\tt farrayPtr} dimensions less @\
!       the total (distributed + undistributed) dimensions in @\
!       the {\tt grid}.  Ungridded dimensions must be in the same order they are @\
!       stored in the {\t farrayPtr}.  Permutations of the order of @\
!       dimensions are handled via individual communication methods.  For example, @\
!       an undistributed dimension can be remapped to a distributed dimension @\
!       as part of the {\tt ESMF\_ArrayRedist()} operation. @\
! \item [{[totalLWidth]}] @\
!       Lower bound of halo region.  The size of this array is the number @\
!       of gridded dimensions in the Field.  However, ordering of the elements @\
!       needs to be the same as they appear in the {\tt farrayPtr}.  Values default @\
!       to 0.  If values for totalLWidth are specified they must be reflected in @\
!       the size of the {\tt farrayPtr}.  That is, for each gridded dimension the @\
!       {\tt farrayPtr} size should be max( {\tt totalLWidth} + {\tt totalUWidth} @\
!       + {\tt computationalCount}, {\tt exclusiveCount} ). @\
! \item [{[totalUWidth]}] @\
!       Upper bound of halo region.  The size of this array is the number @\
!       of gridded dimensions in the Field.  However, ordering of the elements @\
!       needs to be the same as they appear in the {\tt farrayPtr}.  Values default @\
!       to 0.  If values for totalUWidth are specified they must be reflected in @\
!       the size of the {\tt farrayPtr}.  That is, for each gridded dimension the @\
!       {\tt farrayPtr} size should max( {\tt totalLWidth} + {\tt totalUWidth} @\
!       + {\tt computationalCount}, {\tt exclusiveCount} ). @\
! \item [{[name]}]  @\
!       Field name.  @\
! \item [{[rc]}]  @\
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
! \end{description} @\
! @\
!EOP @\
!---------------------------------------------------------------------------- @\

#define FieldCreateGBDataPtrMacro(mname, mtypekind, mrank, mdim, mlen, mrng, mloc) \
!---------------------------------------------------------------------------- @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_FieldCreateGBDataPtr" @\
  function ESMF_FieldCreateGBDataPtr##mrank##D##mtypekind(geom, & @\
    farrayPtr, datacopyflag, gridToFieldMap, & @\
    totalLWidth, totalUWidth, name, rc) @\
@\
    ! return value @\
    type(ESMF_Field) :: ESMF_FieldCreateGBDataPtr##mrank##D##mtypekind @\
@\
    ! input arguments @\
    type(ESMF_Geom) :: geom                  @\
    mname (ESMF_KIND_##mtypekind), dimension(mdim), pointer :: farrayPtr @\
    type(ESMF_DataCopy_Flag), intent(in), optional   :: datacopyflag @\
    integer, intent(in), optional :: gridToFieldMap(:)     @\
    integer, intent(in), optional :: totalLWidth(:) @\
    integer, intent(in), optional :: totalUWidth(:) @\
    character (len=*), intent(in), optional :: name  @\
    integer, intent(out), optional :: rc                @\
@\
    ! local variables @\
    integer          :: localrc @\
@\
    if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
    localrc = ESMF_RC_NOT_IMPL @\
@\
    ESMF_FieldCreateGBDataPtr##mrank##D##mtypekind = & @\
        ESMF_FieldEmptyCreate(name=name, rc=localrc) @\
@\
    if (ESMF_LogFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
@\
    call ESMF_FieldEmptyComplete( & @\
        ESMF_FieldCreateGBDataPtr##mrank##D##mtypekind, & @\
        geom, farrayPtr, datacopyflag=datacopyflag, & @\
        gridToFieldMap=gridToFieldMap, & @\
        totalLWidth=totalLWidth, totalUWidth=totalUWidth, & @\
        rc=localrc) @\
@\
    if (ESMF_LogFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
@\
    call ESMF_FieldValidate(ESMF_FieldCreateGBDataPtr##mrank##D##mtypekind, & @\
        rc=localrc) @\
@\
    if (ESMF_LogFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
@\
    if (present(rc)) rc = ESMF_SUCCESS @\
  end function ESMF_FieldCreateGBDataPtr##mrank##D##mtypekind  @\
!------------------------------------------------------------------------------ @\

TypeKindRankDeclarationMacro(FieldCreateGBDataPtr)

!------------------------------------------------------------------------------

! ESMF_FieldCreateGr
!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_FieldCreateGridTKR"
!BOP
! !IROUTINE:   ESMF_FieldCreate - Create a Field from Grid and typekind

! !INTERFACE:
  ! Private name; call using ESMF_FieldCreate()
  function ESMF_FieldCreateGridTKR(grid, typekind, keywordEnforcer, &
    indexflag, staggerloc, gridToFieldMap, ungriddedLBound, ungriddedUBound, &
    totalLWidth, totalUWidth, pinflag, name, rc)
!
! !RETURN VALUE:
    type(ESMF_Field) :: ESMF_FieldCreateGridTKR
!
! !ARGUMENTS:
    type(ESMF_Grid),         intent(in)            :: grid
    type(ESMF_TypeKind_Flag),intent(in)            :: typekind
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
    type(ESMF_Index_Flag),   intent(in),  optional :: indexflag
    type(ESMF_StaggerLoc),   intent(in),  optional :: staggerloc
    integer,                 intent(in),  optional :: gridToFieldMap(:)
    integer,                 intent(in),  optional :: ungriddedLBound(:)
    integer,                 intent(in),  optional :: ungriddedUBound(:)
    integer,                 intent(in),  optional :: totalLWidth(:)
    integer,                 intent(in),  optional :: totalUWidth(:)
    type(ESMF_Pin_Flag),     intent(in),  optional :: pinflag
    character (len=*),       intent(in),  optional :: name
    integer,                 intent(out), optional :: rc
!
! !STATUS:
! \begin{itemize}
! \item\apiStatusCompatibleVersion{5.2.0r}
! \item\apiStatusModifiedSinceVersion{5.2.0r}
! \begin{description}
! \item[8.1.0] Added argument {\tt pinflag} to provide access to DE sharing
!              between PETs.
! \end{description}
! \end{itemize}
!
! !DESCRIPTION:
! Create an {\tt ESMF\_Field} and allocate space internally for an
! {\tt ESMF\_Array}.  Return a new {\tt ESMF\_Field}. For an example and
! associated documentation using this method see section
! \ref{sec:field:usage:create_grid_tkr}.
!
! The arguments are:
! \begin{description}
! \item [grid]
!       {\tt ESMF\_Grid} object.
! \item[typekind]
!      The typekind of the Field. See section \ref{const:typekind}
!      for a list of valid typekind options.
! \item[{[indexflag]}]
!      Indicate how DE-local indices are defined. By default each DE|s
!      exclusive region is placed to start at the local index space origin,
!      i.e. (1, 1, ..., 1). Alternatively the DE-local index space can be
!      aligned with the global index space, if a global index space is well
!      defined by the associated Grid. See section \ref{const:indexflag}
!      for a list of valid indexflag options. The default indexflag value is the
!      one stored in then {\tt ESMF\_Grid} object. Currently it is
!      erroneous to specify an indexflag
!      different from the one stored in the {\tt ESMF\_Grid} object. The default
!      value is {\tt ESMF\_INDEX\_DELOCAL}
! \item [{[staggerloc]}]
!       Stagger location of data in grid cells.  For valid
!       predefined values see section \ref{const:staggerloc}.
!       To create a custom stagger location see section
!       \ref{sec:usage:staggerloc:adv}. The default
!       value is {\tt ESMF\_STAGGERLOC\_CENTER}.
! \item [{[gridToFieldMap]}]
!       List with number of elements equal to the
!       {\tt grid}|s dimCount.  The list elements map each dimension
!       of the {\tt grid} to a dimension in the {\tt field} by
!       specifying the appropriate {\tt field} dimension index. The default is to
!       map all of the {\tt grid}|s dimensions against the lowest dimensions of
!       the {\tt field} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../).
!       The values of all {\tt gridToFieldMap} entries must be greater than or equal
!       to one and smaller than or equal to the {\tt field} rank.
!       It is erroneous to specify the same {\tt gridToFieldMap} entry
!       multiple times. The total ungridded dimensions in the {\tt field}
!       are the total {\tt field} dimensions less
!       the dimensions in
!       the {\tt grid}.  Ungridded dimensions must be in the same order they are
!       stored in the {\t field}.
!       If the Field dimCount is less than the Grid dimCount then the default
!       gridToFieldMap will contain zeros for the rightmost entries. A zero
!       entry in the {\tt gridToFieldMap} indicates that the particular
!       Grid dimension will be replicating the Field across the DEs along
!       this direction.
! \item [{[ungriddedLBound]}]
!       Lower bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded
!       dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. When field dimension count is
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound
!       must be specified. When both are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt field}.
! \item [{[ungriddedUBound]}]
!       Upper bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded
!       dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. When field dimension count is
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound
!       must be specified. When both are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt field}.
! \item [{[totalLWidth]}]
!       Lower bound of halo region.  The size of this array is the number
!       of gridded dimensions in the Field.  However, ordering of the elements
!       needs to be the same as they appear in the {\tt field}.  Values default
!       to 0.  If values for totalLWidth are specified they must be reflected in
!       the size of the {\tt field}.  That is, for each gridded dimension the
!       {\tt field} size should be max( {\tt totalLWidth} + {\tt totalUWidth}
!       + {\tt computationalCount}, {\tt exclusiveCount} ).
! \item [{[totalUWidth]}]
!       Upper bound of halo region.  The size of this array is the number
!       of gridded dimensions in the Field.  However, ordering of the elements
!       needs to be the same as they appear in the {\tt field}.  Values default
!       to 0.  If values for totalUWidth are specified they must be reflected in
!       the size of the {\tt field}.  That is, for each gridded dimension the
!       {\tt field} size should max( {\tt totalLWidth} + {\tt totalUWidth}
!       + {\tt computationalCount}, {\tt exclusiveCount} ).
! \item[{[pinflag]}]
!      Specify which type of resource DEs are pinned to.  See section 
!      \ref{const:pin_flag} for a list of valid pinning options.
!      The default is to pin DEs to PETs, i.e. only the PET on which a DE
!      was created considers the DE as local.
! \item [{[name]}]
!       Field name.
! \item [{[rc]}]
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!EOP
!------------------------------------------------------------------------------
    integer :: localrc                          !  Local error code
    type(ESMF_ArraySpec) :: arrayspec
    integer :: rank, ungridded_dimcount, ungridded_ldimcount, ungridded_udimcount
    integer :: memDimCount, grid_repdimcount, i
    character(320)  :: msgString

    ! Initialize
    localrc = ESMF_RC_NOT_IMPL

    ! Initialize return code
    if(present(rc)) rc = ESMF_RC_NOT_IMPL

    ! Compute rank
    ungridded_dimcount = 0
    if(present(ungriddedLBound)) then
      ungridded_ldimcount = size(ungriddedLBound)
      ungridded_dimcount = ungridded_ldimcount
    endif
    if(present(ungriddedUBound)) then
      ungridded_udimcount = size(ungriddedUBound)
      ungridded_dimcount = ungridded_udimcount
    endif

    if(present(ungriddedLBound) .and. present(ungriddedUBound)) then
      if(ungridded_ldimcount /= ungridded_udimcount) then
        call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, &
          msg="- ungriddedLBound size must equal to ungriddedUBound size", &
          ESMF_CONTEXT, rcToReturn=rc)
        return
      endif
    endif

    call ESMF_GridGet(grid, rank=memDimCount, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
        ESMF_CONTEXT, rcToReturn=rc)) return

    grid_repdimcount = 0
    if (present(gridToFieldMap)) then
       do i = 1, size(gridToFieldMap)
           if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1
       enddo
    endif

    rank = ungridded_dimcount + memDimCount - grid_repdimcount

#ifdef DEBUGGING
    write(msgString,*) "ESMF_FieldCreateGridTKR(): rank=", rank, &
      "ungridded_dimcount=", ungridded_dimcount, "memDimCount=", memDimCount, &
      "grid_repdimcount=", grid_repdimcount
    call ESMF_LogWrite(msgString, ESMF_LOGMSG_INFO, rc=rc)
#endif

    ! Set ArraySpec from rank and typekind input
    call ESMF_ArraySpecSet(arrayspec, rank=rank, typekind=typekind, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
        ESMF_CONTEXT, rcToReturn=rc)) return

    ESMF_FieldCreateGridTKR = ESMF_FieldCreate(grid, arrayspec, &
      indexflag=indexflag, staggerloc=staggerloc, &
      gridToFieldMap=gridToFieldMap, ungriddedLBound=ungriddedLBound, &
      ungriddedUBound=ungriddedUBound, totalLWidth=totalLWidth, &
      totalUWidth=totalUWidth, pinflag=pinflag, name=name, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
        ESMF_CONTEXT, rcToReturn=rc)) return

    ! Return successfully
    if (present(rc)) rc = ESMF_SUCCESS

end function ESMF_FieldCreateGridTKR

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_FieldCreateGridArraySpec"
!BOP
! !IROUTINE:   ESMF_FieldCreate - Create a Field from Grid and ArraySpec

! !INTERFACE:
  ! Private name; call using ESMF_FieldCreate()
  function ESMF_FieldCreateGridArraySpec(grid, arrayspec, keywordEnforcer, &
    indexflag, staggerloc, gridToFieldMap, ungriddedLBound, &
    ungriddedUBound, totalLWidth, totalUWidth, pinflag, name, rc)
!
! !RETURN VALUE:
    type(ESMF_Field) :: ESMF_FieldCreateGridArraySpec
!
! !ARGUMENTS:
    type(ESMF_Grid),       intent(in)            :: grid
    type(ESMF_ArraySpec),  intent(in)            :: arrayspec
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
    type(ESMF_Index_Flag), intent(in),  optional :: indexflag
    type(ESMF_StaggerLoc), intent(in),  optional :: staggerloc
    integer,               intent(in),  optional :: gridToFieldMap(:)
    integer,               intent(in),  optional :: ungriddedLBound(:)
    integer,               intent(in),  optional :: ungriddedUBound(:)
    integer,               intent(in),  optional :: totalLWidth(:)
    integer,               intent(in),  optional :: totalUWidth(:)
    type(ESMF_Pin_Flag),   intent(in),  optional :: pinflag
    character (len=*),     intent(in),  optional :: name
    integer,               intent(out), optional :: rc
!
! !STATUS:
! \begin{itemize}
! \item\apiStatusCompatibleVersion{5.2.0r}
! \item\apiStatusModifiedSinceVersion{5.2.0r}
! \begin{description}
! \item[8.1.0] Added argument {\tt pinflag} to provide access to DE sharing
!              between PETs.
! \end{description}
! \end{itemize}
!
! !DESCRIPTION:
! Create an {\tt ESMF\_Field} and allocate space internally for an
! {\tt ESMF\_Array}.  Return a new {\tt ESMF\_Field}. For an example and
! associated documentation using this method see section
! \ref{sec:field:usage:create_grid_arrayspec}.
!
! The arguments are:
! \begin{description}
! \item [grid]
!       {\tt ESMF\_Grid} object.
! \item [arrayspec]
!       Data type and kind specification.
! \item[{[indexflag]}]
!      Indicate how DE-local indices are defined. By default each DE|s
!      exclusive region is placed to start at the local index space origin,
!      i.e. (1, 1, ..., 1). Alternatively the DE-local index space can be
!      aligned with the global index space, if a global index space is well
!      defined by the associated Grid. See section \ref{const:indexflag}
!      for a list of valid indexflag options. The default indexflag value is the
!      one stored in then {\tt ESMF\_Grid} object. Currently it is
!      erroneous to specify an indexflag
!      different from the one stored in the {\tt ESMF\_Grid} object.The default
!      value is {\tt ESMF\_INDEX\_DELOCAL}
! \item [{[staggerloc]}]
!       Stagger location of data in grid cells.  For valid
!       predefined values see section \ref{const:staggerloc}.
!       To create a custom stagger location see section
!       \ref{sec:usage:staggerloc:adv}. The default
!       value is {\tt ESMF\_STAGGERLOC\_CENTER}.
! \item [{[gridToFieldMap]}]
!       List with number of elements equal to the
!       {\tt grid}|s dimCount.  The list elements map each dimension
!       of the {\tt grid} to a dimension in the {\tt field} by
!       specifying the appropriate {\tt field} dimension index. The default is to
!       map all of the {\tt grid}|s dimensions against the lowest dimensions of
!       the {\tt field} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../).
!       The values of all {\tt gridToFieldMap} entries must be greater than or equal
!       to one and smaller than or equal to the {\tt field} rank.
!       It is erroneous to specify the same {\tt gridToFieldMap} entry
!       multiple times. The total ungridded dimensions in the {\tt field}
!       are the total {\tt field} dimensions less
!       the dimensions in
!       the {\tt grid}.  Ungridded dimensions must be in the same order they are
!       stored in the {\t field}.
!       If the Field dimCount is less than the Grid dimCount then the default
!       gridToFieldMap will contain zeros for the rightmost entries. A zero
!       entry in the {\tt gridToFieldMap} indicates that the particular
!       Grid dimension will be replicating the Field across the DEs along
!       this direction.
! \item [{[ungriddedLBound]}]
!       Lower bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded
!       dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. When field dimension count is
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound
!       must be specified. When both are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt field}.
! \item [{[ungriddedUBound]}]
!       Upper bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded
!       dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. When field dimension count is
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound
!       must be specified. When both are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt field}.
! \item [{[totalLWidth]}]
!       Lower bound of halo region.  The size of this array is the number
!       of gridded dimensions in the Field.  However, ordering of the elements
!       needs to be the same as they appear in the {\tt field}.  Values default
!       to 0.  If values for totalLWidth are specified they must be reflected in
!       the size of the {\tt field}.  That is, for each gridded dimension the
!       {\tt field} size should be max( {\tt totalLWidth} + {\tt totalUWidth}
!       + {\tt computationalCount}, {\tt exclusiveCount} ).
! \item [{[totalUWidth]}]
!       Upper bound of halo region.  The size of this array is the number
!       of gridded dimensions in the Field.  However, ordering of the elements
!       needs to be the same as they appear in the {\tt field}.  Values default
!       to 0.  If values for totalUWidth are specified they must be reflected in
!       the size of the {\tt field}.  That is, for each gridded dimension the
!       {\tt field} size should max( {\tt totalLWidth} + {\tt totalUWidth}
!       + {\tt computationalCount}, {\tt exclusiveCount} ).
! \item[{[pinflag]}]
!      Specify which type of resource DEs are pinned to.  See section 
!      \ref{const:pin_flag} for a list of valid pinning options.
!      The default is to pin DEs to PETs, i.e. only the PET on which a DE
!      was created considers the DE as local.
! \item [{[name]}]
!       Field name.
! \item [{[rc]}]
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!EOP
!------------------------------------------------------------------------------
    integer :: localrc                          !  Local error code
    type(ESMF_Geom) :: geom
    type(ESMF_Index_Flag)   :: g_indexflag
    type(ESMF_GridDecompType) :: decompType

    ! Initialize
    localrc = ESMF_RC_NOT_IMPL

    ! Initialize return code
    if(present(rc)) then
      rc = ESMF_RC_NOT_IMPL
    endif

    ! check init status of input parameters
    ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc)
    ESMF_INIT_CHECK_SHALLOW(ESMF_ArraySpecGetInit, arrayspec, rc)

    call ESMF_GridGetDecompType(grid, decompType, rc=localrc)
    if (ESMF_LogFoundError(localrc, &
        ESMF_ERR_PASSTHRU, &
        ESMF_CONTEXT, rcToReturn=rc)) return

    if (decompType .eq. ESMF_GRID_ARBITRARY) then
        if ((present(indexflag)) .or. (present(totalLWidth)) .or. (present(totalUWidth))) then
          call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, &
                 msg="- indexflag, totalLWidth or totalUWidth are not allowed for arbitrary grid", &
                 ESMF_CONTEXT, rcToReturn=rc)
           return
        endif
    endif

    call ESMF_GridGet(grid, indexFlag=g_indexflag, rc=localrc)
    if (ESMF_LogFoundError(localrc, &
        ESMF_ERR_PASSTHRU, &
        ESMF_CONTEXT, rcToReturn=rc)) return

    if (present(indexflag)) then
      if(.not. (g_indexflag .eq. indexflag)) then
        call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_SIZE, &
             msg="- user specified indexflag must be identical with Grid indexflag", &
               ESMF_CONTEXT, rcToReturn=rc)
        return
      endif
    endif

    ! Error check staggerloc
    if (present(staggerloc)) then
       if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. &
            (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then
          call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, &
               msg="- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", &
               ESMF_CONTEXT, rcToReturn=rc)
          return
       endif
    endif
       
    ! Create Geom from Grid
    geom=ESMF_GeomCreate(grid, staggerloc, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
      ESMF_CONTEXT, rcToReturn=rc)) return

    ! Create Field from Geom
    ESMF_FieldCreateGridArraySpec=ESMF_FieldCreateGBArraySpec(geom, &
        arrayspec, gridToFieldMap, &
        ungriddedLBound, ungriddedUBound, &
        totalLWidth, totalUWidth, pinflag=pinflag, name=name, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
      ESMF_CONTEXT, rcToReturn=rc)) return

    ! remember that geom was created internally
    ESMF_FieldCreateGridArraySpec%ftypep%geomb_internal = .true.

    if(present(rc)) rc = ESMF_SUCCESS

  end function ESMF_FieldCreateGridArraySpec
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_FieldCreateGridArray"
!BOP
! !IROUTINE: ESMF_FieldCreate - Create a Field from Grid and Array

! !INTERFACE:
  ! Private name; call using ESMF_FieldCreate()
  function ESMF_FieldCreateGridArray(grid, array, keywordEnforcer, datacopyflag, &
    staggerloc, gridToFieldMap, ungriddedLBound, ungriddedUBound, &
    totalLWidth, totalUWidth, name, vm, rc)
!
! !RETURN VALUE:
    type(ESMF_Field) :: ESMF_FieldCreateGridArray
!
! !ARGUMENTS:
    type(ESMF_Grid),       intent(in)            :: grid
    type(ESMF_Array),      intent(in)            :: array
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
    type(ESMF_DataCopy_Flag),   intent(in),  optional :: datacopyflag
    type(ESMF_StaggerLoc), intent(in),  optional :: staggerloc
    integer,               intent(in),  optional :: gridToFieldMap(:)
    integer,               intent(in),  optional :: ungriddedLBound(:)
    integer,               intent(in),  optional :: ungriddedUBound(:)
    integer,               intent(in),  optional :: totalLWidth(:)
    integer,               intent(in),  optional :: totalUWidth(:)
    character (len = *),   intent(in),  optional :: name
    type(ESMF_VM),         intent(in),  optional :: vm
    integer,               intent(out), optional :: rc
!
! !STATUS:
! \begin{itemize}
! \item\apiStatusCompatibleVersion{5.2.0r}
! \item\apiStatusModifiedSinceVersion{5.2.0r}
! \begin{description}
! \item[8.0.0] Added argument {\tt vm} to support object creation on a
!              different VM than that of the current context.
! \end{description}
! \end{itemize}
!
! !DESCRIPTION:
! Create an {\tt ESMF\_Field}.  This version of creation
! assumes the data exists already and is being
! passed in through an {\tt ESMF\_Array}.  For an example and
! associated documentation using this method see section
! \ref{sec:field:usage:create_grid_array}.
!
! The arguments are:
! \begin{description}
! \item [grid]
!       {\tt ESMF\_Grid} object.
! \item [array]
!       {\tt ESMF\_Array} object.
! \item [{[datacopyflag]}]
!       Indicates whether to copy the contents of the {\tt array} or reference it directly.
!       For valid values see \ref{const:datacopyflag}.  The default is
!       {\tt ESMF\_DATACOPY\_REFERENCE}.
! \item [{[staggerloc]}]
!       Stagger location of data in grid cells.  For valid
!       predefined values see section \ref{const:staggerloc}.
!       To create a custom stagger location see section
!       \ref{sec:usage:staggerloc:adv}. The default
!       value is {\tt ESMF\_STAGGERLOC\_CENTER}.
! \item [{[gridToFieldMap]}]
!       List with number of elements equal to the
!       {\tt grid}|s dimCount.  The list elements map each dimension
!       of the {\tt grid} to a dimension in the {\tt field} by
!       specifying the appropriate {\tt field} dimension index. The default is to
!       map all of the {\tt grid}|s dimensions against the lowest dimensions of
!       the {\tt field} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../).
!       The values of all {\tt gridToFieldMap} entries must be greater than or equal
!       to one and smaller than or equal to the {\tt field} rank.
!       It is erroneous to specify the same {\tt gridToFieldMap} entry
!       multiple times. The total ungridded dimensions in the {\tt field}
!       are the total {\tt field} dimensions less
!       the dimensions in
!       the {\tt grid}.  Ungridded dimensions must be in the same order they are
!       stored in the {\t field}.
!       If the Field dimCount is less than the Grid dimCount then the default
!       gridToFieldMap will contain zeros for the rightmost entries. A zero
!       entry in the {\tt gridToFieldMap} indicates that the particular
!       Grid dimension will be replicating the Field across the DEs along
!       this direction.
! \item [{[ungriddedLBound]}]
!       Lower bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded
!       dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. When field dimension count is
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound
!       must be specified. When both are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt field}.
! \item [{[ungriddedUBound]}]
!       Upper bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded
!       dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. When field dimension count is
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound
!       must be specified. When both are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt field}.
! \item [{[totalLWidth]}]
!       Lower bound of halo region.  The size of this array is the number
!       of gridded dimensions in the Field.  However, ordering of the elements
!       needs to be the same as they appear in the {\tt field}.  Values default
!       to 0.  If values for totalLWidth are specified they must be reflected in
!       the size of the {\tt field}.  That is, for each gridded dimension the
!       {\tt field} size should be max( {\tt totalLWidth} + {\tt totalUWidth}
!       + {\tt computationalCount}, {\tt exclusiveCount} ).
! \item [{[totalUWidth]}]
!       Upper bound of halo region.  The size of this array is the number
!       of gridded dimensions in the Field.  However, ordering of the elements
!       needs to be the same as they appear in the {\tt field}.  Values default
!       to 0.  If values for totalUWidth are specified they must be reflected in
!       the size of the {\tt field}.  That is, for each gridded dimension the
!       {\tt field} size should max( {\tt totalLWidth} + {\tt totalUWidth}
!       + {\tt computationalCount}, {\tt exclusiveCount} ).
! \item [{[name]}]
!       Field name.
! \item[{[vm]}]
!       If present, the Field object is constructed on the specified
!       {\tt ESMF\_VM} object. The default is to construct on the VM of the
!       current component context.
! \item [{[rc]}]
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!EOP
!------------------------------------------------------------------------------
    integer :: localrc                       !  Local error code
    type(ESMF_Geom) :: geom
    type(ESMF_GridDecompType) :: decompType
    type(ESMF_Pointer)                    :: vmThis
    logical                               :: actualFlag

    ! Initialize
    localrc = ESMF_RC_NOT_IMPL

    ! Initialize return code
    if (present(rc)) then
      rc = ESMF_RC_NOT_IMPL
    endif

    ! Must make sure the local PET is associated with an actual member
    actualFlag = .true.
    if (present(vm)) then
      ESMF_INIT_CHECK_DEEP(ESMF_VMGetInit, vm, rc)
      call ESMF_VMGetThis(vm, vmThis)
      if (vmThis == ESMF_NULL_POINTER) then
        actualFlag = .false.  ! local PET is not for an actual member
      endif
    endif

    if (actualFlag) then

      ! check init status of input parameters
      ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc)
      ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc)

      call ESMF_GridGetDecompType(grid, decompType, rc=localrc)
      if (ESMF_LogFoundError(localrc, &
          ESMF_ERR_PASSTHRU, &
          ESMF_CONTEXT, rcToReturn=rc)) return

      if (decompType .eq. ESMF_GRID_ARBITRARY) then
          if ((present(totalLWidth)) .or. (present(totalUWidth))) then
            call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, &
                   msg="- indexflag, totalLWidth or totalUWidth are not allowed for arbitrary grid", &
                   ESMF_CONTEXT, rcToReturn=rc)
             return
          endif
      endif

      ! Error check staggerloc
      if (present(staggerloc)) then
         if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. &
              (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then
            call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, &
                 msg="- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", &
                 ESMF_CONTEXT, rcToReturn=rc)
            return
         endif
      endif
          
      ! Create Geom from Grid
      geom=ESMF_GeomCreate(grid, staggerloc, rc=localrc)
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
           ESMF_CONTEXT, rcToReturn=rc)) return
      
   endif ! - actualFlag

    ! Create Field from Geom
    ESMF_FieldCreateGridArray=ESMF_FieldCreateGBArray(geom, array, datacopyflag, &
        gridToFieldMap, ungriddedLBound, ungriddedUBound, totalLWidth, &
        totalUWidth, name=name, vm=vm, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
        ESMF_CONTEXT, rcToReturn=rc)) return

    if (actualFlag) then

      ! remember that geom was created internally
      ESMF_FieldCreateGridArray%ftypep%geomb_internal = .true.

    endif ! - actualFlag

    if (present(rc)) rc = ESMF_SUCCESS

  end function ESMF_FieldCreateGridArray
!------------------------------------------------------------------------------


#define FieldCreateGridDataDoc() \
!---------------------------------------------------------------------------- @\
!BOP @\
! !IROUTINE: ESMF_FieldCreate - Create a Field from Grid and Fortran array @\
! @\
! !INTERFACE: @\
! ! Private name; call using ESMF_FieldCreate() @\
! function ESMF_FieldCreateGridData<rank><type><kind>(grid, & @\
!   farray, indexflag, keywordEnforcer, datacopyflag, staggerloc, & @\
!   gridToFieldMap, ungriddedLBound, ungriddedUBound, & @\
!   totalLWidth, totalUWidth, name, rc) @\
! @\
! !RETURN VALUE: @\
!   type(ESMF_Field) :: ESMF_FieldCreateGridData<rank><type><kind> @\
! @\
! !ARGUMENTS: @\
!   type(ESMF_Grid),          intent(in)            :: grid           @\
!   <type> (ESMF_KIND_<kind>),intent(in),  target   :: farray(<rank>) @\
!   type(ESMF_Index_Flag),    intent(in)            :: indexflag      @\
!type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below @\
!   type(ESMF_DataCopy_Flag), intent(in),  optional :: datacopyflag @\
!   type(ESMF_StaggerLoc),    intent(in),  optional :: staggerloc  @\
!   integer,                  intent(in),  optional :: gridToFieldMap(:)  @\
!   integer,                  intent(in),  optional :: ungriddedLBound(:) @\
!   integer,                  intent(in),  optional :: ungriddedUBound(:) @\
!   integer,                  intent(in),  optional :: totalLWidth(:) @\
!   integer,                  intent(in),  optional :: totalUWidth(:) @\
!   character (len=*),        intent(in),  optional :: name  @\
!   integer,                  intent(out), optional :: rc             @\
! @\
! !STATUS: @\
! \begin{itemize} @\
! \item\apiStatusCompatibleVersion{5.2.0r} @\
! \end{itemize} @\
! @\
! !DESCRIPTION: @\
! Create an {\tt ESMF\_Field} from a Fortran data array and {\tt ESMF\_Grid}. @\
! The Fortran data pointer inside {\tt ESMF\_Field} can be queried but deallocating @\
! the retrieved data pointer is not allowed. @\
! For examples and @\
! associated documentation regarding this method see section  @\
! \ref{sec:field:usage:create_2darray}, @\
! \ref{sec:field:usage:create_2dgrid_3dptr}, @\
! \ref{sec:field:usage:create_2dgrid_3dptr_map}, @\
! \ref{sec:field:usage:create_2dgrid_3dptr_map_halo}, and @\
! \ref{sec:field:usage:create_5dgrid_7dptr_2dungridded}. @\
! @\
! The arguments are: @\
! \begin{description} @\
! \item [grid]  @\
!       {\tt ESMF\_Grid} object. @\
! \item [farray] @\
!       Native Fortran data array to be copied/referenced in the Field @\
!       The Field dimension (dimCount) will be the same as the dimCount @\
!       for the {\tt farray}. @\
! \item[indexflag] @\
!       Indicate how DE-local indices are defined. See section @\
!       \ref{const:indexflag} for a list of valid indexflag options. @\
!       Currently it is erroneous to specify an indexflag @\
!       different from the one stored in the {\tt ESMF\_Grid} object. @\
! \item [{[datacopyflag]}] @\
!       Whether to copy the contents of the {\tt farray} or reference it directly. @\
!       For valid values see \ref{const:datacopyflag}.  The default is @\
!       {\tt ESMF\_DATACOPY\_REFERENCE}. @\
! \item [{[staggerloc]}] @\
!       Stagger location of data in grid cells.  For valid  @\
!       predefined values see section \ref{const:staggerloc}. @\
!       To create a custom stagger location see section @\
!       \ref{sec:usage:staggerloc:adv}.  The default @\
!       value is {\tt ESMF\_STAGGERLOC\_CENTER}. @\
! \item [{[gridToFieldMap]}] @\
!       List with number of elements equal to the @\
!       {\tt grid}|s dimCount.  The list elements map each dimension @\
!       of the {\tt grid} to a dimension in the {\tt farray} by @\
!       specifying the appropriate {\tt farray} dimension index. The default is to @\
!       map all of the {\tt grid}|s dimensions against the lowest dimensions of @\
!       the {\tt farray} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../). @\
!       The values of all {\tt gridToFieldMap} entries must be greater than or equal @\
!       to one and smaller than or equal to the {\tt farray} rank. @\
!       It is erroneous to specify the same {\tt gridToFieldMap} entry @\
!       multiple times. The total ungridded dimensions in the {\tt field} @\
!       are the total {\tt farray} dimensions less @\
!       the total (distributed + undistributed) dimensions in @\
!       the {\tt grid}.  Ungridded dimensions must be in the same order they are @\
!       stored in the {\t farray}.  Permutations of the order of @\
!       dimensions are handled via individual communication methods.  For example, @\
!       an undistributed dimension can be remapped to a distributed dimension @\
!       as part of the {\tt ESMF\_ArrayRedist()} operation. @\
!       If the Field dimCount is less than the Grid dimCount then the default @\
!       gridToFieldMap will contain zeros for the rightmost entries. A zero @\
!       entry in the {\tt gridToFieldMap} indicates that the particular @\
!       Grid dimension will be replicating the Field across the DEs along @\
!       this direction. @\
! \item [{[ungriddedLBound]}] @\
!       Lower bounds of the ungridded dimensions of the {\tt field}. @\
!       The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded @\
!       dimensions in the {\tt field}.  All ungridded dimensions of the @\
!       {\tt field} are also undistributed. When field dimension count is @\
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound @\
!       must be specified. When both are specified the values are checked @\
!       for consistency.  Note that the the ordering of @\
!       these ungridded dimensions is the same as their order in the {\tt farray}. @\
! \item [{[ungriddedUBound]}] @\
!       Upper bounds of the ungridded dimensions of the {\tt field}. @\
!       The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded @\
!       dimensions in the {\tt field}.  All ungridded dimensions of the @\
!       {\tt field} are also undistributed. When field dimension count is @\
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound @\
!       must be specified. When both are specified the values are checked @\
!       for consistency.  Note that the the ordering of @\
!       these ungridded dimensions is the same as their order in the {\tt farray}. @\
! \item [{[totalLWidth]}] @\
!       Lower bound of halo region.  The size of this array is the number @\
!       of gridded dimensions in the Field.  However, ordering of the elements @\
!       needs to be the same as they appear in the {\tt farray}.  Values default @\
!       to 0.  If values for totalLWidth are specified they must be reflected in @\
!       the size of the {\tt farray}.  That is, for each gridded dimension the @\
!       {\tt farray} size should be max( {\tt totalLWidth} + {\tt totalUWidth} @\
!       + {\tt computationalCount}, {\tt exclusiveCount} ). @\
! \item [{[totalUWidth]}] @\
!       Upper bound of halo region.  The size of this array is the number @\
!       of gridded dimensions in the Field.  However, ordering of the elements @\
!       needs to be the same as they appear in the {\tt farray}.  Values default @\
!       to 0.  If values for totalUWidth are specified they must be reflected in @\
!       the size of the {\tt farray}.  That is, for each gridded dimension the @\
!       {\tt farray} size should max( {\tt totalLWidth} + {\tt totalUWidth} @\
!       + {\tt computationalCount}, {\tt exclusiveCount} ). @\
! \item [{[name]}]  @\
!       Field name.  @\
! \item [{[rc]}]  @\
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
! \end{description} @\
! @\
!EOP @\
!---------------------------------------------------------------------------- @\

#define FieldCreateGridDataMacro(mname, mtypekind, mrank, mdim, mlen, mrng, mloc) \
!---------------------------------------------------------------------------- @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_FieldCreateGridData" @\
  function ESMF_FieldCreateGridData##mrank##D##mtypekind(grid, & @\
    farray, indexflag, keywordEnforcer, datacopyflag, staggerloc, & @\
    gridToFieldMap, ungriddedLBound, & @\
    ungriddedUBound, totalLWidth, totalUWidth, name, rc) @\
@\
    ! return value @\
    type(ESMF_Field) :: ESMF_FieldCreateGridData##mrank##D##mtypekind @\
@\
    ! input arguments @\
    type(ESMF_Grid),         intent(in)            :: grid @\
    mname (ESMF_KIND_##mtypekind), intent(in), target :: farray(mdim) @\
    type(ESMF_Index_Flag),   intent(in)            :: indexflag @\
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below @\
    type(ESMF_DataCopy_Flag),intent(in),  optional :: datacopyflag @\
    type(ESMF_StaggerLoc),   intent(in),  optional :: staggerloc @\
    integer,                 intent(in),  optional :: gridToFieldMap(:) @\
    integer,                 intent(in),  optional :: ungriddedLBound(:) @\
    integer,                 intent(in),  optional :: ungriddedUBound(:) @\
    integer,                 intent(in),  optional :: totalLWidth(:) @\
    integer,                 intent(in),  optional :: totalUWidth(:) @\
    character (len=*),       intent(in),  optional :: name @\
    integer,                 intent(out), optional :: rc @\
@\
    integer :: localrc                       !  Local error code@\
    type(ESMF_Geom) :: geom @\
    type(ESMF_GridDecompType)      :: decompType @\
@\
    ! Initialize @\
    localrc = ESMF_RC_NOT_IMPL@\
@\
    ! Initialize return code   @\
    if (present(rc)) then@\
      rc = ESMF_RC_NOT_IMPL@\
    endif     @\
@\
    ! check init status of input parameters@\
    ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc)@\
@\
@\
    call ESMF_GridGetDecompType(grid, decompType, rc=localrc) @\
    if (ESMF_LogFoundError(localrc, &   @\
        ESMF_ERR_PASSTHRU, &   @\
        ESMF_CONTEXT, rcToReturn=rc)) return   @\
@\
    if (decompType .eq. ESMF_GRID_ARBITRARY) then @\
        if ((present(totalLWidth)) .or. (present(totalUWidth))) then @\
          call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, &  @\
            msg="- indexflag, totalLWidth or totalUWidth are not allowed for arbitrary grid", & @\
            ESMF_CONTEXT, rcToReturn=rc)  @\
           return @\
        endif @\
    endif @\
    ! Error check staggerloc  @\
    if (present(staggerloc)) then @\
       if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & @\
          (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then @\
           call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, &  @\
                 msg="- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", &  @\
                 ESMF_CONTEXT, rcToReturn=rc)  @\
           return @\
         endif @\
    endif   @\
@\
    ! Create Geom from Grid@\
    geom=ESMF_GeomCreate(grid, staggerloc, rc=localrc)@\
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &@\
      ESMF_CONTEXT, rcToReturn=rc)) return@\
@\
@\
       ESMF_FieldCreateGridData##mrank##D##mtypekind = & @\
              ESMF_FieldCreateGBData##mrank##D##mtypekind(geom, & @\
                               farray, indexflag=indexflag, datacopyflag=datacopyflag, & @\
                               gridToFieldMap=gridToFieldMap, & @\
                               ungriddedLBound=ungriddedLBound, & @\
                               ungriddedUBound=ungriddedUBound, & @\
                               totalLWidth=totalLWidth, totalUWidth=totalUWidth, & @\
                               name=name, rc=localrc) @\
    if (ESMF_LogFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
@\
    ! remember that geom was created internally @\
    ESMF_FieldCreateGridData##mrank##D##mtypekind%ftypep%geomb_internal = .true. @\
@\
    if (present(rc)) rc = ESMF_SUCCESS @\
  end function ESMF_FieldCreateGridData##mrank##D##mtypekind  @\
!------------------------------------------------------------------------------ @\

TypeKindRankDeclarationMacro(FieldCreateGridData)


#define FieldCreateGridDataPtrDoc() \
!---------------------------------------------------------------------------- @\
!BOP @\
! !IROUTINE: ESMF_FieldCreate - Create a Field from Grid and Fortran array pointer @\
! @\
! !INTERFACE: @\
! ! Private name; call using ESMF_FieldCreate() @\
! function ESMF_FieldCreateGridDataPtr<rank><type><kind>(grid, & @\
!   farrayPtr, keywordEnforcer, datacopyflag, staggerloc, gridToFieldMap, & @\
!   totalLWidth, totalUWidth, name, rc) @\
! @\
! !RETURN VALUE: @\
!   type(ESMF_Field) :: ESMF_FieldCreateGridDataPtr<rank><type><kind> @\
! @\
! !ARGUMENTS: @\
!   type(ESMF_Grid),           intent(in)            :: grid              @\
!   <type> (ESMF_KIND_<kind>), pointer               :: farrayPtr(<rank>) @\
!type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below @\
!   type(ESMF_DataCopy_Flag),  intent(in),  optional :: datacopyflag @\
!   type(ESMF_StaggerLoc),     intent(in),  optional :: staggerloc  @\
!   integer,                   intent(in),  optional :: gridToFieldMap(:)     @\
!   integer,                   intent(in),  optional :: totalLWidth(:) @\
!   integer,                   intent(in),  optional :: totalUWidth(:) @\
!   character (len=*),         intent(in),  optional :: name  @\
!   integer,                   intent(out), optional :: rc                @\
! @\
! !STATUS: @\
! \begin{itemize} @\
! \item\apiStatusCompatibleVersion{5.2.0r} @\
! \end{itemize} @\
! @\
! !DESCRIPTION: @\
! Create an {\tt ESMF\_Field} from a Fortran data pointer and {\tt ESMF\_Grid}. @\
! The Fortran data pointer inside {\tt ESMF\_Field} can be queried and deallocated when @\
! datacopyflag is {\tt ESMF\_DATACOPY\_REFERENCE}. Note that the {\tt ESMF\_FieldDestroy} call does not @\
! deallocate the Fortran data pointer in this case. This gives user more flexibility over memory management. @\
! @\
! For examples and @\
! associated documentation regarding this method see section  @\
! \ref{sec:field:usage:create_2dptr}, @\
! \ref{sec:field:usage:create_2dgrid_3dptr}, @\
! \ref{sec:field:usage:create_2dgrid_3dptr_map}, @\
! \ref{sec:field:usage:create_2dgrid_3dptr_map_halo}, and @\
! \ref{sec:field:usage:create_5dgrid_7dptr_2dungridded}. @\
! @\
! The arguments are: @\
! \begin{description} @\
! \item [grid]  @\
!       {\tt ESMF\_Grid} object. @\
! \item [farrayPtr] @\
!       Native Fortran data pointer to be copied/referenced in the Field @\
!       The Field dimension (dimCount) will be the same as the dimCount @\
!       for the {\tt farrayPtr}. @\
! \item [{[datacopyflag]}] @\
!       Whether to copy the contents of the {\tt farrayPtr} or reference it directly. @\
!       For valid values see \ref{const:datacopyflag}.  The default is @\
!       {\tt ESMF\_DATACOPY\_REFERENCE}. @\
! \item [{[staggerloc]}] @\
!       Stagger location of data in grid cells.  For valid  @\
!       predefined values see section \ref{const:staggerloc}. @\
!       To create a custom stagger location see section @\
!       \ref{sec:usage:staggerloc:adv}.  The default @\
!       value is {\tt ESMF\_STAGGERLOC\_CENTER}. @\
! \item [{[gridToFieldMap]}] @\
!       List with number of elements equal to the @\
!       {\tt grid}|s dimCount.  The list elements map each dimension @\
!       of the {\tt grid} to a dimension in the {\tt farrayPtr} by @\
!       specifying the appropriate {\tt farrayPtr} dimension index. The default is to @\
!       map all of the {\tt grid}|s dimensions against the lowest dimensions of @\
!       the {\tt farrayPtr} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../). @\
!       The values of all {\tt gridToFieldMap} entries must be greater than or equal @\
!       to one and smaller than or equal to the {\tt farrayPtr} rank. @\
!       It is erroneous to specify the same {\tt gridToFieldMap} entry @\
!       multiple times. The total ungridded dimensions in the {\tt field} @\
!       are the total {\tt farrayPtr} dimensions less @\
!       the total (distributed + undistributed) dimensions in @\
!       the {\tt grid}.  Ungridded dimensions must be in the same order they are @\
!       stored in the {\t farrayPtr}.  Permutations of the order of @\
!       dimensions are handled via individual communication methods.  For example, @\
!       an undistributed dimension can be remapped to a distributed dimension @\
!       as part of the {\tt ESMF\_ArrayRedist()} operation. @\
!       If the Field dimCount is less than the Grid dimCount then the default @\
!       gridToFieldMap will contain zeros for the rightmost entries. A zero @\
!       entry in the {\tt gridToFieldMap} indicates that the particular @\
!       Grid dimension will be replicating the Field across the DEs along @\
!       this direction. @\
! \item [{[totalLWidth]}] @\
!       Lower bound of halo region.  The size of this array is the number @\
!       of gridded dimensions in the Field.  However, ordering of the elements @\
!       needs to be the same as they appear in the {\tt farrayPtr}.  Values default @\
!       to 0.  If values for totalLWidth are specified they must be reflected in @\
!       the size of the {\tt farrayPtr}.  That is, for each gridded dimension the @\
!       {\tt farrayPtr} size should be max( {\tt totalLWidth} + {\tt totalUWidth} @\
!       + {\tt computationalCount}, {\tt exclusiveCount} ). @\
! \item [{[totalUWidth]}] @\
!       Upper bound of halo region.  The size of this array is the number @\
!       of gridded dimensions in the Field.  However, ordering of the elements @\
!       needs to be the same as they appear in the {\tt farrayPtr}.  Values default @\
!       to 0.  If values for totalUWidth are specified they must be reflected in @\
!       the size of the {\tt farrayPtr}.  That is, for each gridded dimension the @\
!       {\tt farrayPtr} size should max( {\tt totalLWidth} + {\tt totalUWidth} @\
!       + {\tt computationalCount}, {\tt exclusiveCount} ). @\
! \item [{[name]}]  @\
!       Field name.  @\
! \item [{[rc]}]  @\
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
! \end{description} @\
! @\
!EOP @\
!---------------------------------------------------------------------------- @\

#define FieldCreateGridDataPtrMacro(mname, mtypekind, mrank, mdim, mlen, mrng, mloc) \
!---------------------------------------------------------------------------- @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_FieldCreateGridDataPtr" @\
  function ESMF_FieldCreateGridDataPtr##mrank##D##mtypekind(grid, & @\
    farrayPtr, keywordEnforcer, datacopyflag, staggerloc, gridToFieldMap, & @\
    totalLWidth, totalUWidth, name, rc) @\
@\
    ! return value @\
    type(ESMF_Field) :: ESMF_FieldCreateGridDataPtr##mrank##D##mtypekind @\
@\
    ! input arguments @\
    type(ESMF_Grid), intent(in) :: grid                  @\
    mname (ESMF_KIND_##mtypekind), dimension(mdim), pointer :: farrayPtr @\
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below @\
    type(ESMF_DataCopy_Flag), intent(in), optional   :: datacopyflag @\
    type(ESMF_StaggerLoc), intent(in), optional ::staggerloc  @\
    integer, intent(in), optional :: gridToFieldMap(:)     @\
    integer, intent(in), optional :: totalLWidth(:) @\
    integer, intent(in), optional :: totalUWidth(:) @\
    character (len=*), intent(in), optional :: name  @\
    integer, intent(out), optional :: rc                @\
@\
    integer :: localrc                       !  Local error code@\
    type(ESMF_Geom) :: geom @\
    type(ESMF_GridDecompType)      :: decompType @\
@\
    ! Initialize @\
    localrc = ESMF_RC_NOT_IMPL@\
@\
    ! Initialize return code   @\
    if (present(rc)) then@\
      rc = ESMF_RC_NOT_IMPL@\
    endif     @\
@\
    ! check init status of input parameters@\
    ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc)@\
@\
@\
    call ESMF_GridGetDecompType(grid, decompType, rc=localrc) @\
    if (ESMF_LogFoundError(localrc, &   @\
        ESMF_ERR_PASSTHRU, &   @\
        ESMF_CONTEXT, rcToReturn=rc)) return   @\
@\
    if (decompType .eq. ESMF_GRID_ARBITRARY) then @\
        if ((present(totalLWidth)) .or. (present(totalUWidth))) then @\
          call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, &  @\
            msg="- indexflag, totalLWidth or totalUWidth are not allowed for arbitrary grid", & @\
            ESMF_CONTEXT, rcToReturn=rc)  @\
           return @\
        endif @\
     endif@\
    ! Error check staggerloc  @\
    if (present(staggerloc)) then @\
       if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & @\
          (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then @\
           call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, &  @\
             msg="- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", &  @\
             ESMF_CONTEXT, rcToReturn=rc)  @\
           return @\
         endif @\
    endif   @\
@\
    ! Create Geom from Grid@\
    geom=ESMF_GeomCreate(grid, staggerloc, rc=localrc)@\
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &@\
      ESMF_CONTEXT, rcToReturn=rc)) return@\
@\
@\
       ESMF_FieldCreateGridDataPtr##mrank##D##mtypekind = & @\
              ESMF_FieldCreateGBDataPtr##mrank##D##mtypekind(geom, & @\
                               farrayPtr, datacopyflag=datacopyflag, & @\
                               gridToFieldMap=gridToFieldMap, & @\
                               totalLWidth=totalLWidth, totalUWidth=totalUWidth, & @\
                               name=name, rc=localrc) @\
    if (ESMF_LogFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
@\
    ! remember that geom was created internally @\
    ESMF_FieldCreateGridDataPtr##mrank##D##mtypekind%ftypep%geomb_internal = .true. @\
@\
    if (present(rc)) rc = ESMF_SUCCESS @\
  end function ESMF_FieldCreateGridDataPtr##mrank##D##mtypekind  @\
!------------------------------------------------------------------------------ @\

TypeKindRankDeclarationMacro(FieldCreateGridDataPtr)

!------------------------------------------------------------------------------

! ESMF_FieldCreateLo
!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_FieldCreateLSTKR"
!BOP
! !IROUTINE:   ESMF_FieldCreate - Create a Field from LocStream and typekind

! !INTERFACE:
  ! Private name; call using ESMF_FieldCreate()
  function ESMF_FieldCreateLSTKR(locstream, typekind, keywordEnforcer, &
    gridToFieldMap, ungriddedLBound, ungriddedUBound, pinflag, name, rc)
!
! !RETURN VALUE:
    type(ESMF_Field) :: ESMF_FieldCreateLSTKR
!
! !ARGUMENTS:
    type(ESMF_LocStream),    intent(in)            :: locstream
    type(ESMF_TypeKind_Flag),intent(in)            :: typekind
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
    integer,                 intent(in),  optional :: gridToFieldMap(:)
    integer,                 intent(in),  optional :: ungriddedLBound(:)
    integer,                 intent(in),  optional :: ungriddedUBound(:)
    type(ESMF_Pin_Flag),     intent(in),  optional :: pinflag
    character (len=*),       intent(in),  optional :: name
    integer,                 intent(out), optional :: rc
!
! !DESCRIPTION:
! Create an {\tt ESMF\_Field} and allocate space internally for an
! {\tt ESMF\_Array}.  Return a new {\tt ESMF\_Field}. For an example and
! associated documentation using this method see section
! \ref{sec:field:usage:create_locs_tkr}.
!
! The arguments are:
! \begin{description}
! \item [locstream]
!       {\tt ESMF\_LocStream} object.
! \item[typekind]
!       The typekind of the Field. See section \ref{const:typekind}
!       for a list of valid typekind options.
! \item [{[gridToFieldMap]}]
!       List with number of elements equal to the
!       {\tt grid}|s dimCount.  The list elements map each dimension
!       of the {\tt grid} to a dimension in the {\tt field} by
!       specifying the appropriate {\tt field} dimension index. The default is to
!       map all of the {\tt grid}|s dimensions against the lowest dimensions of
!       the {\tt field} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../).
!       The values of all {\tt gridToFieldMap} entries must be greater than or equal
!       to one and smaller than or equal to the {\tt field} rank.
!       It is erroneous to specify the same {\tt gridToFieldMap} entry
!       multiple times. The total ungridded dimensions in the {\tt field}
!       are the total {\tt field} dimensions less
!       the dimensions in
!       the {\tt grid}.  Ungridded dimensions must be in the same order they are
!       stored in the {\t field}.
!       If the Field dimCount is less than the LocStream dimCount then the default
!       gridToFieldMap will contain zeros for the rightmost entries. A zero
!       entry in the {\tt gridToFieldMap} indicates that the particular
!       LocStream dimension will be replicating the Field across the DEs along
!       this direction.
! \item [{[ungriddedLBound]}]
!       Lower bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded
!       dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. When field dimension count is
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound
!       must be specified. When both are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt field}.
! \item [{[ungriddedUBound]}]
!       Upper bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded
!       dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. When field dimension count is
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound
!       must be specified. When both are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt field}.
! \item[{[pinflag]}]
!      Specify which type of resource DEs are pinned to.  See section 
!      \ref{const:pin_flag} for a list of valid pinning options.
!      The default is to pin DEs to PETs, i.e. only the PET on which a DE
!      was created considers the DE as local.
! \item [{[name]}]
!       Field name.
! \item [{[rc]}]
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!EOP
!------------------------------------------------------------------------------
    integer :: localrc                          !  Local error code
    type(ESMF_ArraySpec) :: arrayspec
    integer :: rank, ungridded_dimcount, ungridded_ldimcount, ungridded_udimcount
    integer :: memDimCount

    ! Initialize
    localrc = ESMF_RC_NOT_IMPL

    ! Initialize return code
    if(present(rc)) rc = ESMF_RC_NOT_IMPL

    ! Compute rank
    ungridded_dimcount = 0
    if(present(ungriddedLBound)) then
      ungridded_ldimcount = size(ungriddedLBound)
      ungridded_dimcount = ungridded_ldimcount
    endif
    if(present(ungriddedUBound)) then
      ungridded_udimcount = size(ungriddedUBound)
      ungridded_dimcount = ungridded_udimcount
    endif

    if(present(ungriddedLBound) .and. present(ungriddedUBound)) then
      if(ungridded_ldimcount /= ungridded_udimcount) then
        call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, &
          msg="- ungriddedLBound size must equal to ungriddedUBound size", &
          ESMF_CONTEXT, rcToReturn=rc)
        return
      endif
    endif

    rank = ungridded_dimcount + 1

    ! Set ArraySpec from rank and typekind input
    call ESMF_ArraySpecSet(arrayspec, rank=rank, typekind=typekind, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
        ESMF_CONTEXT, rcToReturn=rc)) return

    ESMF_FieldCreateLSTKR = ESMF_FieldCreate(locstream, arrayspec, &
        gridToFieldMap=gridToFieldMap, &
        ungriddedLBound=ungriddedLBound, ungriddedUBound=ungriddedUBound, &
        pinflag=pinflag, name=name, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
        ESMF_CONTEXT, rcToReturn=rc)) return

    ! Return successfully
    if (present(rc)) rc = ESMF_SUCCESS

end function ESMF_FieldCreateLSTKR
!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_FieldCreateLSArraySpec"
!BOP
! !IROUTINE:   ESMF_FieldCreate - Create a Field from LocStream and ArraySpec

! !INTERFACE:
  ! Private name; call using ESMF_FieldCreate()
  function ESMF_FieldCreateLSArraySpec(locstream, arrayspec, keywordEnforcer, &
    gridToFieldMap, ungriddedLBound, ungriddedUBound, pinflag, name, rc)
!
! !RETURN VALUE:
    type(ESMF_Field) :: ESMF_FieldCreateLSArraySpec
!
! !ARGUMENTS:
    type(ESMF_LocStream), intent(in)            :: locstream
    type(ESMF_ArraySpec), intent(in)            :: arrayspec
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
    integer,              intent(in),  optional :: gridToFieldMap(:)
    integer,              intent(in),  optional :: ungriddedLBound(:)
    integer,              intent(in),  optional :: ungriddedUBound(:)
    type(ESMF_Pin_Flag),  intent(in),  optional :: pinflag
    character (len=*),    intent(in),  optional :: name
    integer,              intent(out), optional :: rc
!
! !DESCRIPTION:
! Create an {\tt ESMF\_Field} and allocate space internally for an
! {\tt ESMF\_Array}.  Return a new {\tt ESMF\_Field}. For an example and
! associated documentation using this method see section
! \ref{sec:field:usage:create_locs_arrayspec}.
!
! The arguments are:
! \begin{description}
! \item [locstream]
!       {\tt ESMF\_LocStream} object.
! \item [arrayspec]
!       Data type and kind specification.
! \item [{[gridToFieldMap]}]
!       List with number of elements equal to the
!       {\tt grid}|s dimCount.  The list elements map each dimension
!       of the {\tt grid} to a dimension in the {\tt field} by
!       specifying the appropriate {\tt field} dimension index. The default is to
!       map all of the {\tt grid}|s dimensions against the lowest dimensions of
!       the {\tt field} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../).
!       The values of all {\tt gridToFieldMap} entries must be greater than or equal
!       to one and smaller than or equal to the {\tt field} rank.
!       It is erroneous to specify the same {\tt gridToFieldMap} entry
!       multiple times. The total ungridded dimensions in the {\tt field}
!       are the total {\tt field} dimensions less
!       the dimensions in
!       the {\tt grid}.  Ungridded dimensions must be in the same order they are
!       stored in the {\t field}.
!       If the Field dimCount is less than the LocStream dimCount then the default
!       gridToFieldMap will contain zeros for the rightmost entries. A zero
!       entry in the {\tt gridToFieldMap} indicates that the particular
!       LocStream dimension will be replicating the Field across the DEs along
!       this direction.
! \item [{[ungriddedLBound]}]
!       Lower bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded
!       dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. When field dimension count is
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound
!       must be specified. When both are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt field}.
! \item [{[ungriddedUBound]}]
!       Upper bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded
!       dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. When field dimension count is
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound
!       must be specified. When both are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt field}.
! \item[{[pinflag]}]
!      Specify which type of resource DEs are pinned to.  See section 
!      \ref{const:pin_flag} for a list of valid pinning options.
!      The default is to pin DEs to PETs, i.e. only the PET on which a DE
!      was created considers the DE as local.
! \item [{[name]}]
!       Field name.
! \item [{[rc]}]
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!EOP
!------------------------------------------------------------------------------
    integer :: localrc                          !  Local error code
    type(ESMF_Geom) :: geom

    ! Initialize
    localrc = ESMF_RC_NOT_IMPL

    ! Initialize return code
    if(present(rc)) then
      rc = ESMF_RC_NOT_IMPL
    endif

    ! check init status of input parameters
    ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc)
    ESMF_INIT_CHECK_SHALLOW(ESMF_ArraySpecGetInit, arrayspec, rc)

    ! Create Geom from Mesh
    geom=ESMF_GeomCreate(locstream, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
      ESMF_CONTEXT, rcToReturn=rc)) return

    ! Create Field from Geom
    ESMF_FieldCreateLSArraySpec=ESMF_FieldCreateGBArraySpec(geom, &
        arrayspec, gridToFieldMap, &
        ungriddedLBound, ungriddedUBound, &
        pinflag=pinflag, name=name, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
      ESMF_CONTEXT, rcToReturn=rc)) return

    ! remember that geom was created internally
    ESMF_FieldCreateLSArraySpec%ftypep%geomb_internal = .true.

    if(present(rc)) rc = ESMF_SUCCESS

  end function ESMF_FieldCreateLSArraySpec
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_FieldCreateLSArray"
!BOP
! !IROUTINE: ESMF_FieldCreate - Create a Field from LocStream and Array

! !INTERFACE:
  ! Private name; call using ESMF_FieldCreate()
  function ESMF_FieldCreateLSArray(locstream, array, &
    keywordEnforcer, datacopyflag, gridToFieldMap, ungriddedLBound, ungriddedUBound, &
    name, rc)
!
! !RETURN VALUE:
    type(ESMF_Field) :: ESMF_FieldCreateLSArray
!
! !ARGUMENTS:
    type(ESMF_LocStream),     intent(in)            :: locstream
    type(ESMF_Array),         intent(in)            :: array
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
    type(ESMF_DataCopy_Flag), intent(in),  optional :: datacopyflag
    integer,                  intent(in),  optional :: gridToFieldMap(:)
    integer,                  intent(in),  optional :: ungriddedLBound(:)
    integer,                  intent(in),  optional :: ungriddedUBound(:)
    character (len = *),      intent(in),  optional :: name
    integer,                  intent(out), optional :: rc
!
! !DESCRIPTION:
! Create an {\tt ESMF\_Field}.  This version of creation
! assumes the data exists already and is being
! passed in through an {\tt ESMF\_Array}.  For an example and
! associated documentation using this method see section
! \ref{sec:field:usage:create_grid_array}.
!
! The arguments are:
! \begin{description}
! \item [locstream]
!       {\tt ESMF\_LocStream} object.
! \item [array]
!       {\tt ESMF\_Array} object.
! \item [{[datacopyflag]}]
!       Indicates whether to copy the contents of the {\tt array} or reference it directly.
!       For valid values see \ref{const:datacopyflag}.  The default is
!       {\tt ESMF\_DATACOPY\_REFERENCE}.
! \item [{[gridToFieldMap]}]
!       List with number of elements equal to the
!       {\tt grid}|s dimCount.  The list elements map each dimension
!       of the {\tt grid} to a dimension in the {\tt field} by
!       specifying the appropriate {\tt field} dimension index. The default is to
!       map all of the {\tt grid}|s dimensions against the lowest dimensions of
!       the {\tt field} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../).
!       The values of all {\tt gridToFieldMap} entries must be greater than or equal
!       to one and smaller than or equal to the {\tt field} rank.
!       It is erroneous to specify the same {\tt gridToFieldMap} entry
!       multiple times. The total ungridded dimensions in the {\tt field}
!       are the total {\tt field} dimensions less
!       the dimensions in
!       the {\tt grid}.  Ungridded dimensions must be in the same order they are
!       stored in the {\t field}.
!       If the Field dimCount is less than the LocStream dimCount then the default
!       gridToFieldMap will contain zeros for the rightmost entries. A zero
!       entry in the {\tt gridToFieldMap} indicates that the particular
!       LocStream dimension will be replicating the Field across the DEs along
!       this direction.
! \item [{[ungriddedLBound]}]
!       Lower bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded
!       dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. When field dimension count is
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound
!       must be specified. When both are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt field}.
! \item [{[ungriddedUBound]}]
!       Upper bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded
!       dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. When field dimension count is
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound
!       must be specified. When both are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt field}.
! \item [{[name]}]
!       Field name.
! \item [{[rc]}]
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!EOP
!------------------------------------------------------------------------------
    integer :: localrc                       !  Local error code
    type(ESMF_Geom) :: geom

    ! Initialize
    localrc = ESMF_RC_NOT_IMPL

    ! Initialize return code
    if (present(rc)) then
      rc = ESMF_RC_NOT_IMPL
    endif

    ! check init status of input parameters
    ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc)
    ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc)

    ! Create Geom from Mesh
    geom=ESMF_GeomCreate(locstream, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
      ESMF_CONTEXT, rcToReturn=rc)) return

    ! Create Field from Geom
    ESMF_FieldCreateLSArray=ESMF_FieldCreateGBArray(geom, array, datacopyflag, &
    gridToFieldMap, ungriddedLBound, ungriddedUBound, &
    name=name, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
       ESMF_CONTEXT, rcToReturn=rc)) return

    ! remember that geom was created internally
    ESMF_FieldCreateLSArray%ftypep%geomb_internal = .true.

    if (present(rc)) rc = ESMF_SUCCESS

  end function ESMF_FieldCreateLSArray
!------------------------------------------------------------------------------


#define FieldCreateLSDataDoc() \
!---------------------------------------------------------------------------- @\
!BOP @\
! !IROUTINE: ESMF_FieldCreate - Create a Field from LocStream and Fortran array @\
! @\
! !INTERFACE: @\
! ! Private name; call using ESMF_FieldCreate() @\
! function ESMF_FieldCreateLSData<rank><type><kind>(locstream, farray, & @\
!   indexflag, keywordEnforcer, datacopyflag, gridToFieldMap, ungriddedLBound, & @\
!   ungriddedUBound, name, rc) @\
! @\
! !RETURN VALUE: @\
!   type(ESMF_Field) :: ESMF_FieldCreateLSData<rank><type><kind> @\
! @\
! !ARGUMENTS: @\
!   type(ESMF_LocStream),     intent(in)            :: locstream      @\
!   <type> (ESMF_KIND_<kind>),intent(in), target    :: farray(<rank>) @\
!   type(ESMF_Index_Flag),    intent(in)            :: indexflag @\
!type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below @\
!   type(ESMF_DataCopy_Flag), intent(in),  optional :: datacopyflag @\
!   integer,                  intent(in),  optional :: gridToFieldMap(:)     @\
!   integer,                  intent(in),  optional :: ungriddedLBound(:) @\
!   integer,                  intent(in),  optional :: ungriddedUBound(:) @\
!   character (len=*),        intent(in),  optional :: name  @\
!   integer,                  intent(out), optional :: rc    @\
! @\
! !DESCRIPTION: @\
! \begin{sloppypar} @\
! Create an {\tt ESMF\_Field} from a Fortran data array and {\tt ESMF\_LocStream}. @\
! The Fortran data pointer inside {\tt ESMF\_Field} can be queried but deallocating @\
! the retrieved data pointer is not allowed. @\
! \end{sloppypar} @\
! @\
! The arguments are: @\
! \begin{description} @\
! \item [locstream]  @\
!       {\tt ESMF\_LocStream} object. @\
! \item [farray] @\
!       Native Fortran data array to be copied/referenced in the Field @\
!       The Field dimension (dimCount) will be the same as the dimCount @\
!       for the {\tt farray}. @\
! \item[indexflag] @\
!       Indicate how DE-local indices are defined. See section @\
!       \ref{const:indexflag} for a list of valid indexflag options. @\
! \item [{[datacopyflag]}] @\
!       Whether to copy the contents of the {\tt farray} or reference directly. @\
!       For valid values see \ref{const:datacopyflag}.  The default is @\
!       {\tt ESMF\_DATACOPY\_REFERENCE}. @\
! \item [{[gridToFieldMap]}] @\
!       List with number of elements equal to the @\
!       {\tt locstream}|s dimCount.  The list elements map each dimension @\
!       of the {\tt locstream} to a dimension in the {\tt farray} by @\
!       specifying the appropriate {\tt farray} dimension index. The default is to @\
!       map all of the {\tt locstream}|s dimensions against the lowest dimensions of @\
!       the {\tt farray} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../). @\
!       The values of all {\tt gridToFieldMap} entries must be greater than or equal @\
!       to one and smaller than or equal to the {\tt farray} rank. @\
!       It is erroneous to specify the same {\tt gridToFieldMap} entry @\
!       multiple times. The total ungridded dimensions in the {\tt field} @\
!       are the total {\tt farray} dimensions less @\
!       the total (distributed + undistributed) dimensions in @\
!       the {\tt locstream}.  Unlocstreamded dimensions must be in the same order they are @\
!       stored in the {\t farray}.  Permutations of the order of @\
!       dimensions are handled via individual communication methods.  For example, @\
!       an undistributed dimension can be remapped to a distributed dimension @\
!       as part of the {\tt ESMF\_ArrayRedist()} operation. @\
!       If the Field dimCount is less than the LocStream dimCount then the default @\
!       gridToFieldMap will contain zeros for the rightmost entries. A zero @\
!       entry in the {\tt gridToFieldMap} indicates that the particular @\
!       LocStream dimension will be replicating the Field across the DEs along @\
!       this direction. @\
! \item [{[ungriddedLBound]}] @\
!       Lower bounds of the ungridded dimensions of the {\tt field}. @\
!       The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded @\
!       dimensions in the {\tt field}.  All ungridded dimensions of the @\
!       {\tt field} are also undistributed. When field dimension count is @\
!       greater than locstream dimension count, both ungriddedLBound and ungriddedUBound @\
!       must be specified. When both are specified the values are checked @\
!       for consistency.  Note that the the ordering of @\
!       these ungridded dimensions is the same as their order in the {\tt farray}. @\
! \item [{[ungriddedUBound]}] @\
!       Upper bounds of the ungridded dimensions of the {\tt field}. @\
!       The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded @\
!       dimensions in the {\tt field}.  All ungridded dimensions of the @\
!       {\tt field} are also undistributed. When field dimension count is @\
!       greater than locstream dimension count, both ungriddedLBound and ungriddedUBound @\
!       must be specified. When both are specified the values are checked @\
!       for consistency.  Note that the the ordering of @\
!       these ungridded dimensions is the same as their order in the {\tt farray}. @\
! \item [{[name]}]  @\
!       Field name.  @\
! \item [{[rc]}]  @\
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
! \end{description} @\
! @\
!EOP @\
!---------------------------------------------------------------------------- @\

#define FieldCreateLSDataMacro(mname, mtypekind, mrank, mdim, mlen, mrng, mloc) \
!---------------------------------------------------------------------------- @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_FieldCreateLSData" @\
  function ESMF_FieldCreateLSData##mrank##D##mtypekind(locstream, farray, & @\
    indexflag, keywordEnforcer, datacopyflag, gridToFieldMap, ungriddedLBound, & @\
    ungriddedUBound, name, rc) @\
@\
    ! return value @\
    type(ESMF_Field) :: ESMF_FieldCreateLSData##mrank##D##mtypekind @\
@\
    ! input arguments @\
    type(ESMF_LocStream), intent(in) :: locstream                  @\
    mname (ESMF_KIND_##mtypekind), intent(in), target :: farray(mdim) @\
    type(ESMF_Index_Flag), intent(in)            :: indexflag @\
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below @\
    type(ESMF_DataCopy_Flag), intent(in), optional   :: datacopyflag @\
    integer, intent(in), optional :: gridToFieldMap(:)     @\
    integer, intent(in), optional :: ungriddedLBound(:) @\
    integer, intent(in), optional :: ungriddedUBound(:) @\
    character (len=*), intent(in), optional :: name  @\
    integer, intent(out), optional :: rc                @\
@\
    integer :: localrc                       !  Local error code@\
    type(ESMF_Geom) :: geom @\
@\
    ! Initialize @\
    localrc = ESMF_RC_NOT_IMPL@\
@\
    ! Initialize return code   @\
    if (present(rc)) then@\
      rc = ESMF_RC_NOT_IMPL@\
    endif     @\
@\
    ! check init status of input parameters@\
    ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc)@\
@\
@\
    ! Create Geom from LocStream@\
    geom=ESMF_GeomCreate(locstream,rc=localrc)@\
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &@\
      ESMF_CONTEXT, rcToReturn=rc)) return@\
@\
@\
       ESMF_FieldCreateLSData##mrank##D##mtypekind = & @\
              ESMF_FieldCreateGBData##mrank##D##mtypekind(geom, & @\
                               farray, indexflag=indexflag, datacopyflag=datacopyflag, & @\
                               gridToFieldMap=gridToFieldMap, & @\
                               ungriddedLBound=ungriddedLBound, & @\
                               ungriddedUBound=ungriddedUBound, & @\
                               name=name, rc=localrc) @\
    if (ESMF_LogFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
@\
    ! remember that geom was created internally @\
    ESMF_FieldCreateLSData##mrank##D##mtypekind%ftypep%geomb_internal = .true. @\
@\
    if (present(rc)) rc = ESMF_SUCCESS @\
  end function ESMF_FieldCreateLSData##mrank##D##mtypekind  @\
!------------------------------------------------------------------------------ @\

TypeKindRankDeclarationMacro(FieldCreateLSData)


#define FieldCreateLSDataPtrDoc() \
!---------------------------------------------------------------------------- @\
!BOP @\
! !IROUTINE: ESMF_FieldCreate - Create a Field from LocStream and Fortran array pointer @\
! @\
! !INTERFACE: @\
! ! Private name; call using ESMF_FieldCreate() @\
! function ESMF_FieldCreateLSDataPtr<rank><type><kind>(locstream, & @\
!   keywordEnforcer, farrayPtr, datacopyflag, gridToFieldMap, & @\
!   name, rc) @\
! @\
! !RETURN VALUE: @\
!   type(ESMF_Field) :: ESMF_FieldCreateLSDataPtr<rank><type><kind> @\
! @\
! !ARGUMENTS: @\
!   type(ESMF_LocStream),     intent(in)            :: locstream         @\
!   <type> (ESMF_KIND_<kind>),pointer               :: farrayPtr(<rank>) @\
!type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below @\
!   type(ESMF_DataCopy_Flag), intent(in),  optional :: datacopyflag      @\
!   integer,                  intent(in),  optional :: gridToFieldMap(:) @\
!   character (len=*),        intent(in),  optional :: name              @\
!   integer,                  intent(out), optional :: rc                @\
! @\
! !DESCRIPTION: @\
! \begin{sloppypar} @\
! Create an {\tt ESMF\_Field} from a Fortran data pointer and {\tt ESMF\_LocStream}. @\
! The Fortran data pointer inside {\tt ESMF\_Field} can be queried and deallocated when @\
! datacopyflag is {\tt ESMF\_DATACOPY\_REFERENCE}. Note that the {\tt ESMF\_FieldDestroy} call does not @\
! deallocate the Fortran data pointer in this case. This gives user more flexibility over memory management. @\
! \end{sloppypar} @\
! @\
! The arguments are: @\
! \begin{description} @\
! \item [locstream]  @\
!       {\tt ESMF\_LocStream} object. @\
! \item [farrayPtr] @\
!       Native Fortran data pointer to be copied/referenced in the Field @\
!       The Field dimension (dimCount) will be the same as the dimCount @\
!       for the {\tt farrayPtr}. @\
! \item [{[datacopyflag]}] @\
!       Whether to copy the contents of the {\tt farrayPtr} or reference it directly. @\
!       For valid values see \ref{const:datacopyflag}.  The default is @\
!       {\tt ESMF\_DATACOPY\_REFERENCE}. @\
! \item [{[gridToFieldMap]}] @\
!       List with number of elements equal to the @\
!       {\tt locstream}|s dimCount.  The list elements map each dimension @\
!       of the {\tt locstream} to a dimension in the {\tt farrayPtr} by @\
!       specifying the appropriate {\tt farrayPtr} dimension index. The default is to @\
!       map all of the {\tt locstream}|s dimensions against the lowest dimensions of @\
!       the {\tt farrayPtr} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../). @\
!       The values of all {\tt gridToFieldMap} entries must be greater than or equal @\
!       to one and smaller than or equal to the {\tt farrayPtr} rank. @\
!       It is erroneous to specify the same {\tt gridToFieldMap} entry @\
!       multiple times. The total ungridded dimensions in the {\tt field} @\
!       are the total {\tt farrayPtr} dimensions less @\
!       the total (distributed + undistributed) dimensions in @\
!       the {\tt locstream}.  Unlocstreamded dimensions must be in the same order they are @\
!       stored in the {\t farrayPtr}.  Permutations of the order of @\
!       dimensions are handled via individual communication methods.  For example, @\
!       an undistributed dimension can be remapped to a distributed dimension @\
!       as part of the {\tt ESMF\_ArrayRedist()} operation. @\
!       If the Field dimCount is less than the LocStream dimCount then the default @\
!       gridToFieldMap will contain zeros for the rightmost entries. A zero @\
!       entry in the {\tt gridToFieldMap} indicates that the particular @\
!       LocStream dimension will be replicating the Field across the DEs along @\
!       this direction. @\
! \item [{[name]}]  @\
!       Field name.  @\
! \item [{[rc]}]  @\
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
! \end{description} @\
! @\
!EOP @\
!---------------------------------------------------------------------------- @\

#define FieldCreateLSDataPtrMacro(mname, mtypekind, mrank, mdim, mlen, mrng, mloc) \
!---------------------------------------------------------------------------- @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_FieldCreateLSDataPtr" @\
  function ESMF_FieldCreateLSDataPtr##mrank##D##mtypekind(locstream, & @\
    farrayPtr, keywordEnforcer, datacopyflag, gridToFieldMap, & @\
    name, rc) @\
@\
    ! return value @\
    type(ESMF_Field) :: ESMF_FieldCreateLSDataPtr##mrank##D##mtypekind @\
@\
    ! input arguments @\
    type(ESMF_LocStream), intent(in) :: locstream                  @\
    mname (ESMF_KIND_##mtypekind), dimension(mdim), pointer :: farrayPtr @\
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below @\
    type(ESMF_DataCopy_Flag), intent(in), optional   :: datacopyflag @\
    integer, intent(in), optional :: gridToFieldMap(:)     @\
    character (len=*), intent(in), optional :: name  @\
    integer, intent(out), optional :: rc                @\
@\
    integer :: localrc                       !  Local error code@\
    type(ESMF_Geom) :: geom @\
@\
    ! Initialize @\
    localrc = ESMF_RC_NOT_IMPL@\
@\
    ! Initialize return code   @\
    if (present(rc)) then@\
      rc = ESMF_RC_NOT_IMPL@\
    endif     @\
@\
    ! check init status of input parameters@\
    ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc)@\
@\
@\
    ! Create Geom from LocStream@\
    geom=ESMF_GeomCreate(locstream,rc=localrc)@\
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &@\
      ESMF_CONTEXT, rcToReturn=rc)) return@\
@\
@\
       ESMF_FieldCreateLSDataPtr##mrank##D##mtypekind = & @\
              ESMF_FieldCreateGBDataPtr##mrank##D##mtypekind(geom, & @\
                               farrayPtr, datacopyflag=datacopyflag, & @\
                               gridToFieldMap=gridToFieldMap, & @\
                               name=name, rc=localrc) @\
    if (ESMF_LogFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
@\
    ! remember that geom was created internally @\
    ESMF_FieldCreateLSDataPtr##mrank##D##mtypekind%ftypep%geomb_internal = .true. @\
@\
    if (present(rc)) rc = ESMF_SUCCESS @\
  end function ESMF_FieldCreateLSDataPtr##mrank##D##mtypekind  @\
!------------------------------------------------------------------------------ @\

TypeKindRankDeclarationMacro(FieldCreateLSDataPtr)

!------------------------------------------------------------------------------

! ESMF_FieldCreateMe
!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_FieldCreateMeshTKR"
!BOP
! !IROUTINE:   ESMF_FieldCreate - Create a Field from Mesh and typekind

! !INTERFACE:
  ! Private name; call using ESMF_FieldCreate()
  function ESMF_FieldCreateMeshTKR(mesh, typekind, keywordEnforcer, indexflag, &
    meshloc, gridToFieldMap, ungriddedLBound, ungriddedUBound, &
    pinflag, name, rc)
!
! !RETURN VALUE:
    type(ESMF_Field) :: ESMF_FieldCreateMeshTKR
!
! !ARGUMENTS:
    type(ESMF_Mesh),          intent(in)            :: mesh
    type(ESMF_TypeKind_Flag), intent(in)            :: typekind
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
    type(ESMF_Index_Flag),    intent(in),  optional :: indexflag
    type(ESMF_MeshLoc),       intent(in),  optional :: meshloc
    integer,                  intent(in),  optional :: gridToFieldMap(:)
    integer,                  intent(in),  optional :: ungriddedLBound(:)
    integer,                  intent(in),  optional :: ungriddedUBound(:)
    type(ESMF_Pin_Flag),      intent(in),  optional :: pinflag
    character (len=*),        intent(in),  optional :: name
    integer,                  intent(out), optional :: rc
!
! !DESCRIPTION:
! Create an {\tt ESMF\_Field} and allocate space internally for an
! {\tt ESMF\_Array}.  Return a new {\tt ESMF\_Field}. For an example and
! associated documentation using this method see section
! \ref{sec:field:usage:create_mesh_tkr}.
!
! The arguments are:
! \begin{description}
! \item [mesh]
!       {\tt ESMF\_Mesh} object.
! \item [typekind]
!       The typekind of the Field. See section \ref{const:typekind}
!       for a list of valid typekind options.
! \item [{[indexflag]}]
!       Indicate how DE-local indices are defined. See section
!       \ref{const:indexflag} for a list of valid indexflag options.
! \item [{[meshloc]}]
!       \begin{sloppypar}
!       The part of the Mesh on which to build the Field. For valid
!       predefined values see Section~\ref{const:meshloc}.
!       If not set, defaults to {\tt ESMF\_MESHLOC\_NODE}.
!       \end{sloppypar}
! \item [{[gridToFieldMap]}]
!       List with number of elements equal to the
!       {\tt grid}|s dimCount.  The list elements map each dimension
!       of the {\tt grid} to a dimension in the {\tt field} by
!       specifying the appropriate {\tt field} dimension index. The default is to
!       map all of the {\tt grid}|s dimensions against the lowest dimensions of
!       the {\tt field} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../).
!       The values of all {\tt gridToFieldMap} entries must be greater than or equal
!       to one and smaller than or equal to the {\tt field} rank.
!       It is erroneous to specify the same {\tt gridToFieldMap} entry
!       multiple times. The total ungridded dimensions in the {\tt field}
!       are the total {\tt field} dimensions less
!       the dimensions in
!       the {\tt grid}.  Ungridded dimensions must be in the same order they are
!       stored in the {\t field}.
!       If the Field dimCount is less than the Mesh dimCount then the default
!       gridToFieldMap will contain zeros for the rightmost entries. A zero
!       entry in the {\tt gridToFieldMap} indicates that the particular
!       Mesh dimension will be replicating the Field across the DEs along
!       this direction.
! \item [{[ungriddedLBound]}]
!       Lower bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded
!       dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. When field dimension count is
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound
!       must be specified. When both are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt field}.
! \item [{[ungriddedUBound]}]
!       Upper bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded
!       dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. When field dimension count is
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound
!       must be specified. When both are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt field}.
! \item[{[pinflag]}]
!      Specify which type of resource DEs are pinned to.  See section 
!      \ref{const:pin_flag} for a list of valid pinning options.
!      The default is to pin DEs to PETs, i.e. only the PET on which a DE
!      was created considers the DE as local.
! \item [{[name]}]
!       Field name.
! \item [{[rc]}]
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!EOP
!------------------------------------------------------------------------------
    integer :: localrc                          !  Local error code
    type(ESMF_ArraySpec) :: arrayspec
    integer :: rank, ungridded_dimcount, ungridded_ldimcount, ungridded_udimcount
    integer :: memDimCount
    type(ESMF_MeshLoc) :: localMeshloc
    type(ESMF_Distgrid) :: localDistgrid
    type(ESMF_Index_Flag) :: l_indexflag

    ! Initialize
    localrc = ESMF_RC_NOT_IMPL

    ! Initialize return code
    if(present(rc)) rc = ESMF_RC_NOT_IMPL

    ! Compute rank
    ungridded_dimcount = 0
    if(present(ungriddedLBound)) then
      ungridded_ldimcount = size(ungriddedLBound)
      ungridded_dimcount = ungridded_ldimcount
    endif
    if(present(ungriddedUBound)) then
      ungridded_udimcount = size(ungriddedUBound)
      ungridded_dimcount = ungridded_udimcount
    endif

    if(present(ungriddedLBound) .and. present(ungriddedUBound)) then
      if(ungridded_ldimcount /= ungridded_udimcount) then
        call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, &
          msg="- ungriddedLBound size must equal to ungriddedUBound size", &
          ESMF_CONTEXT, rcToReturn=rc)
        return
      endif
    endif

    ! Get DimCount from distgrid
    localMeshloc=ESMF_MESHLOC_NODE
    if (present(meshloc)) then
       localMeshloc=meshloc
    endif

    ! Get distgrid
    if (localMeshloc == ESMF_MESHLOC_NODE) then
       call ESMF_MeshGet(mesh, &
            nodalDistgrid=localDistgrid, &
            rc=localrc)
       if (ESMF_LogFoundError(localrc, &
            ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) return
    else if (localmeshloc == ESMF_MESHLOC_ELEMENT) then
       call ESMF_MeshGet(mesh, &
            elementDistgrid=localDistgrid, &
            rc=localrc)
       if (ESMF_LogFoundError(localrc, &
            ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) return
    else
       if (ESMF_LogFoundError(ESMF_RC_ARG_VALUE, &
                  msg=" Bad Mesh Location value", &
                  ESMF_CONTEXT, rcToReturn=rc)) return
    endif

    ! Get rank
    call ESMF_DistGridGet(localDistgrid, &
         dimCount=rank, rc=localrc)
    if (ESMF_LogFoundError(localrc, &
         ESMF_ERR_PASSTHRU, &
         ESMF_CONTEXT, rcToReturn=rc)) return

    ! Add in ungridded dimensions
    rank = rank + ungridded_dimcount

    ! Set ArraySpec from rank and typekind input
    call ESMF_ArraySpecSet(arrayspec, rank=rank, typekind=typekind, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
        ESMF_CONTEXT, rcToReturn=rc)) return

    ESMF_FieldCreateMeshTKR = ESMF_FieldCreate(mesh, arrayspec, &
      indexflag=indexflag, meshloc=meshloc, gridToFieldMap=gridToFieldMap, &
      ungriddedLBound=ungriddedLBound, ungriddedUBound=ungriddedUBound, &
      pinflag=pinflag, name=name, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
        ESMF_CONTEXT, rcToReturn=rc)) return

    ! Return successfully
    if (present(rc)) rc = ESMF_SUCCESS

end function ESMF_FieldCreateMeshTKR
!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_FieldCreateMeshArraySpec"
!BOP
! !IROUTINE:   ESMF_FieldCreate - Create a Field from Mesh and ArraySpec

! !INTERFACE:
  ! Private name; call using ESMF_FieldCreate()
  function ESMF_FieldCreateMeshArraySpec(mesh, arrayspec, keywordEnforcer, &
    indexflag, meshloc, gridToFieldMap, ungriddedLBound, ungriddedUBound, &
    pinflag, name, rc)
!
! !RETURN VALUE:
    type(ESMF_Field) :: ESMF_FieldCreateMeshArraySpec
!
! !ARGUMENTS:
    type(ESMF_Mesh),      intent(in)            :: mesh
    type(ESMF_ArraySpec), intent(in)            :: arrayspec
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
    type(ESMF_Index_Flag),intent(in),  optional :: indexflag
    type(ESMF_MeshLoc),   intent(in),  optional :: meshloc
    integer,              intent(in),  optional :: gridToFieldMap(:)
    integer,              intent(in),  optional :: ungriddedLBound(:)
    integer,              intent(in),  optional :: ungriddedUBound(:)
    type(ESMF_Pin_Flag),  intent(in),  optional :: pinflag
    character (len=*),    intent(in),  optional :: name
    integer,              intent(out), optional :: rc
!
! !DESCRIPTION:
! Create an {\tt ESMF\_Field} and allocate space internally for an
! {\tt ESMF\_Array}.  Return a new {\tt ESMF\_Field}. For an example and
! associated documentation using this method see section
! \ref{sec:field:usage:create_mesh_arrayspec} and
! \ref{sec:field:usage:createMeshArrayspecOpt}.
!
! The arguments are:
! \begin{description}
! \item [mesh]
!       {\tt ESMF\_Mesh} object.
! \item [arrayspec]
!       Data type and kind specification.
! \item [{[indexflag]}]
!       Indicate how DE-local indices are defined. See section
!       \ref{const:indexflag} for a list of valid indexflag options.
! \item [{[meshloc]}]
!       \begin{sloppypar}
!       The part of the Mesh on which to build the Field. For valid
!       predefined values see Section~\ref{const:meshloc}.
!       If not set, defaults to {\tt ESMF\_MESHLOC\_NODE}.
!       \end{sloppypar}
! \item [{[gridToFieldMap]}]
!       List with number of elements equal to the
!       {\tt grid}|s dimCount.  The list elements map each dimension
!       of the {\tt grid} to a dimension in the {\tt field} by
!       specifying the appropriate {\tt field} dimension index. The default is to
!       map all of the {\tt grid}|s dimensions against the lowest dimensions of
!       the {\tt field} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../).
!       The values of all {\tt gridToFieldMap} entries must be greater than or equal
!       to one and smaller than or equal to the {\tt field} rank.
!       It is erroneous to specify the same {\tt gridToFieldMap} entry
!       multiple times. The total ungridded dimensions in the {\tt field}
!       are the total {\tt field} dimensions less
!       the dimensions in
!       the {\tt grid}.  Ungridded dimensions must be in the same order they are
!       stored in the {\t field}.
!       If the Field dimCount is less than the Mesh dimCount then the default
!       gridToFieldMap will contain zeros for the rightmost entries. A zero
!       entry in the {\tt gridToFieldMap} indicates that the particular
!       Mesh dimension will be replicating the Field across the DEs along
!       this direction.
! \item [{[ungriddedLBound]}]
!       Lower bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded
!       dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. When field dimension count is
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound
!       must be specified. When both are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt field}.
! \item [{[ungriddedUBound]}]
!       Upper bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded
!       dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. When field dimension count is
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound
!       must be specified. When both are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt field}.
! \item[{[pinflag]}]
!      Specify which type of resource DEs are pinned to.  See section 
!      \ref{const:pin_flag} for a list of valid pinning options.
!      The default is to pin DEs to PETs, i.e. only the PET on which a DE
!      was created considers the DE as local.
! \item [{[name]}]
!       Field name.
! \item [{[rc]}]
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!EOP
!------------------------------------------------------------------------------
    integer :: localrc                          !  Local error code
    type(ESMF_Geom) :: geom

    ! Initialize
    localrc = ESMF_RC_NOT_IMPL

    ! Initialize return code
    if(present(rc)) then
      rc = ESMF_RC_NOT_IMPL
    endif

    ! check init status of input parameters
    ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc)
    ESMF_INIT_CHECK_SHALLOW(ESMF_ArraySpecGetInit, arrayspec, rc)

    ! Create Geom from Mesh
    geom=ESMF_GeomCreate(mesh, meshLoc=meshloc,  rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
      ESMF_CONTEXT, rcToReturn=rc)) return

    ! Create Field from Geom
    ESMF_FieldCreateMeshArraySpec=ESMF_FieldCreateGBArraySpec(geom, &
        arrayspec, gridToFieldMap, &
        ungriddedLBound, ungriddedUBound, &
        pinflag=pinflag, name=name, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
      ESMF_CONTEXT, rcToReturn=rc)) return

    ! remember that geom was created internally
    ESMF_FieldCreateMeshArraySpec%ftypep%geomb_internal = .true.

    if(present(rc)) rc = ESMF_SUCCESS

  end function ESMF_FieldCreateMeshArraySpec
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_FieldCreateMeshArray"
!BOP
! !IROUTINE: ESMF_FieldCreate - Create a Field from Mesh and Array

! !INTERFACE:
  ! Private name; call using ESMF_FieldCreate()
  function ESMF_FieldCreateMeshArray(mesh, array, &
    keywordEnforcer, datacopyflag, meshloc, &
    gridToFieldMap, ungriddedLBound, ungriddedUBound, &
    name, vm, rc)
!
! !RETURN VALUE:
    type(ESMF_Field) :: ESMF_FieldCreateMeshArray
!
! !ARGUMENTS:
    type(ESMF_Mesh),          intent(in)            :: mesh
    type(ESMF_Array),         intent(in)            :: array
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
    type(ESMF_DataCopy_Flag), intent(in),  optional :: datacopyflag
    type(ESMF_MeshLoc),       intent(in),  optional :: meshloc
    integer,                  intent(in),  optional :: gridToFieldMap(:)
    integer,                  intent(in),  optional :: ungriddedLBound(:)
    integer,                  intent(in),  optional :: ungriddedUBound(:)
    character (len = *),      intent(in),  optional :: name
    type(ESMF_VM),            intent(in),  optional :: vm
    integer,                  intent(out), optional :: rc
!
! !DESCRIPTION:
! Create an {\tt ESMF\_Field}.  This version of creation
! assumes the data exists already and is being
! passed in through an {\tt ESMF\_Array}.  For an example and
! associated documentation using this method see section
! \ref{sec:field:usage:create_mesh_array}.
!
! The arguments are:
! \begin{description}
! \item [mesh]
!       {\tt ESMF\_Mesh} object.
! \item [array]
!       {\tt ESMF\_Array} object.
! \item [{[datacopyflag]}]
!       Indicates whether to copy the contents of the {\tt array} or reference it directly.
!       For valid values see \ref{const:datacopyflag}.  The default is
!       {\tt ESMF\_DATACOPY\_REFERENCE}.
! \item [{[meshloc]}]
!       \begin{sloppypar}
!       The part of the Mesh on which to build the Field. For valid
!       predefined values see Section~\ref{const:meshloc}.
!       If not set, defaults to {\tt ESMF\_MESHLOC\_NODE}.
!       \end{sloppypar}
! \item [{[gridToFieldMap]}]
!       List with number of elements equal to the
!       {\tt grid}|s dimCount.  The list elements map each dimension
!       of the {\tt grid} to a dimension in the {\tt field} by
!       specifying the appropriate {\tt field} dimension index. The default is to
!       map all of the {\tt grid}|s dimensions against the lowest dimensions of
!       the {\tt field} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../).
!       The values of all {\tt gridToFieldMap} entries must be greater than or equal
!       to one and smaller than or equal to the {\tt field} rank.
!       It is erroneous to specify the same {\tt gridToFieldMap} entry
!       multiple times. The total ungridded dimensions in the {\tt field}
!       are the total {\tt field} dimensions less
!       the dimensions in
!       the {\tt grid}.  Ungridded dimensions must be in the same order they are
!       stored in the {\t field}.
!       If the Field dimCount is less than the Mesh dimCount then the default
!       gridToFieldMap will contain zeros for the rightmost entries. A zero
!       entry in the {\tt gridToFieldMap} indicates that the particular
!       Mesh dimension will be replicating the Field across the DEs along
!       this direction.
! \item [{[ungriddedLBound]}]
!       Lower bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded
!       dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. When field dimension count is
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound
!       must be specified. When both are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt field}.
! \item [{[ungriddedUBound]}]
!       Upper bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded
!       dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. When field dimension count is
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound
!       must be specified. When both are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt field}.
! \item [{[name]}]
!       Field name.
! \item[{[vm]}]
!       If present, the Field object is constructed on the specified
!       {\tt ESMF\_VM} object. The default is to construct on the VM of the
!       current component context.
! \item [{[rc]}]
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!EOP
!------------------------------------------------------------------------------
    integer :: localrc                       !  Local error code
    type(ESMF_Geom) :: geom

    ! Initialize
    localrc = ESMF_RC_NOT_IMPL

    ! Initialize return code
    if (present(rc)) then
      rc = ESMF_RC_NOT_IMPL
    endif

    ! check init status of input parameters
    ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc)
    ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc)

    ! Create Geom from Mesh
    geom=ESMF_GeomCreate(mesh, meshLoc=meshloc, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
      ESMF_CONTEXT, rcToReturn=rc)) return

    ! Create Field from Geom
    ESMF_FieldCreateMeshArray=ESMF_FieldCreateGBArray(geom, array, &
      datacopyflag, gridToFieldMap, ungriddedLBound, ungriddedUBound, &
      name=name, vm=vm, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
      ESMF_CONTEXT, rcToReturn=rc)) return

    ! remember that geom was created internally
    ESMF_FieldCreateMeshArray%ftypep%geomb_internal = .true.

    if (present(rc)) rc = ESMF_SUCCESS

  end function ESMF_FieldCreateMeshArray
!------------------------------------------------------------------------------


#define FieldCreateMeshDataDoc() \
!---------------------------------------------------------------------------- @\
!BOP @\
! !IROUTINE: ESMF_FieldCreate - Create a Field from Mesh and Fortran array @\
! @\
! !INTERFACE: @\
! ! Private name; call using ESMF_FieldCreate() @\
! function ESMF_FieldCreateMeshData<rank><type><kind>(mesh, & @\
!   farray, indexflag, keywordEnforcer, datacopyflag, meshloc, & @\
!   gridToFieldMap, ungriddedLBound, ungriddedUBound, name, rc) @\
! @\
! !RETURN VALUE: @\
!   type(ESMF_Field) :: ESMF_FieldCreateMeshData<rank><type><kind> @\
! @\
! !ARGUMENTS: @\
!   type(ESMF_Mesh),          intent(in)               :: mesh           @\
!   <type> (ESMF_KIND_<kind>),intent(in),  target      :: farray(<rank>) @\
!   type(ESMF_Index_Flag),    intent(in)               :: indexflag @\
!type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below @\
!   type(ESMF_DataCopy_Flag), intent(in),  optional    :: datacopyflag @\
!   type(ESMF_MeshLoc),       intent(in),  optional    :: meshloc @\
!   integer,                  intent(in),  optional    :: gridToFieldMap(:)  @\
!   integer,                  intent(in),  optional    :: ungriddedLBound(:) @\
!   integer,                  intent(in),  optional    :: ungriddedUBound(:) @\
!   character (len=*),        intent(in),  optional    :: name  @\
!   integer,                  intent(out), optional    :: rc    @\
! @\
! !DESCRIPTION: @\
! Create an {\tt ESMF\_Field} from a Fortran data array and {\tt ESMF\_Mesh}. @\
! The Fortran data pointer inside {\tt ESMF\_Field} can be queried but deallocating @\
! the retrieved data pointer is not allowed. @\
! @\
! The arguments are: @\
! \begin{description} @\
! \item [mesh]  @\
!       {\tt ESMF\_Mesh} object. @\
! \item [farray] @\
!       Native Fortran data array to be copied/referenced in the Field @\
!       The Field dimension (dimCount) will be the same as the dimCount @\
!       for the {\tt farray}. @\
! \item[indexflag] @\
!       Indicate how DE-local indices are defined. See section @\
!       \ref{const:indexflag} for a list of valid indexflag options. @\
! \item [{[datacopyflag]}] @\
!       Whether to copy the contents of the {\tt farray} or reference it directly. @\
!       For valid values see \ref{const:datacopyflag}.  The default is @\
!       {\tt ESMF\_DATACOPY\_REFERENCE}. @\
! \item [{[meshloc]}] @\
!       \begin{sloppypar} @\
!       The part of the Mesh on which to build the Field. For valid @\
!       predefined values see Section~\ref{const:meshloc}. @\
!       If not set, defaults to {\tt ESMF\_MESHLOC\_NODE}. @\
!       \end{sloppypar} @\
! \item [{[gridToFieldMap]}] @\
!       List with number of elements equal to the @\
!       {\tt mesh}|s dimCount.  The list elements map each dimension @\
!       of the {\tt mesh} to a dimension in the {\tt farray} by @\
!       specifying the appropriate {\tt farray} dimension index. The default is to @\
!       map all of the {\tt mesh}|s dimensions against the lowest dimensions of @\
!       the {\tt farray} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../). @\
!       The values of all {\tt gridToFieldMap} entries must be greater than or equal @\
!       to one and smaller than or equal to the {\tt farray} rank. @\
!       It is erroneous to specify the same {\tt gridToFieldMap} entry @\
!       multiple times. The total ungridded dimensions in the {\tt field} @\
!       are the total {\tt farray} dimensions less @\
!       the total (distributed + undistributed) dimensions in @\
!       the {\tt mesh}.  Unmeshded dimensions must be in the same order they are @\
!       stored in the {\t farray}.  Permutations of the order of @\
!       dimensions are handled via individual communication methods.  For example, @\
!       an undistributed dimension can be remapped to a distributed dimension @\
!       as part of the {\tt ESMF\_ArrayRedist()} operation. @\
!       If the Field dimCount is less than the Mesh dimCount then the default @\
!       gridToFieldMap will contain zeros for the rightmost entries. A zero @\
!       entry in the {\tt gridToFieldMap} indicates that the particular @\
!       Mesh dimension will be replicating the Field across the DEs along @\
!       this direction. @\
! \item [{[ungriddedLBound]}] @\
!       Lower bounds of the ungridded dimensions of the {\tt field}. @\
!       The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded @\
!       dimensions in the {\tt field}.  All ungridded dimensions of the @\
!       {\tt field} are also undistributed. When field dimension count is @\
!       greater than mesh dimension count, both ungriddedLBound and ungriddedUBound @\
!       must be specified. When both are specified the values are checked @\
!       for consistency.  Note that the the ordering of @\
!       these ungridded dimensions is the same as their order in the {\tt farray}. @\
! \item [{[ungriddedUBound]}] @\
!       Upper bounds of the ungridded dimensions of the {\tt field}. @\
!       The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded @\
!       dimensions in the {\tt field}.  All ungridded dimensions of the @\
!       {\tt field} are also undistributed. When field dimension count is @\
!       greater than mesh dimension count, both ungriddedLBound and ungriddedUBound @\
!       must be specified. When both are specified the values are checked @\
!       for consistency.  Note that the the ordering of @\
!       these ungridded dimensions is the same as their order in the {\tt farray}. @\
! \item [{[name]}]  @\
!       Field name.  @\
! \item [{[rc]}]  @\
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
! \end{description} @\
! @\
!EOP @\
!---------------------------------------------------------------------------- @\

#define FieldCreateMeshDataMacro(mname, mtypekind, mrank, mdim, mlen, mrng, mloc) \
!---------------------------------------------------------------------------- @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_FieldCreateMeshData" @\
  function ESMF_FieldCreateMeshData##mrank##D##mtypekind(mesh, & @\
    farray, indexflag, keywordEnforcer, datacopyflag, meshloc, & @\
    gridToFieldMap, ungriddedLBound, ungriddedUBound, name, rc) @\
@\
    ! return value @\
    type(ESMF_Field) :: ESMF_FieldCreateMeshData##mrank##D##mtypekind @\
@\
    ! input arguments @\
    type(ESMF_Mesh), intent(in) :: mesh                  @\
    mname (ESMF_KIND_##mtypekind), intent(in), target :: farray(mdim) @\
    type(ESMF_Index_Flag), intent(in)            :: indexflag @\
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below @\
    type(ESMF_DataCopy_Flag), intent(in), optional   :: datacopyflag @\
    type(ESMF_MeshLoc), intent(in), optional    :: meshloc @\
    integer, intent(in), optional :: gridToFieldMap(:)     @\
    integer, intent(in), optional :: ungriddedLBound(:) @\
    integer, intent(in), optional :: ungriddedUBound(:) @\
    character (len=*), intent(in), optional :: name  @\
    integer, intent(out), optional :: rc                @\
@\
    integer :: localrc                       !  Local error code@\
    type(ESMF_Geom) :: geom @\
@\
    ! Initialize @\
    localrc = ESMF_RC_NOT_IMPL@\
@\
    ! Initialize return code   @\
    if (present(rc)) then@\
      rc = ESMF_RC_NOT_IMPL@\
    endif     @\
@\
    ! check init status of input parameters@\
    ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc)@\
@\
@\
    ! Create Geom from Mesh@\
    geom=ESMF_GeomCreate(mesh, meshLoc=meshloc, rc=localrc)@\
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &@\
      ESMF_CONTEXT, rcToReturn=rc)) return@\
@\
@\
       ESMF_FieldCreateMeshData##mrank##D##mtypekind = & @\
              ESMF_FieldCreateGBData##mrank##D##mtypekind(geom, & @\
                               farray, indexflag=indexflag, datacopyflag=datacopyflag, & @\
                               gridToFieldMap=gridToFieldMap, & @\
                               ungriddedLBound=ungriddedLBound, & @\
                               ungriddedUBound=ungriddedUBound, & @\
                               name=name, rc=localrc) @\
    if (ESMF_LogFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
@\
    ! remember that geom was created internally @\
    ESMF_FieldCreateMeshData##mrank##D##mtypekind%ftypep%geomb_internal = .true. @\
@\
    if (present(rc)) rc = ESMF_SUCCESS @\
  end function ESMF_FieldCreateMeshData##mrank##D##mtypekind  @\
!------------------------------------------------------------------------------ @\

TypeKindRankDeclarationMacro(FieldCreateMeshData)


#define FieldCreateMeshDataPtrDoc() \
!---------------------------------------------------------------------------- @\
!BOP @\
! !IROUTINE: ESMF_FieldCreate - Create a Field from Mesh and Fortran array pointer @\
! @\
! !INTERFACE: @\
! ! Private name; call using ESMF_FieldCreate() @\
! function ESMF_FieldCreateMeshDataPtr<rank><type><kind>(mesh, & @\
!   farrayPtr, keywordEnforcer, datacopyflag, meshloc, gridToFieldMap, & @\
!   name, rc) @\
! @\
! !RETURN VALUE: @\
!   type(ESMF_Field) :: ESMF_FieldCreateMeshDataPtr<rank><type><kind> @\
! @\
! !ARGUMENTS: @\
!   type(ESMF_Mesh),          intent(in)            :: mesh              @\
!   <type> (ESMF_KIND_<kind>),pointer               :: farrayPtr(<rank>) @\
!type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below @\
!   type(ESMF_DataCopy_Flag), intent(in),  optional :: datacopyflag      @\
!   type(ESMF_MeshLoc),       intent(in),  optional :: meshloc           @\
!   integer,                  intent(in),  optional :: gridToFieldMap(:) @\
!   character (len=*),        intent(in),  optional :: name              @\
!   integer,                  intent(out), optional :: rc                @\
! @\
! !DESCRIPTION: @\
! Create an {\tt ESMF\_Field} from a Fortran data pointer and {\tt ESMF\_Mesh}. @\
! The Fortran data pointer inside {\tt ESMF\_Field} can be queried and deallocated when @\
! datacopyflag is {\tt ESMF\_DATACOPY\_REFERENCE}. Note that the {\tt ESMF\_FieldDestroy} call does not @\
! deallocate the Fortran data pointer in this case. This gives user more flexibility over memory management. @\
! @\
! The arguments are: @\
! \begin{description} @\
! \item [mesh]  @\
!       {\tt ESMF\_Mesh} object. @\
! \item [farrayPtr] @\
!       Native Fortran data pointer to be copied/referenced in the Field @\
!       The Field dimension (dimCount) will be the same as the dimCount @\
!       for the {\tt farrayPtr}. @\
! \item [{[datacopyflag]}] @\
!       Whether to copy the contents of the {\tt farrayPtr} or reference it directly. @\
!       For valid values see \ref{const:datacopyflag}.  The default is @\
!       {\tt ESMF\_DATACOPY\_REFERENCE}. @\
! \item [{[meshloc]}] @\
!       \begin{sloppypar} @\
!       The part of the Mesh on which to build the Field. For valid @\
!       predefined values see Section~\ref{const:meshloc}. @\
!       If not set, defaults to {\tt ESMF\_MESHLOC\_NODE}. @\
!       \end{sloppypar} @\
! \item [{[gridToFieldMap]}] @\
!       List with number of elements equal to the @\
!       {\tt mesh}|s dimCount.  The list elements map each dimension @\
!       of the {\tt mesh} to a dimension in the {\tt farrayPtr} by @\
!       specifying the appropriate {\tt farrayPtr} dimension index. The default is to @\
!       map all of the {\tt mesh}|s dimensions against the lowest dimensions of @\
!       the {\tt farrayPtr} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../). @\
!       The values of all {\tt gridToFieldMap} entries must be greater than or equal @\
!       to one and smaller than or equal to the {\tt farrayPtr} rank. @\
!       It is erroneous to specify the same {\tt gridToFieldMap} entry @\
!       multiple times. The total ungridded dimensions in the {\tt field} @\
!       are the total {\tt farrayPtr} dimensions less @\
!       the total (distributed + undistributed) dimensions in @\
!       the {\tt mesh}.  Unmeshded dimensions must be in the same order they are @\
!       stored in the {\t farrayPtr}.  Permutations of the order of @\
!       dimensions are handled via individual communication methods.  For example, @\
!       an undistributed dimension can be remapped to a distributed dimension @\
!       as part of the {\tt ESMF\_ArrayRedist()} operation. @\
!       If the Field dimCount is less than the Mesh dimCount then the default @\
!       gridToFieldMap will contain zeros for the rightmost entries. A zero @\
!       entry in the {\tt gridToFieldMap} indicates that the particular @\
!       Mesh dimension will be replicating the Field across the DEs along @\
!       this direction. @\
! \item [{[name]}]  @\
!       Field name.  @\
! \item [{[rc]}]  @\
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
! \end{description} @\
! @\
!EOP @\
!---------------------------------------------------------------------------- @\

#define FieldCreateMeshDataPtrMacro(mname, mtypekind, mrank, mdim, mlen, mrng, mloc) \
!---------------------------------------------------------------------------- @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_FieldCreateMeshDataPtr" @\
  function ESMF_FieldCreateMeshDataPtr##mrank##D##mtypekind(mesh, & @\
    farrayPtr, keywordEnforcer, datacopyflag, meshloc, gridToFieldMap, & @\
    name, rc) @\
@\
    ! return value @\
    type(ESMF_Field) :: ESMF_FieldCreateMeshDataPtr##mrank##D##mtypekind @\
@\
    ! input arguments @\
    type(ESMF_Mesh), intent(in) :: mesh                  @\
    mname (ESMF_KIND_##mtypekind), dimension(mdim), pointer :: farrayPtr @\
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below @\
    type(ESMF_DataCopy_Flag), intent(in), optional   :: datacopyflag @\
    type(ESMF_MeshLoc), intent(in), optional :: meshloc @\
    integer, intent(in), optional :: gridToFieldMap(:)     @\
    character (len=*), intent(in), optional :: name  @\
    integer, intent(out), optional :: rc                @\
@\
    integer :: localrc                       !  Local error code@\
    type(ESMF_Geom) :: geom @\
@\
    ! Initialize @\
    localrc = ESMF_RC_NOT_IMPL@\
@\
    ! Initialize return code   @\
    if (present(rc)) then@\
      rc = ESMF_RC_NOT_IMPL@\
    endif     @\
@\
    ! check init status of input parameters@\
    ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc)@\
@\
@\
    ! Create Geom from Mesh@\
    geom=ESMF_GeomCreate(mesh, meshLoc=meshloc, rc=localrc)@\
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &@\
      ESMF_CONTEXT, rcToReturn=rc)) return@\
@\
@\
       ESMF_FieldCreateMeshDataPtr##mrank##D##mtypekind = & @\
              ESMF_FieldCreateGBDataPtr##mrank##D##mtypekind(geom, & @\
                               farrayPtr, datacopyflag=datacopyflag, & @\
                               gridToFieldMap=gridToFieldMap, & @\
                               name=name, rc=localrc) @\
    if (ESMF_LogFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
@\
    ! remember that geom was created internally @\
    ESMF_FieldCreateMeshDataPtr##mrank##D##mtypekind%ftypep%geomb_internal = .true. @\
@\
    if (present(rc)) rc = ESMF_SUCCESS @\
  end function ESMF_FieldCreateMeshDataPtr##mrank##D##mtypekind  @\
!------------------------------------------------------------------------------ @\

TypeKindRankDeclarationMacro(FieldCreateMeshDataPtr)

!------------------------------------------------------------------------------


! ESMF_FieldCreateXGrid
!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_FieldCreateXGTKR"
!BOP
! !IROUTINE:   ESMF_FieldCreate - Create a Field from XGrid and typekind

! !INTERFACE:
  ! Private name; call using ESMF_FieldCreate()
  function ESMF_FieldCreateXGTKR(xgrid, typekind, keywordEnforcer, xgridside, &
    gridindex, gridToFieldMap, ungriddedLBound, ungriddedUBound, &
    pinflag, name, rc)
!
! !RETURN VALUE:
    type(ESMF_Field) :: ESMF_FieldCreateXGTKR
!
! !ARGUMENTS:
    type(ESMF_XGrid),          intent(in)            :: xgrid
    type(ESMF_TypeKind_Flag),  intent(in)            :: typekind
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
    type(ESMF_XGridSide_Flag), intent(in),  optional :: xgridside
    integer,                   intent(in),  optional :: gridindex
    integer,                   intent(in),  optional :: gridToFieldMap(:)
    integer,                   intent(in),  optional :: ungriddedLBound(:)
    integer,                   intent(in),  optional :: ungriddedUBound(:)
    type(ESMF_Pin_Flag),       intent(in),  optional :: pinflag
    character (len=*),         intent(in),  optional :: name
    integer,                   intent(out), optional :: rc
!
! !DESCRIPTION:
! Create an {\tt ESMF\_Field} and allocate space internally for an
! {\tt ESMF\_Array}.  Return a new {\tt ESMF\_Field}. For an example and
! associated documentation using this method see section
! \ref{sec:field:usage:create_locs_tkr}.
!
! The arguments are:
! \begin{description}
! \item [xgrid]
!       {\tt ESMF\_XGrid} object.
! \item[typekind]
!       The typekind of the Field. See section \ref{const:typekind}
!       for a list of valid typekind options.
! \item [{[xgridside]}]
!       Which side of the XGrid to create the Field on (either ESMF\_XGRIDSIDE\_A,
!       ESMF\_XGRIDSIDE\_B, or ESMF\_XGRIDSIDE\_BALANCED). If not passed in then
!       defaults to ESMF\_XGRIDSIDE\_BALANCED.
! \item [{[gridindex]}]
!       If xgridSide is  ESMF\_XGRIDSIDE\_A or ESMF\_XGRIDSIDE\_B then this index tells which Grid on
!       that side to create the Field on. If not provided, defaults to 1.
! \item [{[gridToFieldMap]}]
!       List with number of elements equal to the
!       {\tt grid}|s dimCount.  The list elements map each dimension
!       of the {\tt grid} to a dimension in the {\tt field} by
!       specifying the appropriate {\tt field} dimension index. The default is to
!       map all of the {\tt grid}|s dimensions against the lowest dimensions of
!       the {\tt field} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../).
!       The values of all {\tt gridToFieldMap} entries must be greater than or equal
!       to one and smaller than or equal to the {\tt field} rank.
!       It is erroneous to specify the same {\tt gridToFieldMap} entry
!       multiple times. The total ungridded dimensions in the {\tt field}
!       are the total {\tt field} dimensions less
!       the dimensions in
!       the {\tt grid}.  Ungridded dimensions must be in the same order they are
!       stored in the {\t field}.
!       If the Field dimCount is less than the XGrid dimCount then the default
!       gridToFieldMap will contain zeros for the rightmost entries. A zero
!       entry in the {\tt gridToFieldMap} indicates that the particular
!       XGrid dimension will be replicating the Field across the DEs along
!       this direction.
! \item [{[ungriddedLBound]}]
!       Lower bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded
!       dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. When field dimension count is
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound
!       must be specified. When both are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt field}.
! \item [{[ungriddedUBound]}]
!       Upper bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded
!       dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. When field dimension count is
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound
!       must be specified. When both are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt field}.
! \item[{[pinflag]}]
!      Specify which type of resource DEs are pinned to.  See section 
!      \ref{const:pin_flag} for a list of valid pinning options.
!      The default is to pin DEs to PETs, i.e. only the PET on which a DE
!      was created considers the DE as local.
! \item [{[name]}]
!       Field name.
! \item [{[rc]}]
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!EOP
!------------------------------------------------------------------------------
    integer :: localrc                          !  Local error code
    type(ESMF_ArraySpec) :: arrayspec
    type(ESMF_XGridGeomBase)  :: xgeom
    integer :: rank, ungridded_dimcount, ungridded_ldimcount, ungridded_udimcount

    ! Initialize
    localrc = ESMF_RC_NOT_IMPL

    ! Initialize return code
    if(present(rc)) rc = ESMF_RC_NOT_IMPL

    ! Compute rank
    if(.not. present(xgridside)) then
      ungridded_dimcount = 0
      if(present(ungriddedLBound)) then
        ungridded_ldimcount = size(ungriddedLBound)
        ungridded_dimcount = ungridded_ldimcount
      endif
      if(present(ungriddedUBound)) then
        ungridded_udimcount = size(ungriddedUBound)
        ungridded_dimcount = ungridded_udimcount
      endif

      rank = ungridded_dimcount + 1
    else
      if(xgridside==ESMF_XGRIDSIDE_BALANCED) then
        ungridded_dimcount = 0
        if(present(ungriddedLBound)) then
          ungridded_ldimcount = size(ungriddedLBound)
          ungridded_dimcount = ungridded_ldimcount
        endif
        if(present(ungriddedUBound)) then
          ungridded_udimcount = size(ungriddedUBound)
          ungridded_dimcount = ungridded_udimcount
        endif

        rank = ungridded_dimcount + 1
      else
        call ESMF_XGridGet(xgrid, xgeom, &
          xgridside=xgridside, gridindex=gridindex, rc=localrc)
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) return
        call ESMF_XGridGeomBaseGet(xgeom, dimCount=rank, rc=localrc)
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) return
      endif
    endif

    ! Set ArraySpec from rank and typekind input
    call ESMF_ArraySpecSet(arrayspec, rank=rank, typekind=typekind, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
        ESMF_CONTEXT, rcToReturn=rc)) return

    ESMF_FieldCreateXGTKR = ESMF_FieldCreate(xgrid, arrayspec, &
        xgridside=xgridside, gridindex=gridIndex, &
        gridToFieldMap=gridToFieldMap, ungriddedLBound=ungriddedLBound, &
        ungriddedUBound=ungriddedUBound, pinflag=pinflag, name=name, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
        ESMF_CONTEXT, rcToReturn=rc)) return

    ! Return successfully
    if (present(rc)) rc = ESMF_SUCCESS

end function ESMF_FieldCreateXGTKR
!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_FieldCreateXGArraySpec"
!BOP
! !IROUTINE:   ESMF_FieldCreate - Create a Field from XGrid and ArraySpec

! !INTERFACE:
  ! Private name; call using ESMF_FieldCreate()
  function ESMF_FieldCreateXGArraySpec(xgrid, arrayspec, keywordEnforcer, &
    xgridside, gridindex, gridToFieldMap, ungriddedLBound, ungriddedUBound, &
    pinflag, name, rc)
!
! !RETURN VALUE:
    type(ESMF_Field) :: ESMF_FieldCreateXGArraySpec
!
! !ARGUMENTS:
    type(ESMF_XGrid),          intent(in)            :: xgrid
    type(ESMF_ArraySpec),      intent(in)            :: arrayspec
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
    type(ESMF_XGridSide_Flag), intent(in),  optional :: xgridSide
    integer,                   intent(in),  optional :: gridIndex
    integer,                   intent(in),  optional :: gridToFieldMap(:)
    integer,                   intent(in),  optional :: ungriddedLBound(:)
    integer,                   intent(in),  optional :: ungriddedUBound(:)
    type(ESMF_Pin_Flag),       intent(in),  optional :: pinflag
    character (len=*),         intent(in),  optional :: name
    integer,                   intent(out), optional :: rc
!
! !DESCRIPTION:
! Create an {\tt ESMF\_Field} and allocate space internally for an
! {\tt ESMF\_Array}.  Return a new {\tt ESMF\_Field}. For an example and
! associated documentation using this method see section
! \ref{sec:field:usage:create_locs_arrayspec}.
!
! The arguments are:
! \begin{description}
! \item [xgrid]
!       {\tt ESMF\_XGrid} object.
! \item [arrayspec]
!       Data type and kind specification.
! \item [{[xgridside]}]
!       Which side of the XGrid to create the Field on (either ESMF\_XGRIDSIDE\_A,
!       ESMF\_XGRIDSIDE\_B, or ESMF\_XGRIDSIDE\_BALANCED). If not passed in then
!       defaults to ESMF\_XGRIDSIDE\_BALANCED.
! \item [{[gridindex]}]
!       If xgridside is  ESMF\_XGRIDSIDE\_A or ESMF\_XGRIDSIDE\_B then this index tells which Grid on
!       that side to create the Field on. If not provided, defaults to 1.
! \item [{[gridToFieldMap]}]
!       List with number of elements equal to the
!       {\tt grid}|s dimCount.  The list elements map each dimension
!       of the {\tt grid} to a dimension in the {\tt field} by
!       specifying the appropriate {\tt field} dimension index. The default is to
!       map all of the {\tt grid}|s dimensions against the lowest dimensions of
!       the {\tt field} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../).
!       The values of all {\tt gridToFieldMap} entries must be greater than or equal
!       to one and smaller than or equal to the {\tt field} rank.
!       It is erroneous to specify the same {\tt gridToFieldMap} entry
!       multiple times. The total ungridded dimensions in the {\tt field}
!       are the total {\tt field} dimensions less
!       the dimensions in
!       the {\tt grid}.  Ungridded dimensions must be in the same order they are
!       stored in the {\t field}.
!       If the Field dimCount is less than the XGrid dimCount then the default
!       gridToFieldMap will contain zeros for the rightmost entries. A zero
!       entry in the {\tt gridToFieldMap} indicates that the particular
!       XGrid dimension will be replicating the Field across the DEs along
!       this direction.
! \item [{[ungriddedLBound]}]
!       Lower bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded
!       dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. When field dimension count is
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound
!       must be specified. When both are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt field}.
! \item [{[ungriddedUBound]}]
!       Upper bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded
!       dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. When field dimension count is
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound
!       must be specified. When both are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt field}.
! \item[{[pinflag]}]
!      Specify which type of resource DEs are pinned to.  See section 
!      \ref{const:pin_flag} for a list of valid pinning options.
!      The default is to pin DEs to PETs, i.e. only the PET on which a DE
!      was created considers the DE as local.
! \item [{[name]}]
!       Field name.
! \item [{[rc]}]
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!EOP
!------------------------------------------------------------------------------
    integer :: localrc                          !  Local error code
    type(ESMF_Geom) :: geom
    integer :: ungridded_ldimcount, ungridded_udimcount

    ! Initialize
    localrc = ESMF_RC_NOT_IMPL

    ! Initialize return code
    if(present(rc)) then
      rc = ESMF_RC_NOT_IMPL
    endif

    ! check init status of input parameters
    ESMF_INIT_CHECK_DEEP(ESMF_XGridGetInit,xgrid,rc)
    ESMF_INIT_CHECK_SHALLOW(ESMF_ArraySpecGetInit, arrayspec, rc)

    ! Sanity checking
    if(present(ungriddedLBound) .and. present(ungriddedUBound)) then
      if(present(ungriddedLBound)) then
        ungridded_ldimcount = size(ungriddedLBound)
      endif
      if(present(ungriddedUBound)) then
        ungridded_udimcount = size(ungriddedUBound)
      endif
      if(ungridded_ldimcount /= ungridded_udimcount) then
        call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, &
          msg="- ungriddedLBound size must equal to ungriddedUBound size", &
          ESMF_CONTEXT, rcToReturn=rc)
        return
      endif
    endif

    ! Create Geom from Xgrid
    geom=ESMF_GeomCreate(xgrid, xgridSide, gridIndex, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
      ESMF_CONTEXT, rcToReturn=rc)) return

    ! Create Field from Geom
    ESMF_FieldCreateXGArraySpec=ESMF_FieldCreateGBArraySpec(geom, &
        arrayspec, gridToFieldMap, &
        ungriddedLBound, ungriddedUBound, &
        pinflag=pinflag, name=name, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
      ESMF_CONTEXT, rcToReturn=rc)) return

    ! remember that geom was created internally
    ESMF_FieldCreateXGArraySpec%ftypep%geomb_internal = .true.

    if(present(rc)) rc = ESMF_SUCCESS

  end function ESMF_FieldCreateXGArraySpec
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_FieldCreateXGArray"
!BOP
! !IROUTINE: ESMF_FieldCreate - Create a Field from XGrid and Array

! !INTERFACE:
  ! Private name; call using ESMF_FieldCreate()
  function ESMF_FieldCreateXGArray(xgrid, array, &
    keywordEnforcer, datacopyflag, xgridside, gridindex, &
    gridToFieldMap, ungriddedLBound, ungriddedUBound, &
    name, rc)
!
! !RETURN VALUE:
    type(ESMF_Field) :: ESMF_FieldCreateXGArray
!
! !ARGUMENTS:
    type(ESMF_XGrid),          intent(in)            :: xgrid
    type(ESMF_Array),          intent(in)            :: array
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
    type(ESMF_DataCopy_Flag),  intent(in),  optional :: datacopyflag
    type(ESMF_XGridSide_Flag), intent(in),  optional :: xgridside
    integer,                   intent(in),  optional :: gridindex
    integer,                   intent(in),  optional :: gridToFieldMap(:)
    integer,                   intent(in),  optional :: ungriddedLBound(:)
    integer,                   intent(in),  optional :: ungriddedUBound(:)
    character (len = *),       intent(in),  optional :: name
    integer,                   intent(out), optional :: rc
!
! !DESCRIPTION:
! Create an {\tt ESMF\_Field}.  This version of creation
! assumes the data exists already and is being
! passed in through an {\tt ESMF\_Array}.  For an example and
! associated documentation using this method see section
! \ref{sec:field:usage:create_grid_array}.
!
! The arguments are:
! \begin{description}
! \item [xgrid]
!       {\tt ESMF\_XGrid} object.
! \item [array]
!       {\tt ESMF\_Array} object.
! \item [{[datacopyflag]}]
!       Indicates whether to copy the contents of the {\tt array} or reference it directly.
!       For valid values see \ref{const:datacopyflag}.  The default is
!       {\tt ESMF\_DATACOPY\_REFERENCE}.
! \item [{[xgridside]}]
!       Which side of the XGrid to create the Field on (either ESMF\_XGRIDSIDE\_A,
!       ESMF\_XGRIDSIDE\_B, or ESMF\_XGRIDSIDE\_BALANCED). If not passed in then
!       defaults to ESMF\_XGRIDSIDE\_BALANCED.
! \item [{[gridindex]}]
!       If xgridSide is  ESMF\_XGRIDSIDE\_A or ESMF\_XGRIDSIDE\_B then this index tells which Grid on
!       that side to create the Field on. If not provided, defaults to 1.
! \item [{[gridToFieldMap]}]
!       List with number of elements equal to the
!       {\tt grid}|s dimCount.  The list elements map each dimension
!       of the {\tt grid} to a dimension in the {\tt field} by
!       specifying the appropriate {\tt field} dimension index. The default is to
!       map all of the {\tt grid}|s dimensions against the lowest dimensions of
!       the {\tt field} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../).
!       The values of all {\tt gridToFieldMap} entries must be greater than or equal
!       to one and smaller than or equal to the {\tt field} rank.
!       It is erroneous to specify the same {\tt gridToFieldMap} entry
!       multiple times. The total ungridded dimensions in the {\tt field}
!       are the total {\tt field} dimensions less
!       the dimensions in
!       the {\tt grid}.  Ungridded dimensions must be in the same order they are
!       stored in the {\t field}.
!       If the Field dimCount is less than the XGrid dimCount then the default
!       gridToFieldMap will contain zeros for the rightmost entries. A zero
!       entry in the {\tt gridToFieldMap} indicates that the particular
!       XGrid dimension will be replicating the Field across the DEs along
!       this direction.
! \item [{[ungriddedLBound]}]
!       Lower bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded
!       dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. When field dimension count is
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound
!       must be specified. When both are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt field}.
! \item [{[ungriddedUBound]}]
!       Upper bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded
!       dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. When field dimension count is
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound
!       must be specified. When both are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt field}.
! \item [{[name]}]
!       Field name.
! \item [{[rc]}]
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!EOP
!------------------------------------------------------------------------------
    integer :: localrc                       !  Local error code
    type(ESMF_Geom) :: geom
    integer :: ungridded_ldimcount, ungridded_udimcount

    ! Initialize
    localrc = ESMF_RC_NOT_IMPL

    ! Initialize return code
    if (present(rc)) then
      rc = ESMF_RC_NOT_IMPL
    endif

    ! check init status of input parameters
    ESMF_INIT_CHECK_DEEP(ESMF_XGridGetInit,xgrid,rc)
    ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc)

    ! Sanity checking
    if(present(ungriddedLBound) .and. present(ungriddedUBound)) then
      if(present(ungriddedLBound)) then
        ungridded_ldimcount = size(ungriddedLBound)
      endif
      if(present(ungriddedUBound)) then
        ungridded_udimcount = size(ungriddedUBound)
      endif
      if(ungridded_ldimcount /= ungridded_udimcount) then
        call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, &
          msg="- ungriddedLBound size must equal to ungriddedUBound size", &
          ESMF_CONTEXT, rcToReturn=rc)
        return
      endif
    endif

    ! Create Geom from Mesh
    geom=ESMF_GeomCreate(xgrid, xgridSide, gridIndex, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
      ESMF_CONTEXT, rcToReturn=rc)) return

    ! Create Field from Geom
    ESMF_FieldCreateXGArray=ESMF_FieldCreateGBArray(geom, array, &
      datacopyflag, gridToFieldMap, ungriddedLBound, ungriddedUBound, &
      name=name, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
      ESMF_CONTEXT, rcToReturn=rc)) return

    ! remember that geom was created internally
    ESMF_FieldCreateXGArray%ftypep%geomb_internal = .true.

    if (present(rc)) rc = ESMF_SUCCESS

  end function ESMF_FieldCreateXGArray
!------------------------------------------------------------------------------


#define FieldCreateXGDataDoc() \
!---------------------------------------------------------------------------- @\
!BOP @\
! !IROUTINE: ESMF_FieldCreate - Create a Field from XGrid and Fortran array @\
! @\
! !INTERFACE: @\
! ! Private name; call using ESMF_FieldCreate() @\
! function ESMF_FieldCreateXGData<rank><type><kind>(xgrid, & @\
!   farray, indexflag, keywordEnforcer, datacopyflag, xgridside, gridindex, & @\
!   gridToFieldMap, ungriddedLBound, ungriddedUBound, name,& @\
!   rc) @\
! @\
! !RETURN VALUE: @\
!   type(ESMF_Field) :: ESMF_FieldCreateXGData<rank><type><kind> @\
! @\
! !ARGUMENTS: @\
!   type(ESMF_XGrid),          intent(in)               :: xgrid              @\
!   <type> (ESMF_KIND_<kind>), intent(in),  target      :: farray(<rank>)     @\
!   type(ESMF_Index_Flag),     intent(in)               :: indexflag          @\
!type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below @\
!   type(ESMF_DataCopy_Flag),  intent(in),  optional    :: datacopyflag       @\
!   type(ESMF_XGridSide_Flag), intent(in),  optional    :: xgridside          @\
!   integer,                   intent(in),  optional    :: gridindex          @\
!   integer,                   intent(in),  optional    :: gridToFieldMap(:)  @\
!   integer,                   intent(in),  optional    :: ungriddedLBound(:) @\
!   integer,                   intent(in),  optional    :: ungriddedUBound(:) @\
!   character (len=*),         intent(in),  optional    :: name               @\
!   integer,                   intent(out), optional    :: rc                 @\
! @\
! !DESCRIPTION: @\
! Create an {\tt ESMF\_Field} from a Fortran data array and {\tt ESMF\_Xgrid}. @\
! The Fortran data pointer inside {\tt ESMF\_Field} can be queried but deallocating @\
! the retrieved data pointer is not allowed. @\
! @\
! The arguments are: @\
! \begin{description} @\
! \item [xgrid] @\
!       {\tt ESMF\_XGrid} object. @\
! \item [farray] @\
!       Native Fortran data array to be copied/referenced in the Field @\
!       The Field dimension (dimCount) will be the same as the dimCount @\
!       for the {\tt farray}. @\
! \item[indexflag] @\
!       Indicate how DE-local indices are defined. See section @\
!       \ref{const:indexflag} for a list of valid indexflag options. @\
! \item [{[datacopyflag]}] @\
!       Whether to copy the contents of the {\tt farray} or reference directly. @\
!       For valid values see \ref{const:datacopyflag}.  The default is @\
!       {\tt ESMF\_DATACOPY\_REFERENCE}. @\
! \item [{[xgridside]}] @\
!       Which side of the XGrid to create the Field on (either ESMF\_XGRIDSIDE\_A, @\
!       ESMF\_XGRIDSIDE\_B, or ESMF\_XGRIDSIDE\_BALANCED). If not passed in then @\
!       defaults to ESMF\_XGRIDSIDE\_BALANCED. @\
! \item [{[gridindex]}] @\
!       If xgridside is  ESMF\_XGRIDSIDE\_A or ESMF\_XGRIDSIDE\_B then this index tells which Grid on @\
!       that side to create the Field on. If not provided, defaults to 1. @\
! \item [{[gridToFieldMap]}] @\
!       List with number of elements equal to the @\
!       {\tt xgrid}|s dimCount.  The list elements map each dimension @\
!       of the {\tt xgrid} to a dimension in the {\tt farray} by @\
!       specifying the appropriate {\tt farray} dimension index. The default is to @\
!       map all of the {\tt xgrid}|s dimensions against the lowest dimensions of @\
!       the {\tt farray} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../). @\
!       The values of all {\tt gridToFieldMap} entries must be greater than or equal @\
!       to one and smaller than or equal to the {\tt farray} rank. @\
!       It is erroneous to specify the same {\tt gridToFieldMap} entry @\
!       multiple times. The total ungridded dimensions in the {\tt field} @\
!       are the total {\tt farray} dimensions less @\
!       the total (distributed + undistributed) dimensions in @\
!       the {\tt xgrid}.  Unxgridded dimensions must be in the same order they are @\
!       stored in the {\t farray}.  Permutations of the order of @\
!       dimensions are handled via individual communication methods.  For example, @\
!       an undistributed dimension can be remapped to a distributed dimension @\
!       as part of the {\tt ESMF\_ArrayRedist()} operation. @\
!       If the Field dimCount is less than the Xgrid dimCount then the default @\
!       gridToFieldMap will contain zeros for the rightmost entries. A zero @\
!       entry in the {\tt gridToFieldMap} indicates that the particular @\
!       Xgrid dimension will be replicating the Field across the DEs along @\
!       this direction. @\
! \item [{[ungriddedLBound]}] @\
!       Lower bounds of the ungridded dimensions of the {\tt field}. @\
!       The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded @\
!       dimensions in the {\tt field}.  All ungridded dimensions of the @\
!       {\tt field} are also undistributed. When field dimension count is @\
!       greater than xgrid dimension count, both ungriddedLBound and ungriddedUBound @\
!       must be specified. When both are specified the values are checked @\
!       for consistency.  Note that the the ordering of @\
!       these ungridded dimensions is the same as their order in the {\tt farray}. @\
! \item [{[ungriddedUBound]}] @\
!       Upper bounds of the ungridded dimensions of the {\tt field}. @\
!       The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded @\
!       dimensions in the {\tt field}.  All ungridded dimensions of the @\
!       {\tt field} are also undistributed. When field dimension count is @\
!       greater than xgrid dimension count, both ungriddedLBound and ungriddedUBound @\
!       must be specified. When both are specified the values are checked @\
!       for consistency.  Note that the the ordering of @\
!       these ungridded dimensions is the same as their order in the {\tt farray}. @\
! \item [{[name]}]  @\
!       Field name.  @\
! \item [{[rc]}]  @\
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
! \end{description} @\
! @\
!EOP @\
!---------------------------------------------------------------------------- @\

#define FieldCreateXGDataMacro(mname, mtypekind, mrank, mdim, mlen, mrng, mloc) \
!---------------------------------------------------------------------------- @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_FieldCreateXGData" @\
  function ESMF_FieldCreateXGData##mrank##D##mtypekind(xgrid, & @\
    farray, indexflag, keywordEnforcer, datacopyflag, xgridside, gridindex, & @\
    gridToFieldMap, ungriddedLBound, ungriddedUBound, name, rc) @\
@\
    ! return value @\
    type(ESMF_Field) :: ESMF_FieldCreateXGData##mrank##D##mtypekind @\
@\
    ! input arguments @\
    type(ESMF_XGrid), intent(in)                      :: xgrid @\
    mname (ESMF_KIND_##mtypekind), intent(in), target :: farray(mdim) @\
    type(ESMF_Index_Flag), intent(in)                 :: indexflag @\
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below @\
    type(ESMF_DataCopy_Flag), intent(in), optional    :: datacopyflag @\
    type(ESMF_XGridSide_Flag), intent(in), optional   :: xgridside @\
    integer, intent(in), optional                     :: gridindex @\
    integer, intent(in), optional                     :: gridToFieldMap(:)     @\
    integer, intent(in), optional                     :: ungriddedLBound(:) @\
    integer, intent(in), optional                     :: ungriddedUBound(:) @\
    character (len=*), intent(in), optional           :: name  @\
    integer, intent(out), optional                    :: rc                @\
@\
    integer :: localrc                       !  Local error code@\
    type(ESMF_Geom) :: geom @\
    integer :: ungridded_ldimcount, ungridded_udimcount @\
@\
    ! Initialize @\
    localrc = ESMF_RC_NOT_IMPL@\
@\
    ! Initialize return code   @\
    if (present(rc)) then@\
      rc = ESMF_RC_NOT_IMPL@\
    endif     @\
@\
    ! check init status of input parameters@\
    ESMF_INIT_CHECK_DEEP(ESMF_XGridGetInit,xgrid,rc)@\
@\
@\
    ! Sanity checking @\
    if(present(ungriddedLBound) .and. present(ungriddedUBound)) then @\
      if(present(ungriddedLBound)) then @\
        ungridded_ldimcount = size(ungriddedLBound) @\
      endif @\
      if(present(ungriddedUBound)) then @\
        ungridded_udimcount = size(ungriddedUBound) @\
      endif @\
      if(ungridded_ldimcount /= ungridded_udimcount) then @\
        call ESMF_LogSetError(rcToCheck=ESMF_RC_ARG_WRONG, &  @\
          msg="- ungriddedLBound size must equal to ungriddedUBound size", &   @\
          ESMF_CONTEXT, rcToReturn=rc)  @\
        return @\
      endif @\
    endif @\
@\
    ! Create Geom from Xgrid@\
    geom=ESMF_GeomCreate(xgrid, xgridSide, gridIndex ,rc=localrc)@\
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &@\
      ESMF_CONTEXT, rcToReturn=rc)) return@\
@\
@\
       ESMF_FieldCreateXGData##mrank##D##mtypekind = & @\
              ESMF_FieldCreateGBData##mrank##D##mtypekind(geom, & @\
                               farray, indexflag=indexflag, datacopyflag=datacopyflag, & @\
                               gridToFieldMap=gridToFieldMap, & @\
                               ungriddedLBound=ungriddedLBound, & @\
                               ungriddedUBound=ungriddedUBound, & @\
                               name=name, rc=localrc) @\
    if (ESMF_LogFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
@\
    ! remember that geom was created internally @\
    ESMF_FieldCreateXGData##mrank##D##mtypekind%ftypep%geomb_internal = .true. @\
@\
    if (present(rc)) rc = ESMF_SUCCESS @\
  end function ESMF_FieldCreateXGData##mrank##D##mtypekind  @\
!------------------------------------------------------------------------------ @\

TypeKindRankDeclarationMacro(FieldCreateXGData)


#define FieldCreateXGDataPtrDoc() \
!---------------------------------------------------------------------------- @\
!BOP @\
! !IROUTINE: ESMF_FieldCreate - Create a Field from XGrid and Fortran array pointer @\
! @\
! !INTERFACE: @\
! ! Private name; call using ESMF_FieldCreate() @\
! function ESMF_FieldCreateXGDataPtr<rank><type><kind>(xgrid, farrayPtr, & @\
!   keywordEnforcer, datacopyflag, xgridside, & @\
!   gridindex, gridToFieldMap, name, rc) @\
! @\
! !RETURN VALUE: @\
!   type(ESMF_Field) :: ESMF_FieldCreateXGDataPtr<rank><type><kind> @\
! @\
! !ARGUMENTS: @\
!   type(ESMF_XGrid),          intent(in)            :: xgrid             @\
!   <type> (ESMF_KIND_<kind>), pointer               :: farrayPtr(<rank>) @\
!type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below @\
!   type(ESMF_DataCopy_Flag),  intent(in),  optional :: datacopyflag      @\
!   type(ESMF_XGridSide_Flag), intent(in),  optional :: xgridside         @\
!   integer,                   intent(in),  optional :: gridindex         @\
!   integer,                   intent(in),  optional :: gridToFieldMap(:) @\
!   character (len=*),         intent(in),  optional :: name              @\
!   integer,                   intent(out), optional :: rc                @\
! @\
! !DESCRIPTION: @\
! Create an {\tt ESMF\_Field} from a Fortran data pointer and {\tt ESMF\_Xgrid}. @\
! The Fortran data pointer inside {\tt ESMF\_Field} can be queried and deallocated when @\
! datacopyflag is {\tt ESMF\_DATACOPY\_REFERENCE}. Note that the {\tt ESMF\_FieldDestroy} call does not @\
! deallocate the Fortran data pointer in this case. This gives user more flexibility over memory management. @\
! @\
! The arguments are: @\
! \begin{description} @\
! \item [xgrid] @\
!       {\tt ESMF\_XGrid} object. @\
! \item [farrayPtr] @\
!       Native Fortran data pointer to be copied/referenced in the Field @\
!       The Field dimension (dimCount) will be the same as the dimCount @\
!       for the {\tt farrayPtr}. @\
! \item [{[datacopyflag]}] @\
!       Whether to copy the contents of the {\tt farrayPtr} or reference it directly. @\
!       For valid values see \ref{const:datacopyflag}.  The default is @\
!       {\tt ESMF\_DATACOPY\_REFERENCE}. @\
! \item [{[xgridside]}] @\
!       Which side of the XGrid to create the Field on (either ESMF\_XGRIDSIDE\_A, @\
!       ESMF\_XGRIDSIDE\_B, or ESMF\_XGRIDSIDE\_BALANCED). If not passed in then @\
!       defaults to ESMF\_XGRIDSIDE\_BALANCED. @\
! \item [{[gridindex]}] @\
!       If xgridside is  ESMF\_XGRIDSIDE\_A or ESMF\_XGRIDSIDE\_B then this index tells which Grid on @\
!       that side to create the Field on. If not provided, defaults to 1. @\
! \item [{[gridToFieldMap]}] @\
!       List with number of elements equal to the @\
!       {\tt xgrid}|s dimCount.  The list elements map each dimension @\
!       of the {\tt xgrid} to a dimension in the {\tt farrayPtr} by @\
!       specifying the appropriate {\tt farrayPtr} dimension index. The default is to @\
!       map all of the {\tt xgrid}|s dimensions against the lowest dimensions of @\
!       the {\tt farrayPtr} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../). @\
!       The values of all {\tt gridToFieldMap} entries must be greater than or equal @\
!       to one and smaller than or equal to the {\tt farrayPtr} rank. @\
!       It is erroneous to specify the same {\tt gridToFieldMap} entry @\
!       multiple times. The total ungridded dimensions in the {\tt field} @\
!       are the total {\tt farrayPtr} dimensions less @\
!       the total (distributed + undistributed) dimensions in @\
!       the {\tt xgrid}.  Unxgridded dimensions must be in the same order they are @\
!       stored in the {\t farrayPtr}.  Permutations of the order of @\
!       dimensions are handled via individual communication methods.  For example, @\
!       an undistributed dimension can be remapped to a distributed dimension @\
!       as part of the {\tt ESMF\_ArrayRedist()} operation. @\
!       If the Field dimCount is less than the Xgrid dimCount then the default @\
!       gridToFieldMap will contain zeros for the rightmost entries. A zero @\
!       entry in the {\tt gridToFieldMap} indicates that the particular @\
!       Xgrid dimension will be replicating the Field across the DEs along @\
!       this direction. @\
! \item [{[name]}]  @\
!       Field name.  @\
! \item [{[rc]}]  @\
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
! \end{description} @\
! @\
!EOP @\
!---------------------------------------------------------------------------- @\

#define FieldCreateXGDataPtrMacro(mname, mtypekind, mrank, mdim, mlen, mrng, mloc) \
!---------------------------------------------------------------------------- @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_FieldCreateXGDataPtr" @\
  function ESMF_FieldCreateXGDataPtr##mrank##D##mtypekind(xgrid, farrayPtr, & @\
    keywordEnforcer, datacopyflag, xgridside, gridindex, gridToFieldMap, & @\
    name, rc) @\
@\
    ! return value @\
    type(ESMF_Field) :: ESMF_FieldCreateXGDataPtr##mrank##D##mtypekind @\
@\
    ! input arguments @\
    type(ESMF_XGrid), intent(in) :: xgrid @\
    mname (ESMF_KIND_##mtypekind), dimension(mdim), pointer :: farrayPtr @\
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below @\
    type(ESMF_DataCopy_Flag), intent(in), optional   :: datacopyflag @\
    type(ESMF_XGridSide_Flag), intent(in), optional  :: xgridside @\
    integer, intent(in), optional               :: gridindex @\
    integer, intent(in), optional :: gridToFieldMap(:)     @\
    character (len=*), intent(in), optional :: name  @\
    integer, intent(out), optional :: rc                @\
@\
    integer :: localrc                       !  Local error code@\
    type(ESMF_Geom) :: geom @\
@\
    ! Initialize @\
    localrc = ESMF_RC_NOT_IMPL@\
@\
    ! Initialize return code   @\
    if (present(rc)) then@\
      rc = ESMF_RC_NOT_IMPL@\
    endif     @\
@\
    ! check init status of input parameters@\
    ESMF_INIT_CHECK_DEEP(ESMF_XGridGetInit,xgrid,rc)@\
@\
@\
    ! Create Geom from Xgrid@\
    geom=ESMF_GeomCreate(xgrid,xgridSide,gridIndex,rc=localrc)@\
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &@\
      ESMF_CONTEXT, rcToReturn=rc)) return@\
@\
@\
       ESMF_FieldCreateXGDataPtr##mrank##D##mtypekind = & @\
              ESMF_FieldCreateGBDataPtr##mrank##D##mtypekind(geom, & @\
                               farrayPtr, datacopyflag=datacopyflag, & @\
                               gridToFieldMap=gridToFieldMap, & @\
                               name=name, rc=localrc) @\
    if (ESMF_LogFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
@\
    ! remember that geom was created internally @\
    ESMF_FieldCreateXGDataPtr##mrank##D##mtypekind%ftypep%geomb_internal = .true. @\
@\
    if (present(rc)) rc = ESMF_SUCCESS @\
  end function ESMF_FieldCreateXGDataPtr##mrank##D##mtypekind  @\
!------------------------------------------------------------------------------ @\

TypeKindRankDeclarationMacro(FieldCreateXGDataPtr)

!------------------------------------------------------------------------------


! -------------------------- ESMF-public method -------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_FieldCreateFromField()"
!BOP
! !IROUTINE: ESMF_FieldCreate - Create Field object from an existing Field object

! !INTERFACE:
  ! Private name; call using ESMF_FieldCreate()
  function ESMF_FieldCreateFromField(field, keywordEnforcer, datacopyflag, &
    trailingUngridSlice, name, rc)
!
! !RETURN VALUE:
    type(ESMF_Field) :: ESMF_FieldCreateFromField
!
! !ARGUMENTS:
       type(ESMF_Field),           intent(in)            :: field
       type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
       type(ESMF_DataCopy_Flag),   intent(in),  optional :: datacopyflag
       integer,                    intent(in),  optional :: trailingUngridSlice(:)
       character (len=*),          intent(in),  optional :: name
       integer,                    intent(out), optional :: rc
!
! !DESCRIPTION:
! Create an {\tt ESMF\_Field} object from an existing Field.
!
! The return value is the newly created {\tt ESMF\_Field} object. Supports array
! slicing.
!
! The arguments are:
! \begin{description}
! \item[field]
!     {\tt ESMF\_Field} object to be used as originator.
! \item[{[datacopyflag]}]
!      Specifies whether the created Field object references the memory
!      allocation provided by {\tt field} directly or copies the data from
!      {\tt field} into a new memory allocation. For valid values see
!      \ref{const:datacopyflag}. The default is {\tt ESMF\_DATACOPY\_VALUE}.
! \item[{[trailingUngridSlice]}]
!      If present, the returned Field refers to a slice of {\tt field}
!      created by removing some or all of the trailing (i.e. rightmost)
!      ungridded dimensions from the incoming Field object.
!      The number of trailing dimensions removed is equal to the size $n$
!      of {\tt trailingUngridSlice}, which must be less than or equal to the
!      total number of trailing ungridded dimensions in {\tt field}.
!      The {\tt trailingUngridSlice} argument is interpreted
!      as an index tuple for the $n$ trailing ungridded
!      dimensions in {\tt field} in order, and the Field slice at that
!      location is returned.
! \item[{[name]}]
!      Name of the Field object.
! \item[{[rc]}]
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!EOP
!------------------------------------------------------------------------------
    integer                 :: localrc    ! local return code
    type(ESMF_Array)        :: array, arrayOut
    type(ESMF_Geom)         :: geom
    integer                 :: dimCount
    integer, allocatable    :: gridToFieldMap(:)
    integer, allocatable    :: ungriddedLBound(:), ungriddedUBound(:)

    ! Initialize return code; assume failure until success is certain
    localrc = ESMF_RC_NOT_IMPL
    if (present(rc)) rc = ESMF_RC_NOT_IMPL

    ESMF_INIT_CHECK_DEEP_SHORT(ESMF_FieldGetInit, field, rc)

    call ESMF_FieldGet(field, array=array, geom=geom, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
      ESMF_CONTEXT, rcToReturn=rc)) return

    call ESMF_GeomGet(geom, dimCount=dimCount, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
      ESMF_CONTEXT, rcToReturn=rc)) return

    allocate(gridToFieldMap(dimCount))
    call ESMF_FieldGet(field, gridToFieldMap=gridToFieldMap, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
      ESMF_CONTEXT, rcToReturn=rc)) return

    ! created array slice
    arrayOut = ESMF_ArrayCreate(array, datacopyflag=datacopyflag, &
      trailingUndistSlice=trailingUngridSlice, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
      ESMF_CONTEXT, rcToReturn=rc)) return

    call ESMF_ArrayGet(arrayOut, undistDimCount=dimCount, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
      ESMF_CONTEXT, rcToReturn=rc)) return

    allocate(ungriddedLBound(dimCount))
    allocate(ungriddedUBound(dimCount))

    call ESMF_ArrayGet(arrayOut, undistLBound=ungriddedLBound, &
      undistUBound=ungriddedUBound, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
      ESMF_CONTEXT, rcToReturn=rc)) return

    ESMF_FieldCreateFromField = ESMF_FieldCreate(geom, arrayOut, &
      ESMF_DATACOPY_REFERENCE, gridToFieldMap=gridToFieldMap, &
      ungriddedLBound=ungriddedLBound, ungriddedUBound=ungriddedUBound, &
!      totalLWidth, totalUWidth, &
      name=name, rc=localrc)
    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
      ESMF_CONTEXT, rcToReturn=rc)) return

    ! Return successfully
    if (present(rc)) rc = ESMF_SUCCESS

  end function ESMF_FieldCreateFromField
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_FieldDestroy"
!BOP
! !IROUTINE: ESMF_FieldDestroy - Release resources associated with a Field
! !INTERFACE:
  subroutine ESMF_FieldDestroy(field, keywordEnforcer, noGarbage, rc)
!
! !ARGUMENTS:
    type(ESMF_Field), intent(inout)          :: field
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
    logical,          intent(in),   optional :: noGarbage
    integer,          intent(out),  optional :: rc
!
! !STATUS:
! \begin{itemize}
! \item\apiStatusCompatibleVersion{5.2.0r}
! \item\apiStatusModifiedSinceVersion{5.2.0r}
! \begin{description}
! \item[7.0.0] Added argument {\tt noGarbage}.
!   The argument provides a mechanism to override the default garbage collection
!   mechanism when destroying an ESMF object.
! \end{description}
! \end{itemize}
!
! !DESCRIPTION:
!   Destroys the {\tt ESMF\_Field}, releasing the resources associated with
!   the object.
!
!   If an {\tt ESMF\_Grid} is associated with {\tt field}, it will not be
!   released.
!
!   By default a small remnant of the object is kept in memory in order to
!   prevent problems with dangling aliases. The default garbage collection
!   mechanism can be overridden with the {\tt noGarbage} argument.
!
! The arguments are:
! \begin{description}
! \item[field]
!      {\tt ESMF\_Field} object.
! \item[{[noGarbage]}]
!      If set to {\tt .TRUE.} the object will be fully destroyed and removed
!      from the ESMF garbage collection system. Note however that under this
!      condition ESMF cannot protect against accessing the destroyed object
!      through dangling aliases -- a situation which may lead to hard to debug
!      application crashes.
!
!      It is generally recommended to leave the {\tt noGarbage} argument
!      set to {\tt .FALSE.} (the default), and to take advantage of the ESMF
!      garbage collection system which will prevent problems with dangling
!      aliases or incorrect sequences of destroy calls. However this level of
!      support requires that a small remnant of the object is kept in memory
!      past the destroy call. This can lead to an unexpected increase in memory
!      consumption over the course of execution in applications that use
!      temporary ESMF objects. For situations where the repeated creation and
!      destruction of temporary objects leads to memory issues, it is
!      recommended to call with {\tt noGarbage} set to {\tt .TRUE.}, fully
!      removing the entire temporary object from memory.
! \item[{[rc]}]
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
!EOP
!------------------------------------------------------------------------------
    integer                 :: localrc        ! local return code

    ! Initialize
    localrc = ESMF_RC_NOT_IMPL
    if (present(rc)) rc = ESMF_RC_NOT_IMPL

    ! check input variables
    ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc)

    ! more input checking
    if (.not.associated(field%ftypep)) then
      call ESMF_LogSetError(rcToCheck=ESMF_RC_OBJ_BAD, &
        msg="Uninitialized or already destroyed Field: ftypep unassociated", &
        ESMF_CONTEXT, rcToReturn=rc)
      return
    endif

    ! Destruct all field internals and then free field memory.
    call ESMF_FieldDestruct(field%ftypep, noGarbage, rc=localrc)
    if (ESMF_LogFoundError(localrc, &
      ESMF_ERR_PASSTHRU, &
      ESMF_CONTEXT, rcToReturn=rc)) return

    if (present(noGarbage)) then
      if (noGarbage) then
        ! destroy Base object (which also removes it from garbage collection)
        call ESMF_BaseDestroy(field%ftypep%base, noGarbage, rc=localrc)
        if (ESMF_LogFoundError(localrc, &
          ESMF_ERR_PASSTHRU, &
          ESMF_CONTEXT, rcToReturn=rc)) return
        ! remove reference to this object from ESMF garbage collection table
        call c_ESMC_VMRmFObject(field)
        ! deallocate the actual field data structure
        deallocate(field%ftypep, stat=localrc)
        if (ESMF_LogFoundDeallocError(localrc, &
          msg="Deallocating Field information", &
          ESMF_CONTEXT, rcToReturn=rc)) return
      endif
    endif

    ! Mark this field as invalid
    nullify(field%ftypep)

    ! Set init code
    ESMF_INIT_SET_DELETED(field)

    ! Return successfully
    if (present(rc)) rc = ESMF_SUCCESS

  end subroutine ESMF_FieldDestroy
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_FieldDestruct"
!BOPI
! !IROUTINE:   ESMF_FieldDestruct - Release Field memory allocated internally
!
! !INTERFACE:
  subroutine ESMF_FieldDestruct(ftype, noGarbage, rc)
!
! !ARGUMENTS:
    type(ESMF_FieldType), pointer               :: ftype
    logical,              intent(in),  optional :: noGarbage
    integer,              intent(out), optional :: rc
!
! !DESCRIPTION:
! Releases all resources except the {\tt ESMF\_Field} itself.
!
! The arguments are:
! \begin{description}
! \item[ftype]
!      Pointer to an {\tt ESMF\_Field} object.
! \item[{[noGarbage]}]
!      If set to {\tt .TRUE.} the object will be fully destroyed and removed
!      from the ESMF garbage collection system. Note however that under this
!      condition ESMF cannot protect against accessing the destroyed object
!      through dangling aliases -- a situation which may lead to hard to debug
!      application crashes.
!
!      It is generally recommended to leave the {\tt noGarbage} argument
!      set to {\tt .FALSE.} (the default), and to take advantage of the ESMF
!      garbage collection system which will prevent problems with dangling
!      aliases or incorrect sequences of destroy calls. However this level of
!      support requires that a small remnant of the object is kept in memory
!      past the destroy call. This can lead to an unexpected increase in memory
!      consumption over the course of execution in applications that use
!      temporary ESMF objects. For situations where the repeated creation and
!      destruction of temporary objects leads to memory issues, it is
!      recommended to call with {\tt noGarbage} set to {\tt .TRUE.}, fully
!      removing the entire temporary object from memory.
! \item[{[rc]}]
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!EOPI
!------------------------------------------------------------------------------
    integer                 :: localrc        ! local return code
    type(ESMF_Status)       :: basestatus

    ! Initialize
    localrc = ESMF_RC_NOT_IMPL
    if (present(rc)) rc = ESMF_RC_NOT_IMPL

    call ESMF_BaseGetStatus(ftype%base, basestatus, rc=localrc)
    if (ESMF_LogFoundError(localrc, &
        ESMF_ERR_PASSTHRU, &
        ESMF_CONTEXT, rcToReturn=rc)) return

    if (basestatus .eq. ESMF_STATUS_READY) then
       if(ftype%status .eq. ESMF_FIELDSTATUS_COMPLETE) then

        ! Destroy Array
        call ESMF_FieldDestructArray(ftype, noGarbage, rc=localrc)        
        if (ESMF_LogFoundError(localrc, &
             ESMF_ERR_PASSTHRU, &
             ESMF_CONTEXT, rcToReturn=rc)) return
        
        ! Destroy geometry
        call ESMF_FieldDestructGeom(ftype, noGarbage, rc=localrc)
        if (ESMF_LogFoundError(localrc, &
             ESMF_ERR_PASSTHRU, &
             ESMF_CONTEXT, rcToReturn=rc)) return

        ! Mark invalid
        ftype%status = ESMF_FIELDSTATUS_UNINIT
      endif
    endif

    ! mark object invalid
    call ESMF_BaseSetStatus(ftype%base, ESMF_STATUS_INVALID, rc=localrc)
    if (ESMF_LogFoundError(localrc, &
      ESMF_ERR_PASSTHRU, &
      ESMF_CONTEXT, rcToReturn=rc)) return

    if  (present(rc)) rc = ESMF_SUCCESS

  end subroutine ESMF_FieldDestruct
!------------------------------------------------------------------------------

end module ESMF_FieldCreateMod
