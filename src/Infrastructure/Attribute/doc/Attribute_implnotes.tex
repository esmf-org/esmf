% $Id$
%
% Earth System Modeling Framework
% Copyright 2002-2016, University Corporation for Atmospheric Research,
% Massachusetts Institute of Technology, Geophysical Fluid Dynamics
% Laboratory, University of Michigan, National Centers for Environmental
% Prediction, Los Alamos National Laboratory, Argonne National Laboratory,
% NASA Goddard Space Flight Center.
% Licensed under the University of Illinois-NCSA License.

This section covers Attribute memory deallocation, the use of {\tt ESMF\_AttributeGet()}, Attribute package nesting capabilities, issues with Attributes in a distributed environment, and reading/writing of Attributes via XML files.  Issues and procedures dealing with Attribute memory deallocation, using {\tt ESMF\_AttributeGet()} to retrieve Attribute lists, and nested Attribute package capabilities are discussed to help avoid misuse.  The limitations with Attributes in a distributed environment are also discussed, with an outline of the future work to be done in this area. 

\subsubsection{Attribute memory deallocation}

The Attribute class presents a somewhat different paradigm with respect to memory deallocation than other ESMF objects.  The {\tt ESMF\_AttributeRemove()} call can be issued to remove any Attribute from an ESMF object or an Attribute package on an ESMF object.  This call is also enabled to remove entire Attribute packages with one call, which would remove any nested Attribute packages as well.  The user is {\bf not} required to remove all Attributes that are used in a model run.  The entire Attribute hierarchy will be removed automatically by ESMF, provided the ESMF objects which contain them are properly destroyed.  

The decision to remove either an Attribute or an Attribute package is made by calling {\tt ESMF\_AttributeRemove()} with the correct optional arguments.  If an Attribute which is not associated with any Attribute package should be removed, then the call must be issued without a convention or purpose argument.  If an Attribute in an Attribute package is to be removed, then the call should be issued with all three of name, convention, and purpose.  Finally, if an entire Attribute package is to be removed the call should be issued with a convention and purpose, but no Attribute name.

\subsubsection{Using {\tt ESMF\_AttributeGet()} to retrieve Attribute lists}

The behavior of the {\tt ESMF\_AttributeGet()} routine, when retrieving an Attribute containing a value list, follows a slightly different convention than other similar ESMF routines.  This routine requires the input of a Fortran array as a place to store the retrieved values of the Attribute list.  If the array that is given is longer that the list of Attribute values, the first part of the array will be filled, leaving the extra space untouched.  If, however, the array passed in is shorter than the number of Attribute values, the routine will exit with a return code which is not equal to {\bf ESMF\_SUCCESS}.  It is suggested that if it is required by the user to use a Fortran array that is longer than the number of Attribute values returned, only the indices of the array which the user desires to be filled with retrieved Attribute values should be passed into the routine.  
  
\begin{sloppypar}
Similar behavior is exhibited with the {\tt defaultvalueList} argument in the {\tt ESMF\_AttributeGet()} routine.  The difference here is that if the {\tt valueList} is shorter than the {\tt defaultvalueList} only the appropriate values will be filed in, and the routine will exit without error.  Likewise, if the {\tt valueList} is longer than the {\tt defaultvalueList} then the entire {\tt valueList} will be populated with the beginning section of the {\tt defaultvalueList} that is given.  
\end{sloppypar}

\subsubsection{Using Attribute package nesting capabilites}

There is a recommended practice to organizing metadata conventions when using nested Attribute packages.  The most general Attribute packages should always be added first (innermost parts of the tree), followed by the more specific ones (encompassing tree branches).  For instance, when adding Attribute packages to a Field, it is recommended that the CF convention be added first, followed by the ESMF convention, followed by any additional customized Attribute packages.  

At this time there are several ESMF supplied Attribute packages, with a convention of ESMF and a purpose of General.  These Attribute packages are generated by calling {\tt ESMF\_AttributeAdd()} with the appropriate convention and purpose.  The ESMF standard Attribute packages can be customized by nesting a custom Attribute package around them.

Another consideration when using nested Attribute packages is to remember that when a nested Attribute package is removed every nested Attribute package below the point of removal will also be removed (like pruning a tree branch).  Thus, by removing the ESMF Attribute package on a Field, the CF Attribute package contained within it will also be removed.

\subsubsection{Attributes in a distributed environment}
\label{sec:Att:Dist}

This section discusses the methods of building a consistent view of the metadata across the VM of a model run.  To better explain the ESMF capabilities for ensuring the integrity of Attributes in a distributed environment, a small working vocabulary of ESMF Attributes will be presented.  Three types of changes to an Attribute hierarchy need to be specified, these are: 1. {\bf link changes} are structural links created when two separate Attribute hierarchies are linked, 2. {\bf structural changes} are changes which occur when Attributes or Attribute packages are added or removed within a single level of an Attribute hierarchy, and 3. {\bf value changes} occur when the value portion of any single Attribute is modified.  These definitions will help to describe how {\tt ESMF\_StateReconcile()} and {\tt ESMF\_AttributeUpdate()} can be effectively used to ensure a consistent view of the metadata throughout a model run.

The {\tt ESMF\_StateReconcile()} call is used to create a consistent view of ESMF objects over the entire VM in the initialization phase of a model run.  All Attributes that are attached to an ESMF object contained in the State, i.e. an object that is being reconciled, can also be reconciled.  This is done by setting a flag in the {\tt ESMF\_StateReconcile()} call, see the State documentation for details.  This means that, at the conclusion of {\tt ESMF\_StateReconcile()} there is a one-to-one correspondence between Attribute hierarchies and the ESMF objects they represent.  This is the only place where link changes in an Attribute hierarchy can be resolved.

The {\tt ESMF\_AttributeUpdate()} call can be used any time during the run phase of a model to insure that either structural or value changes made to an Attribute hierarchy on a subset of the VM are consistently represented across the remainder of the VM.  At this time, link changes cannot be resolved by {\tt ESMF\_AttributeUpdate()} as this would represent a departure from the one-to-one correspondence between the Attribute hierarchy and the ESMF objects it represents.  This means that {\tt ESMF\_AttributeUpdate()} will only work if it is called after {\tt ESMF\_StateReconcile()} when link changes have been made.  

{\tt ESMF\_AttributeUpdate()} is similar to {\tt ESMF\_StateReconcile()} in that it must be called from a location that has a view of the entire VM across which to update the Attribute hierarchy, such as a coupler Component.  The main difference is that {\tt ESMF\_AttributeUpdate()} operates only on the underlying Attribute hierarchy of the given ESMF object.  The Attribute hierarchy may be updated as many times as necessary.  

The specification of a list of PETs that are to be used as the basis for the update is a key feature of this interface.  This allows a many-to-many communication, as well as the direct specification of which PETs are to be updated and which are to be used as the "real" values.  The information is basically transported from the Attributes on the PETs specified in the rootList to their counterparts on the PETs which are not specified in the rootList.  This means that care must be taken to ensure that the data on the PETs in the rootList is consistent.

One caveat with this routine is that upon completion the destination PETs will have all of the missing Attributes from the source PETs, but this is not true the other way around.  This basically boils down to the fact that the end product of calling {\tt ESMF\_AttributeUpdate()} is {\it not} the union of the Attributes on both source and destination PETs.  This can be achieved, however, by calling {\tt ESMF\_AttributeUpdate()} twice, once from source to destination, and then again from destination to source.

\subsubsection{Writing Attribute packages to file}

The {\tt ESMF\_AttributeWrite()} interface is in limited form at the present time, as it can only be used reliably on the ESMF standard Attribute packages.  Chances are that it will perform as expected for most Attribute packages, but for now it is only guaranteed for the ESMF standard Attribute packages.  This routine is also not yet enabled to handle multi-valued Attributes.    One thing to remember when using this interface is that if you are writing an Attribute package that contains nested Attribute packages then all Attribute nested below the top level Attribute package will be written.

\subsubsection{Copying Attribute hierarchies}
\label{sec:Att:Copy}

The ability to copy an Attribute hierarchy is limited at this time.  The {\tt ESMF\_AttributeCopy()} routine can be used to {\it locally} copy an Attribute hierarchy between two States or Components.  It is important to note that this is a local copy, and no inter-PET communication is carried out.  Another thing to note is that when this functionality is based on a reference copy any further changes made to some portions of the original Attribute hierarchy will also affect the new Attribute hierarchy.

\begin{sloppypar}
There are two flags in the {\tt ESMF\_AttributeCopy()} routine which specify which type of copy is desired.  At this point there are only two different varieties of Attribute hierarchy copies available.  One of the requires the {\tt ESMF\_Copy\_Flag} to be set to {\tt ESMF\_COPY\_VALUE} and the {\tt ESMF\_AttTreeFlag} to be set to {\tt ESMF\_ATTTREE\_OFF}.  This does a copy of only the first level of an Attribute hierarchy, by value.
\end{sloppypar}

The second available copy can be applied by setting the {\tt ESMF\_Copy\_Flag} to {\tt ESMF\_COPY\_ALIAS} and the {\tt ESMF\_AttTreeFlag} to {\tt ESMF\_ATTTREE\_ON}.  This copy is more of a hybrid approach of reference and value copies.  In this case the Attributes which {\it belong} to the object being copied are actually copied in full (by value), while the Attributes which are linked to the object being copied are referenced by a pointer (by reference).  This means that after copying an Attribute hierarchy from ESMF object A to ESMF object B with this approach, the changes made to the lower portion of either A or B's Attribute hierarchy will be reflected on {\it both} object A and object B.

\subsubsection{Reading and writing Attributes from XML files}
\label{Att:Xerces}

\begin{sloppypar}
The Xerces C++ library, v3.1.0 or better, is used to read XML files.  
More specifically, the SAX2 API is currently used, although future releases may 
also use the DOM API.  The Xerces C++ website is 
http://xerces.apache.org/xerces-c/.  For more details, see the 
"ESMF Users Guide", "Building and Installing the ESMF, Third Party Libraries,
Xerces".  Also please see the section on Attribute I/O,~\ref{io:attributeio}.  
Writing Attribute XML files is performed with the standard C++ output file 
stream facility.
\end{sloppypar}

\subsubsection{Attribute duplicates}

The Attribute class has three different types of Attributes, they are: 1. regular Attributes, 2. Attribute packages, and 3. Attribute links.  Each of these types of Attributes have different behavior with respect to duplicates.

With regular Attributes a duplicate Attribute is replaced by the new value, sometimes resulting in a change in the type of the Attribute.  This behavior also applies to the individual Attributes inside an Attribute package.

The second type, Attribute packages (Attpacks), are groups of Attributes identified and organized by a “convention” and “purpose”.  i.e. the name of an Attpack is just one of the three pieces of identifying information: 1. name, 2. convention, and 3. purpose.  If a duplicate Attpack is created (this is a common use case for some users) a fourth piece of identifying information is created by ESMF to separate the two Attpacks. The user can query for this fourth piece of identifying information, called an attPackInstanceName, either at the time of creation or later in the runtime.

The third type, Attribute links, are used to link the Attribute trees of two objects.  Duplicates of Attribute links are required for some of the operations within the ESMF containers, and therefore they are enabled.  However, because there is little demand for duplicate links on the user level, they cannot be deleted in any order other than the order in which they were added.
