% $Id: Attribute_implnotes.tex,v 1.18.2.1 2010/02/05 19:53:27 svasquez Exp $
%
% Earth System Modeling Framework
% Copyright 2002-2010, University Corporation for Atmospheric Research,
% Massachusetts Institute of Technology, Geophysical Fluid Dynamics
% Laboratory, University of Michigan, National Centers for Environmental
% Prediction, Los Alamos National Laboratory, Argonne National Laboratory,
% NASA Goddard Space Flight Center.
% Licensed under the University of Illinois-NCSA License.

This section covers Attribute memory deallocation, the use of {\tt ESMF\_AttributeGet()}, Attribute package nesting capabilities, issues with Attributes in a distributed environment, and reading of Attributes via XML files.  Issues and procedures dealing with Attribute memory deallocation, using {\tt ESMF\_AttributeGet()} to retrieve Attribute lists, and nested Attribute package capabilities are discussed to help avoid misuse.  The limitations with Attributes in a distributed environment are also discussed, with an outline of the future work to be done in this area. 

\subsubsection{Attribute Memory Deallocation}

The Attribute class presents a somewhat different paradigm with respect to memory deallocation than other ESMF objects.  The {\tt ESMF\_AttributeRemove()} call can be issued to remove any Attribute from an ESMF object or an Attribute package on an ESMF object.  This call is also enabled to remove entire Attribute packages with one call, which would remove any nested Attribute packages as well.  The user is {\bf not} required to remove all Attributes that are used in a model run.  The entire Attribute hierarchy will be removed automatically by ESMF, provided the ESMF objects which contain them are properly destroyed.  

The decision to remove either an Attribute or an Attribute package is made by calling {\tt ESMF\_AttributeRemove()} with the correct optional arguments.  If an Attribute which is not associated with any Attribute package should be removed, then the call must be issued without a convention or purpose argument.  If an Attribute in an Attribute package is to be removed, then the call should be issued with all three of name, convention, and purpose.  Finally, if an entire Attribute package is to be removed the call should be issued with a convention and purpose, but no Attribute name.

\subsubsection{Using {\tt ESMF\_AttributeGet()} to retrieve Attribute lists}

The behavior of the {\tt ESMF\_AttributeGet()} routine,when retrieving an Attribute containing a value list, follows a slightly different convention than other similar ESMF routines.  This routine requires the input of a Fortran array as a place to store the retrieved values of the Attribute list.  If the array that is given is longer that the list of Attribute values, the first part of the array will be filled, leaving the extra space untouched.  If, however the array passed in, is shorter than the number of Attribute values, the routine will exit with a return code which is not equal to {\bf ESMF\_SUCCESS}.  It is suggested that if it is required by the user to use a Fortran array that is longer than the number of Attribute values returned, only the indices of the array which the user desires to be filled with retrieved Attribute values should be passed into the routine.  
  
Similar behavior is exhibited with the {\tt defaultvalueList} argument in the {\tt ESMF\_AttributeGet()} routine.  The difference here is that if the {\tt valueList} is shorter than the {\tt defaultvalueList} only the appropriate values will be filed in, and the routine will exit without error.  Likewise, if the {\tt valueList} is longer than the {\tt defaultvalueList} then the entire {\tt valueList} will be populated with the beginning section of the {\tt defaultvalueList} that is given.  

\subsubsection{Using Attribute package nesting capabilites}

There is a recommended practice when using nested Attribute packages to organize metadata conventions.  The most general Attribute packages should always be added first, followed by the more specific ones.  For instance, when adding Attribute packages to a Field, it is recommend that the CF convention be added first, followed by the ESG convention, followed by any additional customized Attribute packages.  

At this time there are several ESMF supplied Attribute packages, with a convention of ESMF and a purpose of general.  These Attribute packages are generated by calling {\tt ESMF\_AttributeAdd()} with the appropriate convention and purpose.  The ESMF standard Attribute packages can be customized by nesting a custom Attribute package around them, they can also be modified in other ways but this is not suggested practice at this time.

Another consideration when using nested Attribute packages is to remember that when a nested Attribute package is removed every nested Attribute package below the point of removal will also be removed.  Thus, by removing the ESG Attribute package on a Field, the CF and Attribute package will also be removed.

\subsubsection{Attributes in a Distributed Environment}
\label{sec:Att:Dist}

This section discusses the methods of building a consistent view of the metadata across the VM of a model run.  To better explain the ESMF capabilities for ensuring the integrity of Attributes in a distributed environment, a small working vocabulary of ESMF Attributes will be presented.  Three types of changes to an Attribute hierarchy need to be specified, these are: 1. {\bf link changes} are structural links created when two separate Attribute hierarchies are linked, 2. {\bf structural changes} are changes which occur when Attributes or Attribute packages are added or removed within a single level of an Attribute hierarchy, and 3. {\bf value changes} occur when the value portion of any single Attribute is modified.  These definitions will help to describe how {\tt ESMF\_StateReconcile()} and {\tt ESMF\_AttributeUpdate()} can be effectively used to ensure a consistent view of the metadata throughout a model run.

The {\tt ESMF\_StateReconcile()} call is used to create a consistent view of ESMF objects over the entire VM in the initialization phase of a model run.  All Attributes that are attached to an ESMF object contained in the State, i.e. an object that is being reconciled, can also be reconciled.  This is done by setting a flag in the {\tt ESMF\_StateReconcile()} call, see the State documentation for details.  This means that, at the conclusion of {\tt ESMF\_StateReconcile()} there is a one-to-one correspondence between Attribute hierarchies and the ESMF objects they represent.  This is the only place where link changes in an Attribute hierarchy can be resolved.

The {\tt ESMF\_AttributeUpdate()} call can be used any time during the run phase of a model to insure that either structural or value changes made to an Attribute hierarchy on a subset of the VM are consistently represented across the remainder of the VM.  At this time, link changes cannot be resolved by {\tt ESMF\_AttributeUpdate()} as this would represent a departure from the one-to-one correspondence between the Attribute hierarchy and the ESMF objects it represents.  

This call is similar to {\tt ESMF\_StateReconcile()} in that it must be called from a location that has a view of the entire VM across which to update the Attribute hierarchy, such as a coupler Component.  The main difference is that {\tt ESMF\_AttributeUpdate()} operates only on the underlying Attribute hierarchy of the given ESMF object.  The Attribute hierarchy may be updated as many times as necessary, this call is much more efficient than {\tt ESMF\_StateReconcile()} for this reason.  

The specification of a list of PETs that are to be used as the basis for the update is a key feature of this interface.  This allows a many-to-many communication, as well as the direct specification of which PETs are to be updated and which are to be used as the ``real'' values.  One caveat with this routine is that upon completion the destination PETs will have all of the missing Attributes from the source PETs, but this is not true the other way around.  This basically boils down to the fact that the end product of calling {\tt ESMF\_AttributeUpdate()} is {\it not} the union of the Attributes on both source and destination PETs.  This can be achieved, however, by calling {\tt ESMF\_AttributeUpdate()} twice, once from source to destination, and then again from destination to source.

\subsubsection{Writing Attribute packages to file}

The {\tt ESMF\_AttributeWrite()} interface is used to write the contents of an Attribute package to a file.  This routine can be called on any ESMF object that is capable of holding Attribute packages.  It can also write out all Attributes in Attribute packages with the same specifiers throughout an entire ESMF object hierarchy.  The files are written in either tab-delimited or XML format, which is controlled by an optional flag in the interface.

This interface is in limited form at the present time, as it can only be used reliably on the ESMF standard Attribute packages.  Chances are that it will perform as expected for most Attribute packages, but for now it is only guaranteed for the ESMF standard Attribute packages.  This routine is also not yet enabled to handle multi-valued Attributes.    One thing to remember when using this interface is that if you are writing an Attribute package that contains nested Attribute packages then all Attribute nested below the top level Attribute package will be written.

The flag that is used to determine which format for writing the Attribute packages is called the {\tt ESMF\_AttWriteFlag}.  It can take values of {\tt ESMF\_ATTWRITE\_TAB} or {\tt ESMF\_ATTWRITE\_XML}, where the default value is the former option.  In both cases the write files will end up in the execution directory after they are written and closed.  The tab-delimited file will have an ending of .stdout, and the XML file will have an ending of .xml.  In both cases the file will be named for the name of the ESMF object from which {\tt ESMF\_AttributeWrite()} was called.

\subsubsection{Copying Attribute hierarchies}

The ability to copy an Attribute hierarchy is limited at this time.  The {\tt ESMF\_AttributeCopy()} routine can be used to {\it locally} copy an Attribute hierarchy between States.  It is important to note that this is a local copy, and no inter-PET communication is carried out.  Another thing to note is that when this functionality is based on a reference copy any further changes made to some portions of the original Attribute hierarchy will also affect the new Attribute hierarchy.

There are two flags in the {\tt ESMF\_AttributeCopy()} routine which specify which type of copy is desired.  At this point there are only two different varieties of Attribute hierarchy copies available.  One of the requires the {\tt ESMF\_AttCopyFlag} to be set to {\tt ESMF\_ATTCOPY\_VALUE} and the {\tt ESMF\_AttTreeFlag} to be set to {\tt ESMF\_ATTTREE\_OFF}.  This does a copy of only the first level of an Attribute hierarchy, by value.

The second available copy can be applied by setting the {\tt ESMF\_AttCopyFlag} to {\tt ESMF\_ATTCOPY\_HYBRID} and the {\tt ESMF\_AttTreeFlag} to {\tt ESMF\_ATTTREE\_ON}.  This copy is more of a hybrid approach of reference and value copies.  In this case the Attributes which {\it belong} to the object being copied are actually copied in full (by value), while the Attributes which are linked to the object being copied are referenced by a pointer (by reference).  This means that after copying an Attribute hierarchy from ESMF object A to ESMF object B with this approach, the changes made to the lower portion of either A or B's Attribute hierarchy will be reflected on {\it both} object A and object B.

\subsubsection{Reading Attributes from XML files}

The Xerces C++ library is used to read XML files.  More specifically, the SAX2 API is currently used, although future releases may also use the DOM API.  The Xerces C++ website is http://xerces.apache.org/xerces-c/.
