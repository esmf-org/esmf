! $Id: ESMF_Array.F90,v 1.25.2.3 2007/10/18 02:41:57 cdeluca Exp $
!
! Earth System Modeling Framework
! Copyright 2002-2007, University Corporation for Atmospheric Research, 
! Massachusetts Institute of Technology, Geophysical Fluid Dynamics 
! Laboratory, University of Michigan, National Centers for Environmental 
! Prediction, Los Alamos National Laboratory, Argonne National Laboratory, 
! NASA Goddard Space Flight Center.
! Licensed under the University of Illinois-NCSA License.
!
!==============================================================================
#define ESMF_FILENAME "ESMF_Array.F90"
!
!     ESMF Array module
      module ESMF_ArrayMod
!
!==============================================================================
!
! This file contains the Array class definition and all Array
! class methods which are *not* generated by macro.  
! See ESMF_ArrayCreate.F90 and ESMF_ArrayGet.F90 for the 
! macro-generated interfaces.
!
!------------------------------------------------------------------------------
#include "ESMF.h"

!------------------------------------------------------------------------------
!BOPI
! !MODULE: ESMF_ArrayMod - Manage data arrays uniformly between F90 and C++     
!
! !DESCRIPTION:
!
! The code in this file implements the {\tt Array} class and 
!  associated functions and subroutines.  
!
! C and C++ arrays are simple pointers to memory.
! Fortran arrays contain shape and stride definitions and are strongly
! typed.  To enable interoperability between the languages the C++ code
! must be able to obtain this information from the Fortran description
! (which is called the "dope vector" in Fortran), either through a priori
! knowledge or through query.
!
!------------------------------------------------------------------------------
! !USES:
      use ESMF_UtilTypesMod    ! ESMF base class
      use ESMF_BaseMod
      use ESMF_LogErrMod
      use ESMF_IOSpecMod
      use ESMF_ArraySpecMod
      use ESMF_LocalArrayMod
      use ESMF_DELayoutMod
      implicit none

!------------------------------------------------------------------------------
! !PRIVATE TYPES:
      private
!------------------------------------------------------------------------------
!     ! ESMF_HaloDirection
! 
!     ! Object for specifiying halo directions (mostly a placeholder for now)

      type ESMF_HaloDirection
      sequence
      private
        integer :: edges
      end type


!------------------------------------------------------------------------------
!     ! ESMF_Mask
! 
!     ! Class for storing information about masked regions.

      type ESMF_Mask
      sequence
      private
        ! same size as data array
#if !defined(ESMF_NO_INITIALIZERS) && !defined(ESMF_AIX_8_INITBUG)
        type (ESMF_LocalArray), pointer :: maskvals => NULL()
#else
        type (ESMF_LocalArray), pointer :: maskvals 
#endif
      end type


!------------------------------------------------------------------------------
!     ! ESMF_Array
!
!     ! Array data type.  All information is kept on the C++ side inside
!     ! the class structure.

      type ESMF_Array
      sequence
        ! opaque pointer to the C++ class data
#if !defined(ESMF_NO_INITIALIZERS) && !defined(ESMF_AIX_8_INITBUG)
        type(ESMF_Pointer) :: this = ESMF_NULL_POINTER
#else
        type(ESMF_Pointer) :: this
#endif
      end type

!------------------------------------------------------------------------------
! !PUBLIC TYPES:
      public ESMF_HaloDirection, ESMF_Mask
      public ESMF_Array
!------------------------------------------------------------------------------

! !PUBLIC MEMBER FUNCTIONS:
 
      public ESMF_ArrayGet, ESMF_ArraySet
      public ESMF_ArrayGetAttribute, ESMF_ArraySetAttribute
      public ESMF_ArrayGetAttributeCount
      public ESMF_ArrayGetAttributeInfo

      public ESMF_ArraySetAxisIndex, ESMF_ArrayGetAxisIndex  
      !public ESMF_ArrayComputeAxisIndex

      public ESMF_ArrayWriteRestart
      public ESMF_ArrayReadRestart
      public ESMF_ArrayWrite
      public ESMF_ArrayRead
 
      public ESMF_ArrayValidate
      public ESMF_ArrayPrint
!EOPI

      public assignment(=)

!------------------------------------------------------------------------------
! The following line turns the CVS identifier string into a printable variable.
      character(*), parameter, private :: version = &
      '$Id: ESMF_Array.F90,v 1.25.2.3 2007/10/18 02:41:57 cdeluca Exp $'
!
!==============================================================================
!
! INTERFACE BLOCKS
!
!==============================================================================

!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_ArrayGetAxisIndex  - Get Array attributes
!
! !INTERFACE:
      interface ESMF_ArrayGetAxisIndex 
   
! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_ArrayGetAxisIndex
        module procedure ESMF_ArrayGetAxisIndexOld

! !DESCRIPTION:
!     This interface provides a single entry point for methods that get
!     AxisIndex derived types from an {\tt ESMF\_Array}.
 
!EOPI
      end interface
!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_ArraySetAttribute  - Set Array attributes
!
! !INTERFACE:
      interface ESMF_ArraySetAttribute 
   
! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_ArraySetInt4Attr
        module procedure ESMF_ArraySetInt4ListAttr
        module procedure ESMF_ArraySetInt8Attr
        module procedure ESMF_ArraySetInt8ListAttr
        module procedure ESMF_ArraySetReal4Attr
        module procedure ESMF_ArraySetReal4ListAttr
        module procedure ESMF_ArraySetReal8Attr
        module procedure ESMF_ArraySetReal8ListAttr
        module procedure ESMF_ArraySetLogicalAttr
        module procedure ESMF_ArraySetLogicalListAttr
        module procedure ESMF_ArraySetCharAttr

! !DESCRIPTION:
!     This interface provides a single entry point for methods that attach
!     attributes to an {\tt ESMF\_Array}.
 
!EOPI
      end interface
!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_ArrayGetAttribute  - Get Array attributes
!
! !INTERFACE:
      interface ESMF_ArrayGetAttribute 
   
! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_ArrayGetInt4Attr
        module procedure ESMF_ArrayGetInt4ListAttr
        module procedure ESMF_ArrayGetInt8Attr
        module procedure ESMF_ArrayGetInt8ListAttr
        module procedure ESMF_ArrayGetReal4Attr
        module procedure ESMF_ArrayGetReal4ListAttr
        module procedure ESMF_ArrayGetReal8Attr
        module procedure ESMF_ArrayGetReal8ListAttr
        module procedure ESMF_ArrayGetLogicalAttr
        module procedure ESMF_ArrayGetLogicalListAttr
        module procedure ESMF_ArrayGetCharAttr

! !DESCRIPTION:
!     This interface provides a single entry point for methods that retrieve
!     attributes from an {\tt ESMF\_Array}.
 
!EOPI
      end interface

!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_ArrayGetAttributeInfo - Get type, count from a Array attribute
!
! !INTERFACE:
      interface ESMF_ArrayGetAttributeInfo
   
! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_ArrayGetAttrInfoByName
        module procedure ESMF_ArrayGetAttrInfoByNum

! !DESCRIPTION:
!     This interface provides a single entry point for methods that retrieve
!     information about attributes from an {\tt ESMF\_Array}.
 
!EOPI
      end interface



interface assignment (=)
 module procedure ESMF_aras
end interface

!==============================================================================

      contains

!==============================================================================

subroutine ESMF_aras(daval, saval)
 type(ESMF_LocalArray), intent(out) :: daval
 type(ESMF_Array), intent(in) :: saval

 daval%this%ptr = saval%this%ptr
end subroutine


!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArrayGet"
!BOP
! !IROUTINE: ESMF_ArrayGet
!
! !INTERFACE:
      subroutine ESMF_ArrayGet(array, rank, type, kind, counts, &
                               lbounds, ubounds, strides, haloWidth, &
                               base, name, rc)
!
! !ARGUMENTS:
      type(ESMF_Array) :: array
      integer, intent(out), optional :: rank
      type(ESMF_DataType), intent(out), optional :: type
      type(ESMF_DataKind), intent(out), optional :: kind
      integer, dimension(:), intent(out), optional :: counts
      integer, dimension(:), intent(out), optional :: lbounds
      integer, dimension(:), intent(out), optional :: ubounds
      integer, dimension(:), intent(out), optional :: strides
      integer, intent(out), optional :: haloWidth
      type(ESMF_Pointer), intent(out), optional :: base
      character(len=ESMF_MAXSTR), intent(out), optional :: name
      integer, intent(out), optional :: rc             

!
! !DESCRIPTION:
!  Return information about an {\tt ESMF\_Array}.
!  For queries where the caller only wants a single value, 
!  specify the argument by name.
!  All the arguments after the array input are optional to facilitate this.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array}.
!     \item [{[rank]}]
!           The number of dimensions in the {\tt array}.
!     \item [{[type]}]
!	    {\tt ESMF\_DataType}.  Will be one of: 
!           {\tt ESMF\_DATA\_INTEGER}, {\tt ESMF\_DATA\_REAL},
!           {\tt ESMF\_DATA\_LOGICAL}, {\tt ESMF\_DATA\_CHARACTER}, or
!           {\tt ESMF\_DATA\_COMPLEX}.
!     \item [{[kind]}]
!           {\tt ESMF\_DataKind} variable which indicates 
!           the item size in bytes.  Will be one of:
!           {\tt ESMF\_I1}, {\tt ESMF\_I2}, {\tt ESMF\_I4},
!           {\tt ESMF\_I8}, {\tt ESMF\_R4}, {\tt ESMF\_R8},
!           {\tt ESMF\_C8}, or {\tt ESMF\_C16}.
!     \item [{[counts]}]
!           The number of items in each dimension of the {\tt array}.
!     \item [{[lbounds]}]
!           The lower index value of each dimension of the {\tt array}.
!     \item [{[ubounds]}]
!           The upper index value of each dimension of the {\tt array}.
!     \item [{[strides]}]
!           If nonzero, the spacing between index values per dimension
!           of the {\tt array}.
!     \item [{[haloWidth]}]
!           Width of halo region.
!     \item [{[base]}]
!           Base memory address of the data region of the {\tt array}.
!     \item [{[name]}]
!           {\tt array} name.  If one was not specified at create time,
!           a unique name will have been generated.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!EOP

      integer :: status      ! Error status
      logical :: rcpresent   ! Return code present
      integer :: lrank       ! Local use to get rank

      ! Initialize return code; assume failure until success is certain
      status = ESMF_FAILURE
      rcpresent = .FALSE.
      if (present(rc)) then
          rcpresent = .TRUE.
          rc = ESMF_FAILURE
      endif


      if (present(rank)) then
         call c_ESMC_ArrayGetRank(array, rank, status)
         if (status .ne. ESMF_SUCCESS) return
      endif

      if (present(type)) then
         call c_ESMC_ArrayGetType(array, type, status)
         if (status .ne. ESMF_SUCCESS) return
      endif

      if (present(kind)) then
         call c_ESMC_ArrayGetKind(array, kind, status)
         if (status .ne. ESMF_SUCCESS) return
      endif

      if (present(counts)) then
         call c_ESMC_ArrayGetRank(array, lrank, status)
         if (status .ne. ESMF_SUCCESS) return
         call c_ESMC_ArrayGetLengths(array, lrank, counts, status)
         if (status .ne. ESMF_SUCCESS) return
      endif

      if (present(lbounds)) then
         call c_ESMC_ArrayGetRank(array, lrank, status)
         if (status .ne. ESMF_SUCCESS) return
         call c_ESMC_ArrayGetLbounds(array, lrank, lbounds, status)
         if (status .ne. ESMF_SUCCESS) return
      endif
   
      if (present(ubounds)) then
         call c_ESMC_ArrayGetRank(array, lrank, status)
         if (status .ne. ESMF_SUCCESS) return
         call c_ESMC_ArrayGetUbounds(array, lrank, ubounds, status)
         if (status .ne. ESMF_SUCCESS) return
      endif
   
      if (present(haloWidth)) then
         call c_ESMC_ArrayGetHWidth(array, haloWidth, status)
         if (status .ne. ESMF_SUCCESS) return
      endif
   
      if (present(base)) then
         call c_ESMC_ArrayGetBaseAddr(array, base, status)
         if (status .ne. ESMF_SUCCESS) return
      endif
   
      if (present(strides)) then
         call ESMF_LogWrite("Strides not yet supported", &
                               ESMF_LOG_WARNING, ESMF_CONTEXT)
         strides(:) = 1
      endif

      if (present(name)) then
         call c_ESMC_GetName(array, name, status)
         if (status .ne. ESMF_SUCCESS) return
      endif
   
      if (rcpresent) rc = ESMF_SUCCESS

      end subroutine ESMF_ArrayGet


!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArrayGetInt4Attr"

!BOP
! !IROUTINE: ESMF_ArrayGetAttribute  - Retrieve a 4-byte integer attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_ArrayGetAttribute()
      subroutine ESMF_ArrayGetInt4Attr(array, name, value, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(in) :: array  
      character (len = *), intent(in) :: name
      integer(ESMF_KIND_I4), intent(out) :: value
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Returns an integer attribute from the {\tt array}.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to retrieve.
!     \item [value]
!           The integer value of the named attribute.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP

      integer :: status                           ! Error status

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_FAILURE

      call c_ESMC_AttributeGetValue(array%this, name, &
                                    ESMF_DATA_INTEGER, ESMF_I4, 1, &
                                    value, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_ArrayGetInt4Attr

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArrayGetInt4ListAttr"

!BOP
! !IROUTINE: ESMF_ArrayGetAttribute - Retrieve a 4-byte integer list attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_ArrayGetAttribute()
      subroutine ESMF_ArrayGetInt4ListAttr(array, name, count, valueList, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(in) :: array  
      character (len = *), intent(in) :: name
      integer, intent(in) :: count   
      integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!      Returns a 4-byte integer list attribute from the {\tt array}.
! 
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to retrieve.
!     \item [count]
!           The number of values in the attribute.
!     \item [valueList]
!           The integer values of the named attribute.
!           The list must be at least {\tt count} items long.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP

      integer :: status                           ! Error status
      integer :: limit

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_FAILURE

      limit = size(valueList)
      if (count > limit) then
          if (ESMF_LogMsgFoundError(ESMF_RC_OBJ_BAD, &
                                "count longer than valueList", &
                                 ESMF_CONTEXT, rc)) return
      endif

      call c_ESMC_AttributeGetValue(array%this, name, &
                                    ESMF_DATA_INTEGER, ESMF_I4, count, &
                                    valueList, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_ArrayGetInt4ListAttr

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArrayGetInt8Attr"

!BOP
! !IROUTINE: ESMF_ArrayGetAttribute  - Retrieve an 8-byte integer attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_ArrayGetAttribute()
      subroutine ESMF_ArrayGetInt8Attr(array, name, value, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(in) :: array  
      character (len = *), intent(in) :: name
      integer(ESMF_KIND_I8), intent(out) :: value
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Returns an 8-byte integer attribute from the {\tt array}.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to retrieve.
!     \item [value]
!           The integer value of the named attribute.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP

      integer :: status                           ! Error status

      call c_ESMC_AttributeGetValue(array%this, name, &
                                    ESMF_DATA_INTEGER, ESMF_I8, 1, &
                                    value, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_ArrayGetInt8Attr

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArrayGetInt8ListAttr"

!BOP
! !IROUTINE: ESMF_ArrayGetAttribute - Retrieve an 8-byte integer list attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_ArrayGetAttribute()
      subroutine ESMF_ArrayGetInt8ListAttr(array, name, count, valueList, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(in) :: array  
      character (len = *), intent(in) :: name
      integer, intent(in) :: count   
      integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!      Returns an 8-byte integer list attribute from the {\tt array}.
! 
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to retrieve.
!     \item [count]
!           The number of values in the attribute.
!     \item [valueList]
!           The integer values of the named attribute.
!           The list must be at least {\tt count} items long.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP

      integer :: status                           ! Error status
      integer :: limit

      limit = size(valueList)
      if (count > limit) then
          if (ESMF_LogMsgFoundError(ESMF_RC_OBJ_BAD, &
                                "count longer than valueList", &
                                 ESMF_CONTEXT, rc)) return
      endif

      call c_ESMC_AttributeGetValue(array%this, name, &
                                    ESMF_DATA_INTEGER, ESMF_I8, count, &
                                    valueList, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_ArrayGetInt8ListAttr

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArrayGetReal4Attr"

!BOP
! !IROUTINE: ESMF_ArrayGetAttribute - Retrieve a 4-byte real attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_ArrayGetAttribute()
      subroutine ESMF_ArrayGetReal4Attr(array, name, value, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(in) :: array  
      character (len = *), intent(in) :: name
      real(ESMF_KIND_R4), intent(out) :: value
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!      Returns a 4-byte real attribute from the {\tt array}.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to retrieve.
!     \item [value]
!           The real value of the named attribute.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP

      integer :: status                           ! Error status

      call c_ESMC_AttributeGetValue(array%this, name, &
                                    ESMF_DATA_REAL, ESMF_R4, 1, value, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_ArrayGetReal4Attr

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArrayGetReal4ListAttr"

!BOP
! !IROUTINE: ESMF_ArrayGetAttribute - Retrieve a 4-byte real list attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_ArrayGetAttribute()
      subroutine ESMF_ArrayGetReal4ListAttr(array, name, count, valueList, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(in) :: array  
      character (len = *), intent(in) :: name
      integer, intent(in) :: count   
      real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!      Returns a 4-byte real attribute from an {\tt ESMF\_Array}.
! 
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to retrieve.
!     \item [count]
!           The number of values in the attribute.
!     \item [valueList]
!           The real values of the named attribute.
!           The list must be at least {\tt count} items long.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP

      integer :: status                           ! Error status
      integer :: limit

      limit = size(valueList)
      if (count > limit) then
          if (ESMF_LogMsgFoundError(ESMF_RC_OBJ_BAD, &
                                "count longer than valueList", &
                                 ESMF_CONTEXT, rc)) return
      endif

      call c_ESMC_AttributeGetValue(array%this, name, &
                                    ESMF_DATA_REAL, ESMF_R4, count, &
                                    valueList, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_ArrayGetReal4ListAttr

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArrayGetReal8Attr"

!BOP
! !IROUTINE: ESMF_ArrayGetAttribute - Retrieve an 8-byte real attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_ArrayGetAttribute()
      subroutine ESMF_ArrayGetReal8Attr(array, name, value, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(in) :: array  
      character (len = *), intent(in) :: name
      real(ESMF_KIND_R8), intent(out) :: value
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!      Returns an 8-byte real attribute from the {\tt array}.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to retrieve.
!     \item [value]
!           The real value of the named attribute.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP

      integer :: status                           ! Error status

      call c_ESMC_AttributeGetValue(array%this, name, &
                                    ESMF_DATA_REAL, ESMF_R8, 1, value, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_ArrayGetReal8Attr

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArrayGetReal8ListAttr"

!BOP
! !IROUTINE: ESMF_ArrayGetAttribute - Retrieve an 8-byte real list attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_ArrayGetAttribute()
      subroutine ESMF_ArrayGetReal8ListAttr(array, name, count, valueList, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(in) :: array  
      character (len = *), intent(in) :: name
      integer, intent(in) :: count   
      real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!      Returns an 8-byte real attribute from an {\tt ESMF\_Array}.
! 
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to retrieve.
!     \item [count]
!           The number of values in the attribute.
!     \item [valueList]
!           The real values of the named attribute.
!           The list must be at least {\tt count} items long.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP

      integer :: status                           ! Error status
      integer :: limit

      limit = size(valueList)
      if (count > limit) then
          if (ESMF_LogMsgFoundError(ESMF_RC_OBJ_BAD, &
                                "count longer than valueList", &
                                 ESMF_CONTEXT, rc)) return
      endif

      call c_ESMC_AttributeGetValue(array%this, name, &
                                    ESMF_DATA_REAL, ESMF_R8, count, &
                                    valueList, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_ArrayGetReal8ListAttr

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArrayGetLogicalAttr"

!BOP
! !IROUTINE: ESMF_ArrayGetAttribute - Retrieve a logical attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_ArrayGetAttribute()
      subroutine ESMF_ArrayGetLogicalAttr(array, name, value, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(in) :: array  
      character (len = *), intent(in) :: name
      type(ESMF_Logical), intent(out) :: value
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!      Returns a logical attribute from the {\tt array}.
! 
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to retrieve.
!     \item [value]
!           The logical value of the named attribute.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP

      integer :: status                           ! Error status

      call c_ESMC_AttributeGetValue(array%this, name, &
                                    ESMF_DATA_LOGICAL, ESMF_NOKIND, 1, &
                                    value, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_ArrayGetLogicalAttr

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArrayGetLogicalListAttr"

!BOP
! !IROUTINE: ESMF_ArrayGetAttribute - Retrieve a logical list attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_ArrayGetAttribute()
      subroutine ESMF_ArrayGetLogicalListAttr(array, name, count, valueList, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(in) :: array  
      character (len = *), intent(in) :: name
      integer, intent(in) :: count   
      type(ESMF_Logical), dimension(:), intent(out) :: valueList
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!      Returns a logical list attribute from the {\tt array}.
! 
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to retrieve.
!     \item [count]
!           The number of values in the attribute.
!     \item [valueList]
!           The logical values of the named attribute.
!           The list must be at least {\tt count} items long.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP

      integer :: status                           ! Error status
      integer :: limit

      limit = size(valueList)
      if (count > limit) then
          if (ESMF_LogMsgFoundError(ESMF_RC_OBJ_BAD, &
                                    "count longer than valueList", &
                                     ESMF_CONTEXT, rc)) return
      endif

      call c_ESMC_AttributeGetValue(array%this, name, &
                                    ESMF_DATA_LOGICAL, ESMF_NOKIND, count, &
                                    valueList, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_ArrayGetLogicalListAttr

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArrayGetCharAttr"

!BOP
! !IROUTINE: ESMF_ArrayGetAttribute - Retrieve a character attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_ArrayGetAttribute()
      subroutine ESMF_ArrayGetCharAttr(array, name, value, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(in) :: array  
      character (len = *), intent(in) :: name
      character (len = *), intent(out) :: value
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!      Returns a character attribute from the {\tt array}.
! 
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to retrieve.
!     \item [value]
!           The character value of the named attribute.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP

      integer :: status                           ! Error status

      call c_ESMC_AttributeGetChar(array%this, name, value, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_ArrayGetCharAttr


!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArrayGetAttributeCount"

!BOP
! !IROUTINE: ESMF_ArrayGetAttributeCount - Query the number of attributes
!
! !INTERFACE:
      subroutine ESMF_ArrayGetAttributeCount(array, count, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(in) :: array  
      integer, intent(out) :: count   
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Returns the number of attributes associated with the given {\tt array} 
!     in the argument {\tt count}.
! 
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [count]
!           The number of attributes associated with this object.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP

      integer :: status                           ! Error status

      call c_ESMC_AttributeGetCount(array%this, count, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_ArrayGetAttributeCount

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArrayGetAttrInfoByName"

!BOP
! !IROUTINE: ESMF_ArrayGetAttributeInfo - Query Array attributes by name
!
! !INTERFACE:
      ! Private name; call using ESMF_ArrayGetAttributeInfo()
      subroutine ESMF_ArrayGetAttrInfoByName(array, name, datatype, &
                                             datakind, count, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(in) :: array  
      character(len=*), intent(in) :: name
      type(ESMF_DataType), intent(out), optional :: datatype
      type(ESMF_DataKind), intent(out), optional :: datakind
      integer, intent(out), optional :: count   
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Returns information associated with the named attribute, 
!     including {\tt datatype} and {\tt count}.
! 
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to query.
!     \item [{[datatype]}]
!           The data type of the attribute. One of the values
!           {\tt ESMF\_DATA\_INTEGER}, {\tt ESMF\_DATA\_REAL},
!           {\tt ESMF\_DATA\_LOGICAL}, or {\tt ESMF\_DATA\_CHARACTER}.
!     \item [{[datakind]}]
!           The datakind of the attribute, if attribute is type
!           {\tt ESMF\_DATA\_INTEGER} or {\tt ESMF\_DATA\_REAL}.
!           One of the values {\tt ESMF\_I4}, {\tt ESMF\_I8}, {\tt ESMF\_R4},
!           or {\tt ESMF\_R8}.
!           For all other types the value {\tt ESMF\_NOKIND} is returned.
!     \item [{[count]}]
!           The number of items in this attribute.  For character types,
!           the length of the character string.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP

      integer :: status                           ! Error status
      type(ESMF_DataType) :: localDt
      type(ESMF_DataKind) :: localDk
      integer :: localCount

      call c_ESMC_AttributeGetAttrInfoName(array%this, name, &
                                           localDt, localDk, localCount, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(datatype)) datatype = localDt
      if (present(datakind)) datakind = localDk
      if (present(count)) count = localCount

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_ArrayGetAttrInfoByName

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArrayGetAttrInfoByNum"

!BOP
! !IROUTINE: ESMF_ArrayGetAttributeInfo - Query Array attributes by index number
!
! !INTERFACE:
      ! Private name; call using ESMF_ArrayGetAttributeInfo()
      subroutine ESMF_ArrayGetAttrInfoByNum(array, attributeIndex, name, &
                                            datatype, datakind, count, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(in) :: array  
      integer, intent(in) :: attributeIndex
      character(len=*), intent(out), optional :: name
      type(ESMF_DataType), intent(out), optional :: datatype
      type(ESMF_DataKind), intent(out), optional :: datakind
      integer, intent(out), optional :: count   
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!      Returns information associated with the indexed attribute, 
!      including {\tt name}, {\tt datatype}, {\tt datakind} (if applicable)
!      and {\tt count}.
! 
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [attributeIndex]
!           The index number of the attribute to query.
!     \item [name]
!           Returns the name of the attribute.
!     \item [{[datatype]}]        
!           The data type of the attribute. One of the values
!           {\tt ESMF\_DATA\_INTEGER}, {\tt ESMF\_DATA\_REAL},
!           {\tt ESMF\_DATA\_LOGICAL}, or {\tt ESMF\_DATA\_CHARACTER}.
!     \item [{[datakind]}]
!           The datakind of the attribute, if attribute is type
!           {\tt ESMF\_DATA\_INTEGER} or {\tt ESMF\_DATA\_REAL}.
!           One of the values {\tt ESMF\_I4}, {\tt ESMF\_I8}, {\tt ESMF\_R4},
!           or {\tt ESMF\_R8}.
!           For all other types the value {\tt ESMF\_NOKIND} is returned.
!     \item [{[count]}]
!           Returns the number of items in this attribute.  For character types,
!           this is the length of the character string.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP

      integer :: status                           ! Error status
      character(len=ESMF_MAXSTR) :: localName
      type(ESMF_DataType) :: localDt
      type(ESMF_DataKind) :: localDk
      integer :: localCount

      call c_ESMC_AttributeGetAttrInfoNum(array%this, attributeIndex, &
                                         localName, localDt, localDk, &
                                         localCount, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(name)) name = localName
      if (present(datatype)) datatype = localDt
      if (present(datakind)) datakind = localDk
      if (present(count)) count = localCount

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_ArrayGetAttrInfoByNum

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArrayGetAxisIndex"
!BOPI
! !IROUTINE: ESMF_ArrayGetAxisIndex
!
! !INTERFACE:
      subroutine ESMF_ArrayGetAxisIndex(array, domainTypeFlag, AIPerRank, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(in) :: array 
      type(ESMF_DomainTypeFlag), intent(in) :: domainTypeFlag
      type(ESMF_AxisIndex), intent(inout) :: AIPerRank(:)
      integer, intent(out), optional :: rc     
!
! !DESCRIPTION:
!      Used to retrieve the index annotation from an {\tt ESMF\_Array}.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array}.
!     \item [domainTypeFlag]
!     \item [AIPerRank]
!           An array of index spaces.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

        integer :: status, i

        ! call c routine to get index
        call c_ESMC_ArrayGetAxisIndex(array, domainTypeFlag, AIPerRank,&
                                      status)
        if (status .ne. ESMF_SUCCESS) goto 10

        ! translate from C++ to Fortran
        do i=1,size(AIPerRank)
          AIPerRank(i)%min = AIPerRank(i)%min + 1
          AIPerRank(i)%max = AIPerRank(i)%max + 1
        enddo

        status = ESMF_SUCCESS

 10     continue

        if (present(rc)) rc = status

        end subroutine ESMF_ArrayGetAxisIndex

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArrayGetAxisIndex"
!BOPI
! !IROUTINE: ESMF_ArrayGetAxisIndex
!
! !INTERFACE:
      subroutine ESMF_ArrayGetAxisIndexOld(array, totalindex, compindex, &
                                           exclindex, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(in) :: array 
      type(ESMF_AxisIndex), intent(inout), optional :: totalindex(:)
      type(ESMF_AxisIndex), intent(inout), optional :: compindex(:)
      type(ESMF_AxisIndex), intent(inout), optional :: exclindex(:)
      integer, intent(out), optional :: rc     
!
! !DESCRIPTION:
!      Used to retrieve the index annotation from an {\tt ESMF\_Array}.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array}.
!     \item [totalindex]
!           An array of index spaces for the total array size.
!     \item [{[compindex]}]
!           An array of index spaces for the computational array size.
!     \item [{[exclindex]}]
!           An array of index spaces for the exclusive array size.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

        integer :: status, i

        ! call c routine to get index
        if (present(totalindex)) then
          call c_ESMC_ArrayGetAxisIndex(array, ESMF_DOMAIN_TOTAL, totalindex,&
                                        status)
          if (status .ne. ESMF_SUCCESS) goto 10
          do i=1,size(totalindex)
            totalindex(i)%min = totalindex(i)%min + 1
            totalindex(i)%max = totalindex(i)%max + 1
          enddo
        endif

        if (present(compindex)) then
          call c_ESMC_ArrayGetAxisIndex(array, ESMF_DOMAIN_COMPUTATIONAL, &
                                        compindex, status)
          if (status .ne. ESMF_SUCCESS) goto 10
          do i=1,size(compindex)
            compindex(i)%min = compindex(i)%min + 1
            compindex(i)%max = compindex(i)%max + 1
          enddo
        endif

        if (present(exclindex)) then
          call c_ESMC_ArrayGetAxisIndex(array, ESMF_DOMAIN_EXCLUSIVE, &
                                        exclindex, status)
          if (status .ne. ESMF_SUCCESS) goto 10
          do i=1,size(exclindex)
            exclindex(i)%min = exclindex(i)%min + 1
            exclindex(i)%max = exclindex(i)%max + 1
          enddo
        endif

        status = ESMF_SUCCESS

 10   continue
        if (present(rc)) rc = status

        end subroutine ESMF_ArrayGetAxisIndexOld

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArrayPrint"
!BOP
! !IROUTINE: ESMF_ArrayPrint - Print contents of an Array object
!
! !INTERFACE:
      subroutine ESMF_ArrayPrint(array, options, rc)
!
! !ARGUMENTS:
      type(ESMF_Array) :: array
      character (len = *), intent(in), optional :: options
      integer, intent(out), optional :: rc 
!
! !DESCRIPTION:
!     Prints information about the {\tt array} to {\tt stdout}.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array}.
!     \item [{[options]}]
!           Print options are not yet supported.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!EOP

       character (len=6) :: defaultopts      ! default print options 
       integer :: status                     ! local error status
       logical :: rcpresent        

       ! Initialize return code; assume failure until success is certain
       status = ESMF_FAILURE
       rcpresent = .FALSE.
       if (present(rc)) then
         rcpresent = .TRUE.
         rc = ESMF_FAILURE
       endif

       if (array%this .eq. ESMF_NULL_POINTER) then
         print *, "Array Print:"
         print *, " Empty or Uninitialized Array"
         if (present(rc)) rc = ESMF_SUCCESS
         return
       endif

       defaultopts = "brief"

       if(present(options)) then
           call c_ESMC_ArrayPrint(array, options, status) 
       else
           call c_ESMC_ArrayPrint(array, defaultopts, status) 
       endif

       if (ESMF_LogMsgFoundError(status, &
                                    ESMF_ERR_PASSTHRU, &
                                    ESMF_CONTEXT, rc)) return

       ! set return values
       if (rcpresent) rc = ESMF_SUCCESS

       end subroutine ESMF_ArrayPrint

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArrayRead"
!BOPI
! !IROUTINE: ESMF_ArrayRead
!
! !INTERFACE:
      function ESMF_ArrayRead(name, iospec, rc)
!
! !RETURN VALUE:
      type(ESMF_Array) :: ESMF_ArrayRead
!
! !ARGUMENTS:
      character (len = *), intent(in) :: name              ! array name to read
      type(ESMF_IOSpec), intent(in), optional :: iospec    ! file specs
      integer, intent(out), optional :: rc                 ! return code
!
! !DESCRIPTION:
!     Read data from persistent storage in a variety of formats.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array}.
!     \item [{[iospec]}]
!           The file specification.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI
! !REQUIREMENTS:

!
!	Changed BOP/EOP to BOPI/EOPI until function is implemented.
!
        type (ESMF_Array) :: a

!       ! this is just to prevent compiler warnings
        a%this = ESMF_NULL_POINTER

!
! TODO: add code here
!

        ESMF_ArrayRead = a 

        if (present(rc)) rc = ESMF_FAILURE

        end function ESMF_ArrayRead

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArrayReadRestat"
!BOPI
! !IROUTINE: ESMF_ArrayReadRestart
!
! !INTERFACE:
      function ESMF_ArrayReadRestart(name, iospec, rc)
!
! !RETURN VALUE:
      type(ESMF_Array) :: ESMF_ArrayReadRestart
!
!
! !ARGUMENTS:
      character (len = *), intent(in) :: name 
      type(ESMF_IOSpec), intent(in), optional :: iospec 
      integer, intent(out), optional :: rc
!
! !DESCRIPTION:
!      Used to reinitialize
!      all data associated with an {\tt ESMF\_Array}
!      from the last call to writerestart.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array}.
!     \item [{[iospec]}]
!           The file specification.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI
! !REQUIREMENTS:

        type (ESMF_Array) :: a 

!       ! this is just to prevent compiler warnings
        a%this = ESMF_NULL_POINTER

!
! TODO: add code here
!

        ESMF_ArrayReadRestart = a 
 
        if (present(rc)) rc = ESMF_FAILURE

        end function ESMF_ArrayReadRestart

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArrayReorder"
!BOPI
! !IROUTINE: ESMF_ArrayReorder
!
! !INTERFACE:
      subroutine ESMF_ArrayReorder(array, newarrayspec, newarray, rc)
!
! !ARGUMENTS:
      type(ESMF_Array) :: array 
      type(ESMF_ArraySpec), intent(in) :: newarrayspec
      type(ESMF_Array):: newarray   
      integer, intent(out), optional :: rc       
!
! !DESCRIPTION:
!      Used to alter the local memory ordering (layout) of this Array.
!
!  !TODO: remove this note before generating user documentation
!
!      (i am not sure this makes sense now, or that the routine should be
!      in this class.  but i am leaving this here as a reminder that we
!      might need some low level reorder functions.  maybe the argument
!      should be another array or an arrayspec which describes what you
!      want, and the input array is what exists, and this routine can then
!      make one into the other.   is this a type of create?  or is this
!      a copy?)
!
!EOPI

!
! TODO: code goes here
!	Changed BOP/EOP to BOPI/EOPI until code is written.
!
        if (present(rc)) rc = ESMF_FAILURE

        end subroutine ESMF_ArrayReorder

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArraySetInt4Attr"

!BOP
! !IROUTINE: ESMF_ArraySetAttribute - Set a 4-byte integer attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_ArraySetAttribute()
      subroutine ESMF_ArraySetInt4Attr(array, name, value, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(inout) :: array  
      character (len = *), intent(in) :: name
      integer(ESMF_KIND_I4), intent(in) :: value
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!      Attaches a 4-byte integer attribute to the {\tt array}.
!      The attribute has a {\tt name} and a {\tt value}.
! 
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to add.
!     \item [value]
!           The integer value of the attribute to add.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP

      integer :: status                           ! Error status

      call c_ESMC_AttributeSetValue(array%this, name, &
                                    ESMF_DATA_INTEGER, ESMF_I4, 1, &
                                    value, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_ArraySetInt4Attr

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArraySetInt4ListAttr"

!BOP
! !IROUTINE: ESMF_ArraySetAttribute - Set a 4-byte integer list attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_ArraySetAttribute()
      subroutine ESMF_ArraySetInt4ListAttr(array, name, count, valueList, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(in) :: array  
      character (len = *), intent(in) :: name
      integer, intent(in) :: count   
      integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Attaches a 4-byte integer list attribute to the {\tt array}.
!     The attribute has a {\tt name} and a {\tt valueList}.
!     The number of integer items in the {\tt valueList} is
!     given by {\tt count}.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to add.
!     \item [count]
!           The number of integers in the {\tt valueList}.
!     \item [valueList]
!           The integer values of the attribute to add.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP

      integer :: status                           ! Error status
      integer :: limit

      limit = size(valueList)
      if (count > limit) then
          if (ESMF_LogMsgFoundError(ESMF_RC_OBJ_BAD, &
                                "count longer than valueList", &
                                 ESMF_CONTEXT, rc)) return
      endif

      call c_ESMC_AttributeSetValue(array%this, name, &
                                    ESMF_DATA_INTEGER, ESMF_I4, count, &
                                    valueList, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_ArraySetInt4ListAttr

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArraySetInt8Attr"

!BOP
! !IROUTINE: ESMF_ArraySetAttribute - Set an 8-byte integer attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_ArraySetAttribute()
      subroutine ESMF_ArraySetInt8Attr(array, name, value, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(inout) :: array  
      character (len = *), intent(in) :: name
      integer(ESMF_KIND_I8), intent(in) :: value
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!      Attaches an 8-byte integer attribute to the {\tt array}.
!      The attribute has a {\tt name} and a {\tt value}.
! 
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to add.
!     \item [value]
!           The integer value of the attribute to add.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP

      integer :: status                           ! Error status

      call c_ESMC_AttributeSetValue(array%this, name, &
                                    ESMF_DATA_INTEGER, ESMF_I8, 1, &
                                    value, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_ArraySetInt8Attr

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArraySetInt8ListAttr"

!BOP
! !IROUTINE: ESMF_ArraySetAttribute - Set an 8-byte integer list attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_ArraySetAttribute()
      subroutine ESMF_ArraySetInt8ListAttr(array, name, count, valueList, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(in) :: array  
      character (len = *), intent(in) :: name
      integer, intent(in) :: count   
      integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Attaches an 8-byte integer list attribute to the {\tt array}.
!     The attribute has a {\tt name} and a {\tt valueList}.
!     The number of integer items in the {\tt valueList} is
!     given by {\tt count}.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to add.
!     \item [count]
!           The number of integers in the {\tt valueList}.
!     \item [valueList]
!           The integer values of the attribute to add.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP

      integer :: status                           ! Error status
      integer :: limit

      limit = size(valueList)
      if (count > limit) then
          if (ESMF_LogMsgFoundError(ESMF_RC_OBJ_BAD, &
                                "count longer than valueList", &
                                 ESMF_CONTEXT, rc)) return
      endif

      call c_ESMC_AttributeSetValue(array%this, name, &
                                    ESMF_DATA_INTEGER, ESMF_I8, count, &
                                    valueList, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_ArraySetInt8ListAttr

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArraySetReal4Attr"

!BOP
! !IROUTINE: ESMF_ArraySetAttribute - Set a 4-byte real attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_ArraySetAttribute()
      subroutine ESMF_ArraySetReal4Attr(array, name, value, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(in) :: array  
      character (len = *), intent(in) :: name
      real(ESMF_KIND_R4), intent(in) :: value
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!      Attaches a 4-byte real attribute to the {\tt array}.
!      The attribute has a {\tt name} and a {\tt value}.
! 
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to add.
!     \item [value]
!           The real value of the attribute to add.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP

      integer :: status                           ! Error status

      call c_ESMC_AttributeSetValue(array%this, name, &
                                    ESMF_DATA_REAL, ESMF_R4, 1, value, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_ArraySetReal4Attr

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArraySetReal4ListAttr"

!BOP
! !IROUTINE: ESMF_ArraySetAttribute - Set a 4-byte real list attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_ArraySetAttribute()
      subroutine ESMF_ArraySetReal4ListAttr(array, name, count, valueList, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(in) :: array  
      character (len = *), intent(in) :: name
      integer, intent(in) :: count   
      real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Attaches a 4-byte real list attribute to the {\tt array}.
!     The attribute has a {\tt name} and a {\tt valueList}.
!     The number of real items in the {\tt valueList} is
!     given by {\tt count}.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to add.
!     \item [count]
!           The number of reals in the {\tt valueList}.
!     \item [value]
!           The real values of the attribute to add.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP

      integer :: status                           ! Error status
      integer :: limit

      limit = size(valueList)
      if (count > limit) then
          if (ESMF_LogMsgFoundError(ESMF_RC_OBJ_BAD, &
                                "count longer than valueList", &
                                 ESMF_CONTEXT, rc)) return
      endif

      call c_ESMC_AttributeSetValue(array%this, name, &
                                    ESMF_DATA_REAL, ESMF_R4, count, &
                                    valueList, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_ArraySetReal4ListAttr

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArraySetReal8Attr"

!BOP
! !IROUTINE: ESMF_ArraySetAttribute - Set an 8-byte real attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_ArraySetAttribute()
      subroutine ESMF_ArraySetReal8Attr(array, name, value, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(in) :: array  
      character (len = *), intent(in) :: name
      real(ESMF_KIND_R8), intent(in) :: value
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!      Attaches an 8-byte real attribute to the {\tt array}.
!      The attribute has a {\tt name} and a {\tt value}.
! 
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to add.
!     \item [value]
!           The real value of the attribute to add.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP

      integer :: status                           ! Error status

      call c_ESMC_AttributeSetValue(array%this, name, &
                                    ESMF_DATA_REAL, ESMF_R8, 1, value, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_ArraySetReal8Attr

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArraySetReal8ListAttr"

!BOP
! !IROUTINE: ESMF_ArraySetAttribute - Set an 8-byte real list attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_ArraySetAttribute()
      subroutine ESMF_ArraySetReal8ListAttr(array, name, count, valueList, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(in) :: array  
      character (len = *), intent(in) :: name
      integer, intent(in) :: count   
      real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Attaches an 8-byte real list attribute to the {\tt array}.
!     The attribute has a {\tt name} and a {\tt valueList}.
!     The number of real items in the {\tt valueList} is
!     given by {\tt count}.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to add.
!     \item [count]
!           The number of reals in the {\tt valueList}.
!     \item [value]
!           The real values of the attribute to add.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP

      integer :: status                           ! Error status
      integer :: limit

      limit = size(valueList)
      if (count > limit) then
          if (ESMF_LogMsgFoundError(ESMF_RC_OBJ_BAD, &
                                "count longer than valueList", &
                                 ESMF_CONTEXT, rc)) return
      endif

      call c_ESMC_AttributeSetValue(array%this, name, &
                                    ESMF_DATA_REAL, ESMF_R8, count, &
                                    valueList, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_ArraySetReal8ListAttr

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArraySetLogicalAttr"

!BOP
! !IROUTINE: ESMF_ArraySetAttribute - Set a logical attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_ArraySetAttribute()
      subroutine ESMF_ArraySetLogicalAttr(array, name, value, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(in) :: array  
      character (len = *), intent(in) :: name
      type(ESMF_Logical), intent(in) :: value
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Attaches a logical attribute to the {\tt array}.
!     The attribute has a {\tt name} and a {\tt value}.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to add.
!     \item [value]
!           The logical true/false value of the attribute to add.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP

      integer :: status                           ! Error status

      call c_ESMC_AttributeSetValue(array%this, name, &
                                    ESMF_DATA_LOGICAL, ESMF_NOKIND, 1, &
                                    value, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_ArraySetLogicalAttr

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArraySetLogicalListAttr"

!BOP
! !IROUTINE: ESMF_ArraySetAttribute - Set a logical list attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_ArraySetAttribute()
      subroutine ESMF_ArraySetLogicalListAttr(array, name, count, valueList, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(in) :: array  
      character (len = *), intent(in) :: name
      integer, intent(in) :: count   
      type(ESMF_Logical), dimension(:), intent(in) :: valueList
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Attaches a logical list attribute to the {\tt array}.
!     The attribute has a {\tt name} and a {\tt valueList}.
!     The number of logical items in the {\tt valueList} is
!     given by {\tt count}.
! 
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to add.
!     \item [count]
!           The number of logicals in the {\tt valueList}.
!     \item [value]
!           The logical true/false values of the attribute.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP

      integer :: status                           ! Error status
      integer :: limit

      limit = size(valueList)
      if (count > limit) then
          if (ESMF_LogMsgFoundError(ESMF_RC_OBJ_BAD, &
                                "count longer than valueList", &
                                 ESMF_CONTEXT, rc)) return
      endif

      call c_ESMC_AttributeSetValue(array%this, name, &
                                    ESMF_DATA_LOGICAL, ESMF_NOKIND, &
                                    count, valueList, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_ArraySetLogicalListAttr

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArraySetCharAttr"

!BOP
! !IROUTINE: ESMF_ArraySetAttribute - Set a character attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_ArraySetAttribute()
      subroutine ESMF_ArraySetCharAttr(array, name, value, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(in) :: array  
      character (len = *), intent(in) :: name
      character (len = *), intent(in) :: value
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!      Attaches a character attribute to the {\tt array}.
!     The attribute has a {\tt name} and a {\tt value}.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to add.
!     \item [value]
!           The character value of the attribute to add.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP

      integer :: status                           ! Error status

      call c_ESMC_AttributeSetChar(array%this, name, value, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_ArraySetCharAttr

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArraySetAxisIndex"
!BOPI
! !IROUTINE: ESMF_ArraySetAxisIndex
!
! !INTERFACE:
      subroutine ESMF_ArraySetAxisIndex(array, totalindex, compindex, &
                                        exclindex, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(inout) :: array 
      type(ESMF_AxisIndex), intent(inout), optional :: totalindex(:)
      type(ESMF_AxisIndex), intent(inout), optional :: compindex(:)
      type(ESMF_AxisIndex), intent(inout), optional :: exclindex(:)
      integer, intent(out), optional :: rc     
!
! !DESCRIPTION:
!      Used to annotate an {\tt ESMF\_Array} with information 
!      used to manage halo regions.
!           
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array}.
!     \item [{[totalindex]}]
!	    An array of index spaces for the total array size.
!     \item [{[compindex]}]
!	    An array of index spaces for the computational array size.
!     \item [{[exclindex]}]
!	    An array of index spaces for the exclusive array size.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!       
!
!EOPI

        integer :: status
        integer :: i

        ! call c routine to add index
        if (present(totalindex)) then
          do i=1,size(totalindex)
            totalindex(i)%min = totalindex(i)%min - 1
            totalindex(i)%max = totalindex(i)%max - 1
          enddo
          call c_ESMC_ArraySetAxisIndex(array, ESMF_DOMAIN_TOTAL, &
                                        totalindex, status)
          if (status .ne. ESMF_SUCCESS) goto 10
          do i=1,size(totalindex)
            totalindex(i)%min = totalindex(i)%min + 1
            totalindex(i)%max = totalindex(i)%max + 1
          enddo
        endif

        if (present(compindex)) then
          do i=1,size(compindex)
            compindex(i)%min = compindex(i)%min - 1
            compindex(i)%max = compindex(i)%max - 1
          enddo
          call c_ESMC_ArraySetAxisIndex(array, ESMF_DOMAIN_COMPUTATIONAL, &
                                        compindex, status)
          if (status .ne. ESMF_SUCCESS) goto 10
          do i=1,size(compindex)
            compindex(i)%min = compindex(i)%min + 1
            compindex(i)%max = compindex(i)%max + 1
          enddo
        endif

        if (present(exclindex)) then
          do i=1,size(exclindex)
            exclindex(i)%min = exclindex(i)%min - 1
            exclindex(i)%max = exclindex(i)%max - 1
          enddo
          call c_ESMC_ArraySetAxisIndex(array, ESMF_DOMAIN_EXCLUSIVE, &
                                        exclindex, status)
          if (status .ne. ESMF_SUCCESS) goto 10
          do i=1,size(exclindex)
            exclindex(i)%min = exclindex(i)%min + 1
            exclindex(i)%max = exclindex(i)%max + 1
          enddo
        endif

        status = ESMF_SUCCESS

 10   continue
        if (present(rc)) rc = status
        end subroutine ESMF_ArraySetAxisIndex

!------------------------------------------------------------------------------
! obsolete.  nsc 03nov05
!#undef  ESMF_METHOD
!#define ESMF_METHOD "ESMF_ArrayComputeAxisIndex"
!!BOPI
!! !IROUTINE: ESMF_ArrayComputeAxisIndex
!!
!! !INTERFACE:
!      subroutine ESMF_ArrayComputeAxisIndex(array, delayout, decompids, rc)
!!
!! !ARGUMENTS:
!      type(ESMF_Array), intent(inout) :: array 
!      type(ESMF_DELayout), intent(in) :: delayout
!      integer, dimension(:), intent(in) :: decompids
!      integer, intent(out), optional :: rc     
!!
!! !DESCRIPTION:
!!      Used to annotate an {\tt ESMF\_Array} with information 
!!      used to manage halo regions.
!!           
!!     The arguments are:
!!     \begin{description}
!!     \item [array]
!!           An {\tt ESMF\_Array}.
!!     \item [delayout]
!!           The {\tt ESMF\_DELayout} over which this {\tt ESMF\_Array}
!!           is decomposed.
!!     \item [decompids]
!!           An integer array, one index per dimension, identifying
!!           which axes are decomposed and in which order.
!!     \item [{[rc]}]
!!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!!     \end{description}
!!       
!!
!!EOPI
!
!        integer :: status
!        integer :: dlength
!
!        ! call c routine to do work
!        dlength = size(decompids)
!   !     call c_ESMC_ArrayComputeAxisIndex(array, delayout, decompids, &
!   !                                       dlength, status)
!        status = ESMF_FAILURE
!
!        if (present(rc)) rc = status
!
!        end subroutine ESMF_ArrayComputeAxisIndex
!
!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArraySet"
!BOP
! !IROUTINE: ESMF_ArraySet - Set information about an Array
!
! !INTERFACE:
      subroutine ESMF_ArraySet(array, name, rc)

!
! !ARGUMENTS:
      type(ESMF_Array), intent(inout) :: array
      character (len = *), intent(in), optional :: name
      integer, intent(out), optional :: rc

!
! !DESCRIPTION:
!     Sets the name of the {\tt ESMF\_Array}.  
!     Note: Unlike most other ESMF objects there are
!     very few items which can be changed once an {\tt ESMF\_Array} 
!     is created.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array}.
!     \item [{[name]}]
!           The array name.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!EOP

      integer :: status                           ! Error status
      logical :: rcpresent                        ! Return code present

      ! Initialize return code; assume failure until success is certain
      status = ESMF_FAILURE
      rcpresent = .FALSE.
      if (present(rc)) then
          rcpresent = .TRUE.
          rc = ESMF_FAILURE
      endif

      if (present(name)) then
          call c_ESMC_SetName(array, "Array", name, status)
          if (ESMF_LogMsgFoundError(status, &
                                    ESMF_ERR_PASSTHRU, &
                                    ESMF_CONTEXT, rc)) return
      endif

      if (rcpresent) rc = ESMF_SUCCESS

      end subroutine ESMF_ArraySet


!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArrayValidate"
!BOP
! !IROUTINE: ESMF_ArrayValidate - Check validity of an Array 
!
! !INTERFACE:
      subroutine ESMF_ArrayValidate(array, options, rc)
!
!
! !ARGUMENTS:
      type(ESMF_Array) :: array
      character (len = *), intent(in), optional :: options
      integer, intent(out), optional :: rc 
!
! !DESCRIPTION:
!      Validates that the {\tt array} is internally consistent.
!      Currently this method determines if the {\tt array} has a valid
!      data pointer.  The method returns an error code if problems 
!      are found.  
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array}.
!     \item [{[options]}]
!           Validation options are not yet supported.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP

       character (len=6) :: defaultopts      ! default print options 
       integer :: status                     ! local error status
       logical :: rcpresent        

       ! Initialize return code; assume failure until success is certain
       status = ESMF_FAILURE
       rcpresent = .FALSE.
       if (present(rc)) then
         rcpresent = .TRUE.
         rc = ESMF_FAILURE
       endif

       defaultopts = "brief"

       ! Simple validity checks
       if (array%this .eq. ESMF_NULL_POINTER) then
          ! TODO: this will always return.  
          if (ESMF_LogFoundError(ESMF_RC_OBJ_BAD, &
                                ESMF_CONTEXT, rc)) return
       endif

       if(present(options)) then
           !call c_ESMC_ArrayValidate(array, options, status) 
       else
           !call c_ESMC_ArrayValidate(array, defaultopts, status) 
       endif

       !if (status .ne. ESMF_SUCCESS) then
       !  print *, "Array validate error"
       !  return
       !endif

       ! Set return values
       if (rcpresent) rc = ESMF_SUCCESS

       end subroutine ESMF_ArrayValidate

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArrayWrite"
!BOP
! !IROUTINE: ESMF_ArrayWrite
!
! !INTERFACE:
      subroutine ESMF_ArrayWrite(array, iospec, filename, rc)
!
! !ARGUMENTS:
      type(ESMF_Array) :: array
      type(ESMF_IOSpec), intent(in), optional :: iospec
      character(len=*), intent(in), optional :: filename
      integer, intent(out), optional :: rc     
!
! !DESCRIPTION:
!      Used to write data to persistent storage in a variety of formats.  
!      (see writerestart/restore for quick data dumps.)  Details of I/O 
!      options specified with an {\tt ESMF\_IOSpec}.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array}.
!     \item [{[iospec]}]
!           The file specification.
!     \item [{[filename]}]
!           The file name.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!EOP

       character (len=16) :: defaultopts      ! default write options 
       character (len=16) :: defaultfile      ! default filename
       integer :: status                      ! local error status
       logical :: rcpresent        

       ! Initialize return code; assume failure until success is certain
       status = ESMF_FAILURE
       rcpresent = .FALSE.
       if (present(rc)) then
         rcpresent = .TRUE.
         rc = ESMF_FAILURE
       endif

       defaultopts = "singlefile"
       defaultfile = "datafile"

       if(present(filename)) then
           call c_ESMC_ArrayWrite(array, defaultopts, trim(filename), status) 
       else
           call c_ESMC_ArrayWrite(array, defaultopts, trim(defaultfile), status) 
       endif
       if (ESMF_LogMsgFoundError(status, &
                                 ESMF_ERR_PASSTHRU, &
                                 ESMF_CONTEXT, rc)) return

       ! Set return values
       if (rcpresent) rc = ESMF_SUCCESS

       end subroutine ESMF_ArrayWrite


!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArrayWriteRestart"
!BOPI
! !IROUTINE: ESMF_ArrayWriteRestart
!
! !INTERFACE:
      subroutine ESMF_ArrayWriteRestart(array, iospec, rc)
!
! !ARGUMENTS:
      type(ESMF_Array):: array 
      type(ESMF_IOSpec), intent(in), optional :: iospec
      integer, intent(out), optional :: rc            
!
! !DESCRIPTION:
!      Used to save all data to disk as quickly as possible.  
!      (see read/write for other options).  Internally this routine uses the
!      same I/O interface as read/write, but the default options are to
!      select the fastest way to save data to disk.
!     
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array}.
!     \item [{[iospec]}]
!           The file specification.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI
! !REQUIREMENTS:

!
! TODO: code goes here
!
        if (present(rc)) rc = ESMF_FAILURE

        end subroutine ESMF_ArrayWriteRestart


!------------------------------------------------------------------------------


       end module ESMF_ArrayMod

