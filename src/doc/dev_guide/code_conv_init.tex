% CVS $Id$


\subsection{Initialization Standardization Instructions}

\subsubsection{Overview}

Currently not all Fortran compilers support the
automatic initialization of class components. However,
in the ESMF system this initialization is used for two
tasks. The first is the initialization of shallow class
components which need to be set before they're used
(e.g. flags). The second is the detection of invalid
(e.g. not yet created) deep class variables. In order
to handle these tasks in the absence of compiler
initialization a software based solution has been
developed.

 The software solution is based on the improbability of
an uninitialized variable containing a specific value. For
example, given a 64 bit integer variable x, the
probability of x containing the value 10 are approximately
1 in $10^{19}$. This of course assumes that the value in
an uninitialized variable is a uniformly distributed random
variable, which is not necessarily true. However, the small probability
of a given value occurring is not an unreasonable assumption
given that the value is not pathological
(e.g. 0 or binary 111111..). The probability can
also be made as small as is necessary
by using larger precision types.

 Given the improbability of a specific value occurring in an
uninitialized variable, the task of initializing a shallow
class is implemented as follows. First, a non-pathological
value, ESMF\_INIT\_DEFINED, is chosen. Next, an integer
component, isInit, is added to the shallow class.
Finally, for every routine taking the shallow
class as an input variable, the component isInit is checked
against ESMF\_INIT\_DEFINED. If they don't match, then the variable
containing isInit is initialized, including setting isInit to
ESMF\_INIT\_DEFINED. If they do match, then with extremely high probability
the variable has already been initialized and nothing
need be done. This algorithm helps to ensure that the shallow
class is initialized before being used in the system.

 The task of detecting an invalid deep class is
implemented as follows. As before, we chose a value
ESMF\_INIT\_CREATED, and add the isInit component to the class
definition. Next, inside the constructors for
the class isInit is set to ESMF\_INIT\_CREATED, and
inside the destructors for the class isInit
is set to something other than ESMF\_INIT\_CREATED.
Finally, for every routine taking the deep class
as an input variable, the component isInit is
checked against ESMF\_INIT\_CREATED. If they match, then
nothing happens because with extremely high
probability the variable has been though the
constructor and thus is valid. If they don't match,
then the variable is invalid and an error occurs.
This allows invalid deep class variables to be detected
before being used in the system.

 In order to make the process of adding these non-compiler
based initialization tasks easier, a set of macros has been defined.
The following is a description of the procedures to use them.

\subsubsection{Instructions}

 These changes should be added to all new F90 code in both the source
(/src) and interface (/interface) subdirectories of the classes.

 When adding code as a part of this task remember to use
the standard ESMF coding conventions. In particular, when adding 
new routines remember to use the standard 
ESMF protex style (BOP/EOP) subroutine description, like those that
appear in every other ESMF subroutine. For Validate use 
the BOP/EOP tags for ESMF\_TYPEGetInit and ESMF\_TYPEInit 
use the internal BOPI/EOPI tags. 

 Some F90 source files are autogenerated. In this case, modify
the macro file which is used to create the autogenerated file. 
The macro file is usually named something like ESMF\_TypeMacos.h.
When modifying a macro file remember to end each line
with: @\ To recognize when an F90 file is autogenerated
they usually have the line: <Created by maco - do not edit directly>
close to the beginning. There will also usually be a .cpp
file with the same name as the .F90 file.

 For the purposes of initialization standardization the 
classes in the system have been divided into three types: shallow, deep,
and parameter. Shallow classes have little if any allocation and
can often be used right after declaration. An example of a shallow
class is ESMF\_ArraySpec.  Deep classes on the other hand  have a lot of
allocated data and need to be constructed before being used. An example of
a deep class is ESMF\_State. Parameter classes are 
those which are used to add type checking to a set of parameter values.
This type of class is typically just a single integer wrapped in a Fortran type.
An example of a parameter class is ESMF\_GridType. Both shallow and
deep classes are effected by the standardization, but parameter classes
are left unchanged. See section~\ref{is:typelist} for a list of
ESMF classes and their classification. 

  The instructions for the standardization have been broken 
up by what to do for each module, what to do for each type of class, 
and what to do for routines.

\subsubsection{Module}

When adding a new F90 module do the following:

\begin{enumerate}
\item If the following line is not present in the use statement list, then add 
it (except in ESMF\_LogErr.F90 and ESMF\_UtilTypes.F90):
\begin{verbatim}
    use ESMF_InitMacrosMod 
\end{verbatim}

\item If the following line is not present in the include statement list, then add it (except in ESMF\_LogErr.F90):
\begin{verbatim}
    #include "ESMF.h"
\end{verbatim}
\end{enumerate}


\subsubsection{Shallow Class}

 When adding a new shallow class definition perform the following steps:

\begin{enumerate}
\item If the line:
\begin{verbatim}
    use ESMF_UtilTypesMod 
\end{verbatim}
  isn't in the list of used modules, then add it.  

\item Add the line ESMF\_INIT\_DECLARE to the type definition.
\item Be sure the \#ifndef ESMF\_NO\_INITIALIZERS construct is
    used around any initialization of type components. 
    The declarations inside the \#else to \#endif half of the construct
    should be identical to the \#ifndef half except without initialization.
\item Create an initialization subroutine for the class.
    Given that the name of the class is ESMF\_STYPE,
    the name of the subroutine should be ESMF\_STYPEInit().
    This subroutine should take a single parameter of class
    ESMF\_STYPE and set all the variables that are
    initialized in the \#ifndef ESMF\_NO\_INITIALIZERS branch
    of 3. Note, for pointers that are set using ptr->Null()
    in the type initialization, use nullify(t\%ptr) in the 
    ESMF\_STYPEInit subroutine instead. 
\item Add the line ESMF\_INIT\_SET\_DEFINED(S1) to the body of
    the new subroutine ESMF\_STYPEInit() described in 4.
     S1 is the variable being initialized in ESMF\_STYPEInit().
\item Create an access subroutine for the new init component.
    The name of the subroutine should be ESMF\_STYPEGetInit.
    It should have the following form:

\begin{verbatim}
    function ESMF_STYPEGetInit(s)
       type(ESMF_STYPE), intent(in), optional :: s
       ESMF_INIT_TYPE :: ESMF_STYPEGetInit

      if (present(s)) then
          ESMF_STYPEGetInit=ESMF_INIT_GET(s)
      else
          ESMF_STYPEGetInit=ESMF_INIT_DEFINED
      endif

    end function ESMF_STYPEGetInit
\end{verbatim}

\item Create an ESMF\_STYPEValidate subroutine with the following form:

\begin{verbatim}
    ! Comments describing validate (see ESMF_StateValidate for an example)
    subroutine ESMF_STYPEValidate(s,rc)
       type(ESMF_STYPE), intent(inout) :: s
       integer, intent(out),optional :: rc

       ! check initialization status
       ESMF_INIT_CHECK_SET_SHALLOW(ESMF_STYPEGetInit,ESMF_STYPEInit,s)
       
       ! return success
       if (present(rc)) then
          rc=ESMF_SUCCESS
       endif

    end subroutine ESMF_STYPEValidate
\end{verbatim}

\item If the shallow class in question is public, then
    add the lines:
\begin{verbatim}
       public ESMF_STYPEInit
       public ESMF_STYPEGetInit
       public ESMF_STYPEValidate
\end{verbatim}
    to the PUBLIC MEMBER FUNCTION section. 

\item Add the new class to the list in section~\ref{is:typelist}.

\end{enumerate}

Here is an example illustrating the whole procedure: \\

Starting with this shallow class definition:

\begin{verbatim}
   module ESMF_ExampleMod

       type ESMF_Shallow
           private
            ... other components ...
#ifndef ESMF_NO_INITIALIZERS
            integer :: num=0
            integer, pointer :: list(:) => Null()
#else
            integer :: num
            integer, pointer :: list(:)
#endif
       end type

! !PUBLIC TYPES:
      public ESMF_Shallow 
     
! !PUBLIC MEMBER FUNCTIONS:

       contains

       ... other routines ...

   end module ESMF_ExampleMod
\end{verbatim}

The standardization procedure yields this:\\
(modified lines marked with *)

\begin{verbatim}
   module ESMF_ExampleMod
*       use ESMF_UtilTypesMod 
*       use ESMF_InitMacrosMod 

       type ESMF_Shallow
            private
            ... other components ...
#ifndef ESMF_NO_INITIALIZERS
            integer :: num=0
            integer, pointer :: list(:) => Null()
#else
            integer :: num
            integer, pointer :: list(:)
#endif
*            ESMF_INIT_DECLARE
       end type

! !PUBLIC TYPES:
      public ESMF_Shallow 

! !PUBLIC MEMBER FUNCTIONS:
*      public ESMF_ShallowInit
*      public ESMF_ShallowValidate
*      public ESMF_ShallowGetInit

       contains

*    function ESMF_ShallowGetInit(s)
*       type(ESMF_Shallow), intent(in), optional :: s
*       ESMF_INIT_TYPE :: ESMF_ShallowGetInit
*
*      if (present(s)) then
*          ESMF_ShallowGetInit=ESMF_INIT_GET(s)
*      else
*          ESMF_ShallowGetInit=ESMF_INIT_DEFINED
*      endif
*
*    end function ESMF_ShallowGetInit
*
*    subroutine ESMF_ShallowInit(s)
*       type(ESMF_Shallow) :: s
*    
*        s%num=0 
*        nullify(s%list)
*
*        ESMF_INIT_SET_DEFINED(s) 
*    end subroutine ESMF_ShallowInit
*
*    subroutine ESMF_ShallowValidate(s,rc)
*       type(ESMF_Shallow), intent(inout) :: s
*       integer, intent(out),optional :: rc
*
*       ! check initialization status
*       ESMF_INIT_CHECK_SET_SHALLOW(ESMF_ShallowGetInit,ESMF_ShallowInit,s)
*       
*       ! return success
*       if (present(rc)) then
*          rc=ESMF_SUCCESS
*       endif
*
*    end subroutine ESMF_ShallowValidate

       ... other routines ...

   end module ESMF_Shallow
\end{verbatim}

\subsubsection{Deep Class}

 When adding a new deep class definition perform the following steps:

\begin{enumerate}
\item If the line:
\begin{verbatim}
      use ESMF_UtilTypesMod
\end{verbatim} 
    isn't in the list of used modules, then add it.  
\item Add the line ESMF\_INIT\_DECLARE to the type definition.
\item Add the line ESMF\_INIT\_SET\_CREATED(D1) to the
      TypeCreate() function. D1 is the deep class variable
      being created.
\item Add the line ESMF\_INIT\_SET\_DELETED(D1) to the
      TypeDestroy() subroutine. D1 is the deep class
      variable being destroyed.
\item Create an access subroutine for the new init component.
    The name of the subroutine should be ESMF\_DTYPEGetInit.
    It should have the following form:
\begin{verbatim}
    function ESMF_DTYPEGetInit(d)
       type(ESMF_DTYPE), intent(in),optional :: d
       ESMF_INIT_TYPE :: ESMF_DTYPEGetInit

      if (present(d)) then
          ESMF_DTYPEGetInit=ESMF_INIT_GET(d)
      else
          ESMF_DTYPEGetInit=ESMF_INIT_CREATED
      endif

    end function ESMF_DTYPEGetInit
\end{verbatim}

\item Given that the deep class is ESMF\_DTYPE create a validate subroutine
 with the following form:
\begin{verbatim}
    ! Comments describing validate (see ESMF_StateValidate for an example)
    subroutine ESMF_DTYPEValidate(d1,rc)
       type(ESMF_DTYPE), intent(in) :: d1
       integer, intent(out),optional :: rc

       ! Check Init Status
       ESMF_INIT_CHECK_DEEP(ESMF_DTYPEGetInit,d1,rc)

       ! Add other checks here

       ! If all checks passed return success
       if (present(rc)) then
           rc=ESMF_SUCCESS
       endif

    end subroutine ESMF_DTYPEValidate
\end{verbatim}

\item If the deep class in question is public, then
    add the lines:
\begin{verbatim}
       public ESMF_DTYPEGetInit
       public ESMF_DTYPEValidate
\end{verbatim}
    to the PUBLIC MEMBER FUNCTION section.

\item  Some deep classes are private and occasionally it
will become necessary to access their internal components
to set the initialization flag or get the this pointer
in code which doesn't have access. The standard way
to do this in ESMF is to write a public subroutine in the 
class module where the subroutine can have access to 
the classes' internal components.

 The following are the standard names for the subroutines
which set a class as created, set a class as deleted, and set the this 
pointer, and get the this pointer:
\begin{verbatim}
ESMF_DTYPESetInitCreated
ESMF_DTYPESetInitDeleted
ESMF_DTYPESetThis
ESMF_DTYPEGetThis
\end{verbatim}


\item Add the new class to the list in section~\ref{is:typelist}.

\end{enumerate}

    
Here is an example illustrating the whole procedure: \\

Starting with this deep type definition:

\begin{verbatim}
   module ESMF_ExampleMod

       type ESMF_Deep
            private
            ... other components ...
       end type

! !PUBLIC TYPES:
      public ESMF_Deep

! !PUBLIC MEMBER FUNCTIONS:

       contains

        function ESMF_DeepCreate()
              type(ESMF_Deep) :: ESMF_DeepCreate

              ... other create code ...

        end function ESMF_DeepCreate

        subroutine ESMF_DeepDestroy(d)
              type(ESMF_Deep) :: d

              ... other create code ...

        end subroutine ESMF_DeepDestroy

        ... other routines ...

   end module ESMF_ExampleMod
\end{verbatim}

The standardization procedure yields this:\\
(modified lines marked with *)

\begin{verbatim}
   module ESMF_ExampleMod
*       use ESMF_UtilTypesMod 
*       use ESMF_InitMacrosMod       

       type ESMF_Deep
           private
           ... other components ...
*           ESMF_INIT_DECLARE
       end type

! !PUBLIC TYPES:
      public ESMF_Deep

! !PUBLIC MEMBER FUNCTIONS:
*      public ESMF_DeepValidate     
*      public ESMF_DeepGetInit     

       contains

*    function ESMF_DeepGetInit(d)
*       type(ESMF_Deep), intent(in),optional :: d
*       ESMF_INIT_TYPE :: ESMF_DeepGetInit
*
*       if (present(d)) then
*          ESMF_DeepGetInit=ESMF_INIT_GET(d)
*      else
*          ESMF_DeepGetInit=ESMF_INIT_CREATED
*      endif
*
*    end function ESMF_DeepGetInit
*
*       subroutine ESMF_DeepValidate(d,rc)
*          type(ESMF_Deep), intent(in) :: d
*          integer, intent(out),optional :: rc
*
*          ! Check Init Status
*          ESMF_INIT_CHECK_DEEP(ESMF_DeepGetInit,d,rc)
*
*         ! Add other checks here
*
*         ! If all checks passed return success
*         if (present(rc)) then
*            rc=ESMF_SUCCESS
*         endif
*
*        end subroutine ESMF_DeepValidate

        function ESMF_DeepCreate()
              type(ESMF_Deep) :: ESMF_DeepCreate

              ... other create code ...

*              ESMF_INIT_SET_CREATED(ESMF_DeepCreate)

        end function ESMF_DeepCreate

        subroutine ESMF_DeepDestroy(d)
              type(ESMF_Deep) :: d

              ... other create code ...

*              ESMF_INIT_SET_DELETED(d)

        end subroutine ESMF_DeepDestroy

        ... other routines ...

   end module ESMF_ExampleMod
\end{verbatim}

\subsubsection{Parameter Class}

When adding a new parameter class definition, don't add any initialization
standardization code. However, do add the new class to the class list in
section~\ref{is:typelist}.

\subsubsection{Subroutine}

   When adding a new subroutine or function (both referred 
to as 'routine' henceforth) perform the following steps:

\begin{enumerate}
\item At the beginning of the routine, for each shallow
      class parameter S1 of type ESMF\_STYPE. Add the line
      ESMF\_INIT\_CHECK\_SHALLOW(ESMF\_STYPEGetInit, ESMF\_STYPEInit, S1).
      In addition, if the intent of S1 is intent(in), switch it to 
      intent(inout) to allow it to be modified.  

\item At the beginning of each routine, for each deep
     class *input* parameter D1 of type ESMF\_DTYPE, add the line
     ESMF\_INIT\_CHECK\_DEEP(ESMF\_DTYPEGetInit, D1, rc). 
     Here rc is the return code variable
     for the routine.
\end{enumerate}

 The initialization macros in 1. and 2. should be
added before any code which uses the types being checked. 

  When adding the check macros to code there are a couple of issues
to keep in mind for compatibility with all compilers. First, 
don't break up the macro across lines (e.g. using \&). 
Second, some compilers have a maximum line length. Occasionally, 
the Deep class check macro will expand to larger than this
length, if you find that this is occurring with a particular
line use the ESMF\_INIT\_CHECK\_DEEP\_SHORT macro instead. 
It takes exactly the same parameter list as the normal deep class
check macro, but expands to a much shorter line. 

 Here is an example illustrating this procedure: \\

Starting with this routine:

\begin{verbatim}
   subroutine ESMF_EXAMPLE(s1,d1,s2,d2,d3,rc)
         type(ESMF_Shallow1), intent(in) :: s1
         type(ESMF_Shallow2), intent(out) :: s2
         type(ESMF_Deep1),intent(in) :: d1
         type(ESMF_Deep2),intent(inout) :: d2
         type(ESMF_Deep3),intent(out) :: d3
         integer :: rc
         .... local variable declarations ...

         ! initialize return code
         rc=ESMF_FAILURE

          ...... rest of subroutine code....

  end subroutine ESMF_Example
\end{verbatim}

The standardization yields this:\\
(modified lines marked with *)

\begin{verbatim}
   subroutine ESMF_EXAMPLE(s1,d1,s2,d2,d3,rc)
*         type(ESMF_Shallow1), intent(inout) :: s1
         type(ESMF_Shallow2) :: s2
         type(ESMF_Deep1) :: d1
         type(ESMF_Deep2),intent(inout) :: d2
         type(ESMF_Deep3),intent(out) :: d3
         integer :: rc
         .... other local variable declarations ...

         ! initialize return code
         rc=ESMF_FAILURE

*         ! check variables
*         ESMF_INIT_CHECK_DEEP(ESMF_Deep1GetInit,d1,rc)
*         ESMF_INIT_CHECK_DEEP(ESMF_Deep2GetInit,d2,rc)
*
*         ESMF_INIT_CHECK_SET_SHALLOW(ESMF_Shallow1GetInit,ESMF_Shallow1Init,s1)
*         ESMF_INIT_CHECK_SET_SHALLOW(ESMF_Shallow2GetInit,ESMF_Shallow2Init,s2)

          ...... rest of subroutine code....

  end subroutine ESMF_Example
\end{verbatim}

\subsubsection{ESMF Class Types}\label{is:typelist}

CAUTION: The following lists are very much outdated!!!

\begin{table}[t]
\begin{tabular}{llll}

{\bf Class} & {\bf Type} & {\bf Fortran} & {\bf ESMF} \\ \hline

ESMF\_Alarm                 & Deep            & public & public  \\
ESMF\_AlarmList\_Flag       & Parameter       & public & public  \\
ESMF\_Array                 & Deep            & &  \\
ESMF\_ArrayBundle           & Deep            & &  \\
ESMF\_ArraySpec             & Shallow         & &  \\
ESMF\_Attribute             & Shallow         & &  \\
ESMF\_Base                  & Deep            & &  \\
ESMF\_BaseTime              & Shallow         & &  \\
ESMF\_CWrap                 & Deep            & &  \\
ESMF\_Calendar              & Deep            & &  \\
ESMF\_CalKind\_Flag         & Parameter       & &  \\
ESMF\_Clock                 & Deep            & &  \\
ESMF\_CommHandle            & Deep            & &  \\
ESMF\_CommTable             & Deep            & &  \\
ESMF\_CompClass             & Deep            & &  \\
ESMF\_CompType\_Flag        & Parameter       & &  \\
ESMF\_Config                & Deep            & &  \\
ESMF\_ConfigAttrUsed        & Shallow         & &  \\
ESMF\_Context\_Flag         & Parameter       & &  \\
ESMF\_CoordOrder            & Parameter       & &  \\
ESMF\_CplComp               & Deep            & &  \\
ESMF\_DELayout              & Deep            & &  \\
ESMF\_DataHolder            & Shallow         & &  \\
ESMF\_DataValue             & Ignore          & &  \\
ESMF\_Decomp\_Flag          & Parameter       & &  \\
ESMF\_Direction\_Flag       & Parameter       & &  \\
ESMF\_DistGrid              & Deep            & &  \\
ESMF\_Field                 & Deep            & &  \\
ESMF\_FieldBundle           & Deep            & &  \\
ESMF\_FieldBundleDataMap    & Shallow         & &  \\
ESMF\_FieldBundleType       & Deep            & &  \\
ESMF\_FieldDataMap          & Shallow         & &  \\
ESMF\_FieldType             & Deep            & &  \\
ESMF\_Fraction              & Shallow         & &  \\
ESMF\_Grid                  & Deep            & &  \\
ESMF\_GridComp              & Deep            & &  \\
ESMF\_GridStatus\_Flag      & Parameter       & &  \\
ESMF\_Index\_Flag           & Parameter       & &  \\
ESMF\_InterfaceInt          & Ignore          & &  \\

\end{tabular}
\end{table}

\begin{table}[t]
\begin{tabular}{llll}

{\bf Class} & {\bf Type} & {\bf Fortran} & {\bf ESMF} \\ \hline

ESMF\_LOGENTRY              & Shallow         & &  \\
ESMF\_LocalArray            & Deep            & &  \\
ESMF\_Log                   & Shallow         & &  \\
ESMF\_LogKind\_Flag         & Parameter       & &  \\
ESMF\_Logical               & Ignore          & &  \\
ESMF\_Mask                  & Shallow         & &  \\
ESMF\_LogMsg\_Flag          & Parameter       & &  \\
ESMF\_NeededFlag            & Parameter       & &  \\
ESMF\_ObjectID              & Shallow         & &  \\
ESMF\_Pin\_Flag             & Parameter       & &  \\
ESMF\_PhysGrid              & Deep            & &  \\
ESMF\_Pointer               & Ignore          & &  \\
ESMF\_ReadyFlag             & Parameter       & &  \\
ESMF\_Reduce\_Flag          & Parameter       & &  \\
ESMF\_Region\_Flag          & Parameter       & &  \\
ESMF\_RegridMethod\_Flag    & Parameter       & &  \\
ESMF\_RelLoc                & Parameter       & &  \\
ESMF\_ReqForRestartFlag     & Parameter       & &  \\
ESMF\_Route                 & Deep            & &  \\
ESMF\_RouteHandle           & Deep            & &  \\
ESMF\_StaggerLoc            & Shallow         & &  \\
ESMF\_State                 & Deep            & &  \\
ESMF\_StateClass            & Deep            & &  \\
ESMF\_StateItem             & Shallow         & &  \\
ESMF\_StateItem\_Flag       & Parameter       & &  \\
ESMF\_StateIntent\_Flag     & Parameter       & &  \\
ESMF\_Status                & Parameter       & &  \\
ESMF\_Sync\_Flag            & Parameter       & &  \\
ESMF\_End\_Flag             & Parameter       & &  \\
ESMF\_Time                  & Shallow         & &  \\
ESMF\_TimeInterval          & Shallow         & &  \\
ESMF\_VM                    & Deep            & &  \\
ESMF\_VMId                  & Deep            & &  \\
ESMF\_VMPlan                & Deep            & &  \\
ESMF\_ValidFlag             & Parameter       & &  \\

\end{tabular}
\end{table}

















