% CVS $Id$

\subsection{Docs: Code and Documentation Templates and Associated Scripts}
\label{sec:code_templates}

ESMF maintains a set of templates for developing Fortran and 
C++ codes and their documentation.  The documentation templates
include requirements, design, and reference documents.
These templates are bundled with the source distribution, in 
the following directory:\newline
\begin{verbatim}
$(ESMF_DIR)/scripts/doc_templates 
\end{verbatim} 

\subsubsection{Documentation Generation Script}

The {\tt do\_newdoc} script in the document templates package creates
a new document directory and populates it with the appropriate files.
The READMEs in the package describe the procedure for running the 
script.

\subsubsection{Code Generation Scripts}
A set of scripts is available that creates a set of new directories for either 
a C++ or Fortran class and populates them with the appropriate code and 
document files.  The READMEs in the {\tt doc\_templates} 
package describe the procedures for doing this.  

The following scripts are included in the {\tt doc\_templates} package:
\begin{description}
\item [do\_newcomp] This script creates a new component. It makes a new component directory
tree if one does not already exist. In addition, it adds the required template files
in the component directory tree with the proper root file names.
\item [do\_newclass] This script creates a new class template in the current directory. 
It may be used for both C++ and Fortran 90 classes. For C++, it adds an include
file (ESMC\_class.h) in the component include directory, if one does not exist.
\end{description}

\subsection{Docs: Documentation Guidelines and Conventions}
\label{sec:docguidelines}

\subsubsection{Accessibility}

Software documentation for the last public release is at:
\begin{verbatim}
  http://www.earthsystemmodeling.org -> Users -> Documentation
\end{verbatim} 

Software documentation for all releases is at:
\begin{verbatim}
  http://www.earthsystemmodeling.org -> Download -> View All Releases
\end{verbatim}

Documents are available to developers for editing through the
ESMF repository on the SourceForge site.

\subsubsection{File format}

Documents will be available in both web-browsable (e.g. html) and
printer-friendly formats.  They will be written in \LaTeX\ and based on a
set of templates. \LaTeX\ was chosen because:

\begin{itemize}
\item it is a format that many people are already familiar with; 
\item it can produce both print and web documentation by using text-to-html
tools such as \htmladdnormallink{latex2html} 
{http://laborant.dfki.uni-sb.de:8000/doc/latex2html-manual-html-99\_1/};
\item it is the format generated by the F90/C++ compatible 
auto-documentation tool \htmladdnormallink{ProTeX}
{http://polar.gsfc.nasa.gov/software/protex/protex.php}\cite{protex}, 
which we shall use.
\end{itemize}

\subsubsection{Typeface and Diagram Conventions}

\input{../ESMF_typefaceconventions}

\subsubsection{Style Rules for \LaTeX}

General style recommendations for \LaTeX\ documentation include the
following:

\begin{enumerate}
\item Limiting the source file text width to 80 characters;
\item The use of proper indentation in sections and environments;
\item The liberal use of blank lines to delimit blocks;
\item Leaving as much of the typesetting as possible to \LaTeX\ itself
  (user-specified lengths, pagebreaks, etc. are discouraged);
\item The use of the \texttt{html} package for convenient production
  of HTML and print formats;
\item The use of the \texttt{fontenc} packages
  to permit use of \LaTeX\ special tokens in source;
\item The use of a Type-I font (e.g the \texttt{times} or
  \texttt{palatcm} packages) to provide scaling PDF documents.
\end{enumerate}

\subsection{Docs: Performance Report Conventions}
Measurements and analysis of ESMF performance are documented in
performance reports.  These reports are used to communicate 
information about framework performance, and are used to
define and assess the success of optimization efforts.
They are posted on the ESMF website under the {\bf Performance}
link.  Reports typically contain the following sections:  Objective,
Description of the Benchmark,  Results, Optimizations 
and Conclusions.

Performance reports should contain the following specific 
information:
\begin{enumerate}
\item The tag or version of the framework used ({\it not} a moving tag,
like HEAD or LAST\_STABLE)
\item Where to get the source code
\item Machine location and type
\item OS and compiler version
\item Processor counts
\item Complete description of grids and distributions or where
to get that info
\item How many iterations were performed for each data point
\item How the timings were obtained from the iterations 
\end{enumerate}

\subsection{Docs: Reference Manual Conventions}

\subsubsection{Description, Use and Examples, and Other Introductory Sections}

\begin{enumerate}
\item These sections shall contain thorough coverage of class
behavior and usage.  Any mention of private classes or implementation 
strategies shall be reserved for the sections called {\it Design and 
Implementation Notes}.  Restrictions shall be listed in the 
{\it Restrictions and Future Work} sections.
  
\item If a method name is referred to in the text it shall be in this
fashion {\tt ESMF\_<Class><MethodName>()}.  If a code fragment or flag is
included in the text, we shall use the form {\tt ESMF\_<FLAG\_NAME>} 
or surround the fragment with the \LaTeX\ {\tt verbatim} command.  The 
goal is to get all code fragments in an identifiable font.

\item Class names shall be capitalized in these sections, and
in the normal text font, e.g. Field.  The reason is that 
Field is not an ESMF derived type or code fragment and writing 
the full type, e.g. {\tt ESMF\_Field}, everywhere makes long 
explanations less readable.

\item Verbs like halo and regrid shall not be capitalized since they 
are not public classes. The exception is when such a verb is also a
private class, and it is written about in that context.  For example, 
when writing about Regrid as a private class in a {\it Design and 
Implementation Notes} section it is appropriate to capitalize it.

\item Full class names shall be used everywhere (e.g., Layout will
not be used as a shorthand for DELayout).

\end{enumerate}

\subsubsection{Examples Sections}

A standard template for examples has not yet been created.

\subsubsection{Flags and Options Sections}

\begin{enumerate}
\item All flags and options (hereafter referred to as options) 
shall be broken out into separate sections called {\it <Class> Options}.  
Options shall each have their own derived type, 
e.g. {\tt ESMF\_Sync\_Flag}, and valid values will be all capitals
with underscore separators, e.g. {\tt ESMF\_SYNC\_NONBLOCKING}.

\item When possible, call options <Class>Type or <Something>Flag and
name the argument in the argument list the same thing.  For example,
the option {\tt ESMF\_Sync\_Flag} has associated arguments 
called {\tt syncflag}.

\item The purpose of options shall be fully described along with all 
valid values in the options sections of the document.  See the
standard format in {\it Calendar Options} or {\it Grid Options}.

\item In the sections describing the usage and values for options, 
only use the full class name, e.g. {\tt ESMF\_Field}, method names such
as {\tt ESMF\_FieldWrite}, or particular argument names, such as {\tt
syncflag}. Do not use the more informal form of the short class
name in a regular font, e.g. Field.  The rationale is that here we 
are carefully specifying interface behavior and are referring only 
to particular ESMF types, values, and methods.  It is a pain in 
the neck to be that rigorous in the longer text sections 
(like {\it Description}), but it is helpful to be precise for the 
API specification.
\end{enumerate}

\subsubsection{Class API Sections}

\begin{enumerate}
\item Public class methods shall be capitalized by name within a file.
Generally private methods are listed at the end of the file.  Especially 
for classes with many methods, this makes locating a particular method 
somewhat easier.

\item All public methods shall be fully documented in the {\it Reference
Manual}.  Private methods without interfaces shall not appear at all.
Private methods that are overloaded with public interface shall follow
a standard format that clearly indicates that the methods are overloaded;
see {\tt ESMF\_FieldCreate()} for an example.

\item The {\it Reference Manual} shall include for each class a thorough
specification of behavior, including any default values or behaviors.
Description of options can reference {\it <Class> Options} sections.
All descriptions should contain complete sentences with periods,
e.g. "This method sets invalid values for an {\tt ESMF\_FieldBundle} object."

\item The brief one-line description that follows the method name shall
begin with a capital and have no period at the end.

\item All methods shall conform to method naming conventions.

\item Functions shall have their data type and return variable name declared
on a separate line after the {\tt function} statement, and prior to the
argument list declarations.  The data type shall not appear in the
{\tt function} statement.  The optional {\tt result} clause should also
not be used.

\item All arguments shall conform to variable naming conventions
for capitalization and standard use of terms such as count, dim, etc.
The conventions shall be used even if names become fairly long.
All class names will be used in full, e.g. DELayout will not be
used instead of DELayout.  Cryptic abbreviations like {\tt btype} 
shall not be used - use {\tt bundleType} instead.

\item As with descriptions of flags and options:  in the sections describing
methods, only use the full class name, e.g. {\tt ESMF\_Field}, method names such
as {\tt ESMF\_FieldWrite}, or particular argument names, such as {\tt
syncflag}. Do not use the more informal short form in regular 
font, e.g. Field.

\end{enumerate}


\subsection{Code: Method Conventions}

\subsubsection{Standard Method Names}

ESMF defines a set of standard methods and interface rules that
hold across the entire API.  These are: 

\begin{itemize}

\item {\tt ESMF/C\_<Class>Create()} and {\tt ESMF\_<Class>Destroy()}, for creating and 
destroying classes.  The {\tt ESMF\_<Class>Create()} method allocates 
memory for the class structure itself and for internal variables, and
initializes variables as appropriate.  It is always written as a 
Fortran function that returns a derived type instance of the class.

\item {\tt ESMF/C\_<Class>Set()} and {\tt ESMF\_<Class>Get()}, for setting 
and retrieving a particular item or flag.  In general, these methods are
overloaded for all cases where the item can be manipulated as a
name/value pair.  If identifying the item requires more than a 
name, or if the class is of sufficient complexity that overloading
in this way would result in an overwhelming number of options, we 
define specific {\tt ESMF\_<Class>Set<Something>} and 
{\tt ESMF\_<Class>Get<Something>} interfaces.

\item {\tt ESMF/C\_<Class>Add()}, {\tt ESMF\_<Class>Get()}, and 
{\tt ESMF\_<Class>Remove()} for manipulating 
items that can be appended or inserted into a list of like
items within a class.  For example, the {\tt ESMF\_StateAdd()}
method adds another Field to the list of Fields contained
in the State class.

\item {\tt ESMF/C\_<Class>Print()}, for printing the contents of a class to 
standard out.  This method is mainly intended for debugging.

\item {\tt ESMF/C\_<Class>ReadRestart()} and {\tt ESMF\_<Class>WriteRestart}, 
for saving the contents of a class and restoring it exactly.  Read
and write restart methods have not yet been implemented for most
ESMF classes, so where necessary the user needs to write restart 
values themselves.

\item {\tt ESMF/C\_<Class>Validate()}, for determining whether a class is 
internally consistent.  For example, {\tt ESMF\_FieldValidate} checks 
whether the Array and Grid associated with a Field are consistent.
  
\item{\tt ESM[F/C]\_<Class>Construct()} and {\tt ESM[F/C]\_<Class>Destruct()},
for initializing a previously allocated object with valid data.  This 
function is called by the create function.  Depending on the type of 
object this function may or may not allocate resources that need to be freed.  
Only for ESMF internal usage; not visible to users.

\end{itemize}

\subsubsection{Use of *Set and *Get} In general, Set and Get calls with optional arguments
for each possible attribute to be processed shall be used instead of individual
Set and Get calls.  The goals are a smaller, clearer interface and easier extensibility.
An exception is when the Set or Get does not translate to a simple name/value pair,
for instance when one element of an array of internal attributes must be retrieved.

\subsubsection{Use of Is* and Has*} Methods names that indicate the 
presence of some attribute or quality shall use the Has* form.  Methods 
that indicate a condition shall use the Is* form; for example, 
{\tt ESMF\_DELayoutIsLocal}.  In Fortran, these should return {\tt logical}
data type results.  The goals are consistency and clarity.

\subsubsection{Functions vs. Subroutines}
Most Fortran calls in the ESMF are subroutines, with 
any returned values passed through the interface.  For the sake of 
convenience, some ESMF calls are written as functions.

\subsubsection{Source and Destination Ordering}
In ESMF we shall follow a source first, then destination convention when ordering
arguments.

\subsection{Code: Argument Conventions}

The naming conventions listed here apply to arguments that appear in 
ESMF public interfaces.  It is nice if internal arguments also adhere
to these conventions, but not enforced as it is as the interface.

\subsubsection{Standard Variable Names}

The following table lists a set of standard terms that we use in ESMF.

\begin{tabular}{ll}
{\tt Cell} & grid cell \\
{\tt Coord} & coordinate \\
{\tt Count} & count \\
{\tt Dim} & dimension, used for grids \\
{\tt Dst} & destination \\
{\tt List} & indicates that the quantity is an array \\
{\tt Local} & indicates that the quantity is associated with a PET or DE \\
{\tt Per} & per item \\
{\tt Rank} & data array dimension \\
{\tt Send} & send \\
{\tt Src} & source \\
{\tt Recv} & receive \\
\end{tabular}


These are used in combination to create argument and variable names.  
For example, {\tt localCellCountPerDimList} is an array of counts, per 
dimension, of the number of local grid cells.

\subsubsection{Use of Is* and Has*} Variable names that indicate the 
presence of some attribute or quality shall use the Has* form; e.g., a 
variable such as {\tt hasGrid}.  Variables that indicate a condition shall 
use the Is* form.  In Fortran, these should return {\tt logical}
data type results.  The goals are consistency and clarity.

\subsubsection{Variable Capitalization} 
For method arguments that are multi-word, the first word is lower
case and subsequent words begin with upper case.  ESMF class 
names (including typed flags) are an exception.  When multi-word 
class names appear in argument lists, all letters after the first 
are lower case.  The first letter is lower case if the class is the
first word in the argument and upper case otherwise.  For 
example, in an argument list the DELayout class name may appear 
as {\tt delayout} or {\tt srcDelayout}.

\subsubsection{Variables Associated with Options}
Variables associated with flags or option shall have the same name as
the option (as long as it is not too awkward); for example, an option 
{\tt ESMF\_Sync\_Flag} has an associated argument {\tt syncflag}.

\subsubsection{Variables Having Logical Data Type}
Variables associated with flags or other boolean values shall use
the Fortran {\tt logical} data type in the public ESMF API.  The {\tt ESMF\_Logical}
derived type shall only be used in Fortran code internally, for example when passing
logical values between Fortran and C++ code.

\subsubsection{Arguments which are Arrays}
Arguments which are arrays shall use the Fortran assumed-shape passing style.
This allows the procedure to use intrinsic functions such as {\tt size},
{\tt lbound}, and {\tt ubound} within the method to determine array
dimension sizes.  Also, ESMF convention is to place the array specification
following the variable name, rather than by using the {\tt dimension}
attribute or a separate {\tt dimension} statement.  For example:
\begin{verbatim}
    type(ESMF_Field), intent(in) :: fieldList(:)
\end{verbatim}

\subsubsection{Arguments which are Pointers}
Arguments which are pointers may point to either scalar or array targets.
Pointers are typically used when an object must be allocated within the method
and returned to the caller.  A second use is when the original array bounds
must be maintained.  No {\tt intent} attributes are currently used with
pointers because they are not part of Fortran-90 or Fortran-95.

\subsection{Code: File Rules} 

\subsubsection{Version Identification} 
The first line of every file in ESMF
  must be its CVS version identification. For example, each \LaTeX\ 
  file must begin:
\begin{verbatim}
% $Id$ 
\end{verbatim}

In addition, for source code, the CVS identifier must have the 
ability to be written to a variable for output to a configuration log.  
Therefore each F90 module must contain a declaration:
\begin{verbatim}
character(len=80), private :: version = '$Id$'
\end{verbatim}

\subsubsection{License and Copyright Information}

Source and documentation files must contain the ESMF license and 
copyright header:

\begin{verbatim}
! Earth System Modeling Framework
! Copyright 2002-2018, University Corporation for Atmospheric Research,
! Massachusetts Institute of Technology, Geophysical Fluid Dynamics
! Laboratory, University of Michigan, National Centers for Environmental
! Prediction, Los Alamos National Laboratory, Argonne National Laboratory,
! NASA Goddard Space Flight Center.
! Licensed under the University of Illinois-NCSA License.
\end{verbatim}

\subsubsection{TODO: Reminder} 
To identify code sections that need
additional work or other pending activity that must be done before a release,
the code will be marked with a {\tt TODO} identifier. 
\begin{verbatim}
example:
! TODO: add support for other data types (CMD 4/01).
\end{verbatim}
This will allow developers to 'grep' source files before software releases. 

\subsubsection{FILENAME Macros}
Source code files should define the {/tt ESMF\_FILENAME} or {/tt ESMC\_FILENAME}
macros to ensure that the filename is correctly displayed from the ESMF logging.
This can be done using the following code:

\begin{verbatim}
#define ESMC_FILENAME "./src/Infrastructure/Attribute/src/ESMCI_Attribute.C"
\end{verbatim}

with the appropriate filename.  Note that the path is relative to the ESMF
root directory.

\subsection{Code: Style Rules for Source Code}

General style recommendations for source code include the following:

\begin{enumerate}
\item Limiting the text width to 80 characters;
\item Each class implementation will be in a single file;
\item The use of proper indentation of loops and blocks;
\item The liberal use of blank lines to delimit code blocks;
\item The use of comment lines of dashes or dots to delimit
  procedures;
\item The use of useful descriptive names for physically meaningful
  variables; short conventional names for iterators (e.g
  \texttt{(i,j,k)} for spatial grid indices);
\item The use of short comments on the same line to identify variables
  (i.e using \texttt{!} or \texttt{//}); longer comments in
  well-delineated blocks to describe what a portion of code is doing;
\item Compact code units: long procedures should be split up if
  possible. 200 lines is a rule-of-thumb procedure length limit.
\item Use of global variables or public class variables should be
kept to a minimum to increase encapsulation and ensure modular code.
\end{enumerate}















